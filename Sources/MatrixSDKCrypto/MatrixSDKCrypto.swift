// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MatrixSDKCryptoFFI)
import MatrixSDKCryptoFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * Backup keys and information we load from the store.
 */
public protocol BackupKeysProtocol : AnyObject {
    
    /**
     * Get the backups version that we're holding on to.
     */
    func backupVersion()  -> String
    
    /**
     * Get the recovery key that we're holding on to.
     */
    func recoveryKey()  -> BackupRecoveryKey
    
}

/**
 * Backup keys and information we load from the store.
 */
open class BackupKeys:
    BackupKeysProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_backupkeys(self.pointer, $0) }
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_backupkeys(pointer, $0) }
    }

    

    
    
    /**
     * Get the backups version that we're holding on to.
     */
    open func backupVersion()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backupkeys_backup_version(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the recovery key that we're holding on to.
     */
    open func recoveryKey()  -> BackupRecoveryKey {
        return try!  FfiConverterTypeBackupRecoveryKey.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backupkeys_recovery_key(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeBackupKeys: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupKeys

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupKeys {
        return BackupKeys(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BackupKeys) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupKeys {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BackupKeys, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBackupKeys_lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupKeys {
    return try FfiConverterTypeBackupKeys.lift(pointer)
}

public func FfiConverterTypeBackupKeys_lower(_ value: BackupKeys) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBackupKeys.lower(value)
}




/**
 * The private part of the backup key, the one used for recovery.
 */
public protocol BackupRecoveryKeyProtocol : AnyObject {
    
    /**
     * Try to decrypt a message that was encrypted using the public part of the
     * backup key.
     */
    func decryptV1(ephemeralKey: String, mac: String, ciphertext: String) throws  -> String
    
    /**
     * Get the public part of the backup key.
     */
    func megolmV1PublicKey()  -> MegolmV1BackupKey
    
    /**
     * Convert the recovery key to a base 58 encoded string.
     */
    func toBase58()  -> String
    
    /**
     * Convert the recovery key to a base 64 encoded string.
     */
    func toBase64()  -> String
    
}

/**
 * The private part of the backup key, the one used for recovery.
 */
open class BackupRecoveryKey:
    BackupRecoveryKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_backuprecoverykey(self.pointer, $0) }
    }
    /**
     * Create a new random [`BackupRecoveryKey`].
     */
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_new($0)
})
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_backuprecoverykey(pointer, $0) }
    }

    
    /**
     * Try to create a [`BackupRecoveryKey`] from a base 58 encoded string.
     */
    public static func fromBase58(key: String) throws  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeDecodeError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_from_base58(
        FfiConverterString.lower(key),$0)
})
    }

    
    /**
     * Try to create a [`BackupRecoveryKey`] from a base 64 encoded string.
     */
    public static func fromBase64(key: String) throws  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeDecodeError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_from_base64(
        FfiConverterString.lower(key),$0)
})
    }

    
    /**
     * Restore a [`BackupRecoveryKey`] from the given passphrase.
     */
    public static func fromPassphrase(passphrase: String, salt: String, rounds: Int32)  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_from_passphrase(
        FfiConverterString.lower(passphrase),
        FfiConverterString.lower(salt),
        FfiConverterInt32.lower(rounds),$0)
})
    }

    
    /**
     * Create a new [`BackupRecoveryKey`] from the given passphrase.
     */
    public static func newFromPassphrase(passphrase: String)  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_new_from_passphrase(
        FfiConverterString.lower(passphrase),$0)
})
    }

    

    
    
    /**
     * Try to decrypt a message that was encrypted using the public part of the
     * backup key.
     */
    open func decryptV1(ephemeralKey: String, mac: String, ciphertext: String) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePkDecryptionError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_backuprecoverykey_decrypt_v1(self.uniffiClonePointer(), 
        FfiConverterString.lower(ephemeralKey),
        FfiConverterString.lower(mac),
        FfiConverterString.lower(ciphertext),$0
    )
}
        )
    }
    /**
     * Get the public part of the backup key.
     */
    open func megolmV1PublicKey()  -> MegolmV1BackupKey {
        return try!  FfiConverterTypeMegolmV1BackupKey.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backuprecoverykey_megolm_v1_public_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Convert the recovery key to a base 58 encoded string.
     */
    open func toBase58()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backuprecoverykey_to_base58(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Convert the recovery key to a base 64 encoded string.
     */
    open func toBase64()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backuprecoverykey_to_base64(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeBackupRecoveryKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupRecoveryKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BackupRecoveryKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupRecoveryKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BackupRecoveryKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBackupRecoveryKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupRecoveryKey {
    return try FfiConverterTypeBackupRecoveryKey.lift(pointer)
}

public func FfiConverterTypeBackupRecoveryKey_lower(_ value: BackupRecoveryKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBackupRecoveryKey.lower(value)
}




public protocol DehydratedDeviceProtocol : AnyObject {
    
    func keysForUpload(deviceDisplayName: String, pickleKey: Data) throws  -> UploadDehydratedDeviceRequest
    
}

open class DehydratedDevice:
    DehydratedDeviceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_dehydrateddevice(self.pointer, $0) }
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_dehydrateddevice(pointer, $0) }
    }

    

    
    
    open func keysForUpload(deviceDisplayName: String, pickleKey: Data) throws  -> UploadDehydratedDeviceRequest {
        return try  FfiConverterTypeUploadDehydratedDeviceRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeDehydrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_dehydrateddevice_keys_for_upload(self.uniffiClonePointer(), 
        FfiConverterString.lower(deviceDisplayName),
        FfiConverterData.lower(pickleKey),$0
    )
}
        )
    }

}

public struct FfiConverterTypeDehydratedDevice: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DehydratedDevice

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DehydratedDevice {
        return DehydratedDevice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DehydratedDevice) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DehydratedDevice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DehydratedDevice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDehydratedDevice_lift(_ pointer: UnsafeMutableRawPointer) throws -> DehydratedDevice {
    return try FfiConverterTypeDehydratedDevice.lift(pointer)
}

public func FfiConverterTypeDehydratedDevice_lower(_ value: DehydratedDevice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDehydratedDevice.lower(value)
}




public protocol DehydratedDevicesProtocol : AnyObject {
    
    func create() throws  -> DehydratedDevice
    
    func rehydrate(pickleKey: Data, deviceId: String, deviceData: String) throws  -> RehydratedDevice
    
}

open class DehydratedDevices:
    DehydratedDevicesProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_dehydrateddevices(self.pointer, $0) }
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_dehydrateddevices(pointer, $0) }
    }

    

    
    
    open func create() throws  -> DehydratedDevice {
        return try  FfiConverterTypeDehydratedDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeDehydrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_dehydrateddevices_create(self.uniffiClonePointer(), $0
    )
}
        )
    }
    open func rehydrate(pickleKey: Data, deviceId: String, deviceData: String) throws  -> RehydratedDevice {
        return try  FfiConverterTypeRehydratedDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeDehydrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_dehydrateddevices_rehydrate(self.uniffiClonePointer(), 
        FfiConverterData.lower(pickleKey),
        FfiConverterString.lower(deviceId),
        FfiConverterString.lower(deviceData),$0
    )
}
        )
    }

}

public struct FfiConverterTypeDehydratedDevices: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DehydratedDevices

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DehydratedDevices {
        return DehydratedDevices(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DehydratedDevices) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DehydratedDevices {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DehydratedDevices, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDehydratedDevices_lift(_ pointer: UnsafeMutableRawPointer) throws -> DehydratedDevices {
    return try FfiConverterTypeDehydratedDevices.lift(pointer)
}

public func FfiConverterTypeDehydratedDevices_lower(_ value: DehydratedDevices) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDehydratedDevices.lower(value)
}




/**
 * A high level state machine that handles E2EE for Matrix.
 */
public protocol OlmMachineProtocol : AnyObject {
    
    /**
     * Are we able to encrypt room keys.
     *
     * This returns true if we have an active `BackupKey` and backup version
     * registered with the state machine.
     */
    func backupEnabled()  -> Bool
    
    /**
     * Encrypt a batch of room keys and return a request that needs to be sent
     * out to backup the room keys.
     */
    func backupRoomKeys() throws  -> Request?
    
    /**
     * Create a new private cross signing identity and create a request to
     * upload the public part of it to the server.
     */
    func bootstrapCrossSigning() throws  -> BootstrapCrossSigningResult
    
    /**
     * Encrypt the given event with the given type and content for the given
     * device. This method is used to send an event to a specific device.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user who owns the target device.
     * * `device_id` - The ID of the device to which the message will be sent.
     * * `event_type` - The event type.
     * * `content` - The serialized content of the event.
     *
     * # Returns
     * A `Result` containing the request to be sent out if the encryption was
     * successful. If the device is not found, the result will be `Ok(None)`.
     *
     * The caller should ensure that there is an olm session (see
     * `get_missing_sessions`) with the target device before calling this
     * method.
     */
    func createEncryptedToDeviceRequest(userId: String, deviceId: String, eventType: String, content: String) throws  -> Request?
    
    /**
     * Get the status of the private cross signing keys.
     *
     * This can be used to check which private cross signing keys we have
     * stored locally.
     */
    func crossSigningStatus()  -> CrossSigningStatus
    
    /**
     * Decrypt the given event that was sent in the given room.
     *
     * # Arguments
     *
     * * `event` - The serialized encrypted version of the event.
     *
     * * `room_id` - The unique id of the room where the event was sent to.
     *
     * * `strict_shields` - If `true`, messages will be decorated with strict
     * warnings (use `false` to match legacy behaviour where unsafe keys have
     * lower severity warnings and unverified identities are not decorated).
     */
    func decryptRoomEvent(event: String, roomId: String, handleVerificationEvents: Bool, strictShields: Bool) throws  -> DecryptedEvent
    
    /**
     * Manage dehydrated devices.
     */
    func dehydratedDevices()  -> DehydratedDevices
    
    /**
     * Get the device ID of the device of this `OlmMachine`.
     */
    func deviceId()  -> String
    
    /**
     * Disable and reset our backup state.
     *
     * This will remove any pending backup request, remove the backup key and
     * reset the backup state of each room key we have.
     */
    func disableBackup() throws 
    
    /**
     * Discard the currently active room key for the given room if there is
     * one.
     */
    func discardRoomKey(roomId: String) throws 
    
    /**
     * Activate the given backup key to be used with the given backup version.
     *
     * **Warning**: The caller needs to make sure that the given `BackupKey` is
     * trusted, otherwise we might be encrypting room keys that a malicious
     * party could decrypt.
     *
     * The [`OlmMachine::verify_backup`] method can be used to so.
     */
    func enableBackupV1(key: MegolmV1BackupKey, version: String) throws 
    
    /**
     * Encrypt the given event with the given type and content for the given
     * room.
     *
     * **Note**: A room key needs to be shared with the group of users that are
     * members in the given room. If this is not done this method will panic.
     *
     * The usual flow to encrypt an event using this state machine is as
     * follows:
     *
     * 1. Get the one-time key claim request to establish 1:1 Olm sessions for
     * the room members of the room we wish to participate in. This is done
     * using the [`get_missing_sessions()`](Self::get_missing_sessions)
     * method. This method call should be locked per call.
     *
     * 2. Share a room key with all the room members using the
     * [`share_room_key()`](Self::share_room_key). This method call should
     * be locked per room.
     *
     * 3. Encrypt the event using this method.
     *
     * 4. Send the encrypted event to the server.
     *
     * After the room key is shared steps 1 and 2 will become noops, unless
     * there's some changes in the room membership or in the list of devices a
     * member has.
     *
     * # Arguments
     *
     * * `room_id` - The unique id of the room where the event will be sent to.
     *
     * * `even_type` - The type of the event.
     *
     * * `content` - The serialized content of the event.
     */
    func encrypt(roomId: String, eventType: String, content: String) throws  -> String
    
    /**
     * Export all our private cross signing keys.
     *
     * The export will contain the seed for the ed25519 keys as a base64
     * encoded string.
     *
     * This method returns `None` if we don't have any private cross signing
     * keys.
     */
    func exportCrossSigningKeys() throws  -> CrossSigningKeyExport?
    
    /**
     * Export all of our room keys.
     *
     * # Arguments
     *
     * * `passphrase` - The passphrase that should be used to encrypt the key
     * export.
     *
     * * `rounds` - The number of rounds that should be used when expanding the
     * passphrase into an key.
     */
    func exportRoomKeys(passphrase: String, rounds: Int32) throws  -> String
    
    /**
     * Get the backup keys we have saved in our crypto store.
     */
    func getBackupKeys() throws  -> BackupKeys?
    
    /**
     * Get a `Device` from the store.
     *
     * # Arguments
     *
     * * `user_id` - The id of the device owner.
     *
     * * `device_id` - The id of the device itself.
     *
     * * `timeout` - The time in seconds we should wait before returning if
     * the user's device list has been marked as stale. Passing a 0 as the
     * timeout means that we won't wait at all. **Note**, this assumes that
     * the requests from [`OlmMachine::outgoing_requests`] are being processed
     * and sent out. Namely, this waits for a `/keys/query` response to be
     * received.
     */
    func getDevice(userId: String, deviceId: String, timeout: UInt32) throws  -> Device?
    
    /**
     * Get a cross signing user identity for the given user ID.
     *
     * # Arguments
     *
     * * `user_id` - The unique id of the user that the identity belongs to
     *
     * * `timeout` - The time in seconds we should wait before returning if
     * the user's device list has been marked as stale. Passing a 0 as the
     * timeout means that we won't wait at all. **Note**, this assumes that
     * the requests from [`OlmMachine::outgoing_requests`] are being processed
     * and sent out. Namely, this waits for a `/keys/query` response to be
     * received.
     */
    func getIdentity(userId: String, timeout: UInt32) throws  -> UserIdentity?
    
    /**
     * Generate one-time key claiming requests for all the users we are missing
     * sessions for.
     *
     * After the request was sent out and a successful response was received
     * the response body should be passed back to the state machine using the
     * [mark_request_as_sent()](Self::mark_request_as_sent) method.
     *
     * This method should be called every time before a call to
     * [`share_room_key()`](Self::share_room_key) is made.
     *
     * # Arguments
     *
     * * `users` - The list of users for which we would like to establish 1:1
     * Olm sessions for.
     */
    func getMissingSessions(users: [String]) throws  -> Request?
    
    /**
     * Check whether there is a global flag to only encrypt messages for
     * trusted devices or for everyone.
     *
     * Note that if the global flag is false, individual rooms may still be
     * encrypting only for trusted devices, depending on the per-room
     * `only_allow_trusted_devices` flag.
     */
    func getOnlyAllowTrustedDevices() throws  -> Bool
    
    /**
     * Get the stored room settings, such as the encryption algorithm or
     * whether to encrypt only for trusted devices.
     *
     * These settings can be modified via
     * [set_room_algorithm()](Self::set_room_algorithm) and
     * [set_room_only_allow_trusted_devices()](Self::set_room_only_allow_trusted_devices)
     * methods.
     */
    func getRoomSettings(roomId: String) throws  -> RoomSettings?
    
    /**
     * Get all devices of an user.
     *
     * # Arguments
     *
     * * `user_id` - The id of the device owner.
     *
     * * `timeout` - The time in seconds we should wait before returning if
     * the user's device list has been marked as stale. Passing a 0 as the
     * timeout means that we won't wait at all. **Note**, this assumes that
     * the requests from [`OlmMachine::outgoing_requests`] are being processed
     * and sent out. Namely, this waits for a `/keys/query` response to be
     * received.
     */
    func getUserDevices(userId: String, timeout: UInt32) throws  -> [Device]
    
    /**
     * Get a verification flow object for the given user with the given flow
     * id.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to fetch the
     * verification.
     *
     * * `flow_id` - The ID that uniquely identifies the verification flow.
     */
    func getVerification(userId: String, flowId: String)  -> Verification?
    
    /**
     * Get a verification requests that we share with the given user with the
     * given flow id.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to fetch the
     * verification requests.
     *
     * * `flow_id` - The ID that uniquely identifies the verification flow.
     */
    func getVerificationRequest(userId: String, flowId: String)  -> VerificationRequest?
    
    /**
     * Get all the verification requests that we share with the given user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to fetch the
     * verification requests.
     */
    func getVerificationRequests(userId: String)  -> [VerificationRequest]
    
    /**
     * Get our own identity keys.
     */
    func identityKeys()  -> [String: String]
    
    /**
     * Import our private cross signing keys.
     *
     * The export needs to contain the seed for the ed25519 keys as a base64
     * encoded string.
     */
    func importCrossSigningKeys(export: CrossSigningKeyExport) throws 
    
    /**
     * Import room keys from the given serialized unencrypted key export.
     *
     * This method is the same as [`OlmMachine::import_room_keys`] but the
     * decryption step is skipped and should be performed by the caller. This
     * should be used if the room keys are coming from the server-side backup,
     * the method will mark all imported room keys as backed up.
     *
     * # Arguments
     *
     * * `keys` - The serialized version of the unencrypted key export.
     *
     * * `progress_listener` - A callback that can be used to introspect the
     * progress of the key import.
     */
    func importDecryptedRoomKeys(keys: String, progressListener: ProgressListener) throws  -> KeysImportResult
    
    /**
     * Import room keys from the given serialized key export.
     *
     * # Arguments
     *
     * * `keys` - The serialized version of the key export.
     *
     * * `passphrase` - The passphrase that was used to encrypt the key export.
     *
     * * `progress_listener` - A callback that can be used to introspect the
     * progress of the key import.
     */
    func importRoomKeys(keys: String, passphrase: String, progressListener: ProgressListener) throws  -> KeysImportResult
    
    /**
     * Check if a user identity is considered to be verified by us.
     */
    func isIdentityVerified(userId: String) throws  -> Bool
    
    /**
     * Check if the given user is considered to be tracked.
     *
     * A user can be marked for tracking using the
     * [`OlmMachine::update_tracked_users()`] method.
     */
    func isUserTracked(userId: String) throws  -> Bool
    
    /**
     * Mark a request that was sent to the server as sent.
     *
     * # Arguments
     *
     * * `request_id` - The unique ID of the request that was sent out. This
     * needs to be an UUID.
     *
     * * `request_type` - The type of the request that was sent out.
     *
     * * `response_body` - The body of the response that was received.
     */
    func markRequestAsSent(requestId: String, requestType: RequestType, responseBody: String) throws 
    
    /**
     * Get the list of outgoing requests that need to be sent to the
     * homeserver.
     *
     * After the request was sent out and a successful response was received
     * the response body should be passed back to the state machine using the
     * [mark_request_as_sent()](Self::mark_request_as_sent) method.
     *
     * **Note**: This method call should be locked per call.
     */
    func outgoingRequests() throws  -> [Request]
    
    /**
     * Request missing local secrets from our devices (cross signing private
     * keys, megolm backup). This will ask the sdk to create outgoing
     * request to get the missing secrets.
     *
     * The requests will be processed as soon as `outgoing_requests()` is
     * called to process them.
     */
    func queryMissingSecretsFromOtherSessions() throws  -> Bool
    
    /**
     * Let the state machine know about E2EE related sync changes that we
     * received from the server.
     *
     * This needs to be called after every sync, ideally before processing
     * any other sync changes.
     *
     * # Arguments
     *
     * * `events` - A serialized array of to-device events we received in the
     * current sync response.
     *
     * * `device_changes` - The list of devices that have changed in some way
     * since the previous sync.
     *
     * * `key_counts` - The map of uploaded one-time key types and counts.
     */
    func receiveSyncChanges(events: String, deviceChanges: DeviceLists, keyCounts: [String: Int32], unusedFallbackKeys: [String]?, nextBatchToken: String) throws  -> SyncChangesResult
    
    /**
     * Receive an unencrypted verification event.
     *
     * This method can be used to pass verification events that are happening
     * in unencrypted rooms to the `OlmMachine`.
     *
     * **Note**: This has been deprecated.
     */
    func receiveUnencryptedVerificationEvent(event: String, roomId: String) throws 
    
    /**
     * Receive a verification event.
     *
     * This method can be used to pass verification events that are happening
     * in rooms to the `OlmMachine`. The event should be in the decrypted form.
     */
    func receiveVerificationEvent(event: String, roomId: String) throws 
    
    /**
     * Request or re-request a room key that was used to encrypt the given
     * event.
     *
     * # Arguments
     *
     * * `event` - The undecryptable event that we would wish to request a room
     * key for.
     *
     * * `room_id` - The id of the room the event was sent to.
     */
    func requestRoomKey(event: String, roomId: String) throws  -> KeyRequestPair
    
    /**
     * Request a verification flow to begin with our other devices.
     *
     * # Arguments
     *
     * `methods` - The list of verification methods we want to advertise to
     * support.
     */
    func requestSelfVerification(methods: [String]) throws  -> RequestVerificationResult?
    
    /**
     * Request a verification flow to begin with the given user in the given
     * room.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user which we would like to request to
     * verify.
     *
     * * `room_id` - The ID of the room that represents a DM with the given
     * user.
     *
     * * `event_id` - The event ID of the `m.key.verification.request` event
     * that we sent out to request the verification to begin. The content for
     * this request can be created using the [verification_request_content()]
     * method.
     *
     * * `methods` - The list of verification methods we advertised as
     * supported in the `m.key.verification.request` event.
     *
     * [verification_request_content()]: Self::verification_request_content
     */
    func requestVerification(userId: String, roomId: String, eventId: String, methods: [String]) throws  -> VerificationRequest?
    
    /**
     * Request a verification flow to begin with the given user's device.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user which we would like to request to
     * verify.
     *
     * * `device_id` - The ID of the device that we wish to verify.
     *
     * * `methods` - The list of verification methods we advertised as
     * supported in the `m.key.verification.request` event.
     */
    func requestVerificationWithDevice(userId: String, deviceId: String, methods: [String]) throws  -> RequestVerificationResult?
    
    /**
     * Get the number of backed up room keys and the total number of room keys.
     */
    func roomKeyCounts() throws  -> RoomKeyCounts
    
    /**
     * Store the recovery key in the crypto store.
     *
     * This is useful if the client wants to support gossiping of the backup
     * key.
     */
    func saveRecoveryKey(key: BackupRecoveryKey?, version: String?) throws 
    
    /**
     * Set local trust state for the device of the given user without creating
     * or uploading any signatures if verified
     */
    func setLocalTrust(userId: String, deviceId: String, trustState: LocalTrust) throws 
    
    /**
     * Set global flag whether to encrypt messages for untrusted devices, or
     * whether they should be excluded from the conversation.
     *
     * Note that if enabled, it will override any per-room settings.
     */
    func setOnlyAllowTrustedDevices(onlyAllowTrustedDevices: Bool) throws 
    
    /**
     * Set the room algorithm used for encrypting messages to one of the
     * available variants
     */
    func setRoomAlgorithm(roomId: String, algorithm: EventEncryptionAlgorithm) throws 
    
    /**
     * Set flag whether this room should encrypt messages for untrusted
     * devices, or whether they should be excluded from the conversation.
     *
     * Note that per-room setting may be overridden by a global
     * [set_only_allow_trusted_devices()](Self::set_only_allow_trusted_devices)
     * method.
     */
    func setRoomOnlyAllowTrustedDevices(roomId: String, onlyAllowTrustedDevices: Bool) throws 
    
    /**
     * Shares historical room keys used in previous sessions with the list of
     * users for the given room.
     *
     * After the request was sent out and a successful response was received
     * the response body should be passed back to the state machine using the
     * [mark_request_as_sent()](Self::mark_request_as_sent) method.
     *
     * This method should be called after users have been invited to the room.
     *
     * # Arguments
     *
     * * `room_id` - The unique id of the room of which previous room keys
     * will be sent out.
     *
     * * `users` - The list of users which are considered to be members of the
     * room and should receive previous room keys.
     */
    func shareRoomHistoryKeys(roomId: String, users: [String]) throws  -> [Request]
    
    /**
     * Share a room key with the given list of users for the given room.
     *
     * After the request was sent out and a successful response was received
     * the response body should be passed back to the state machine using the
     * [mark_request_as_sent()](Self::mark_request_as_sent) method.
     *
     * This method should be called every time before a call to
     * [`encrypt()`](Self::encrypt) with the given `room_id` is made.
     *
     * # Arguments
     *
     * * `room_id` - The unique id of the room, note that this doesn't strictly
     * need to be a Matrix room, it just needs to be an unique identifier for
     * the group that will participate in the conversation.
     *
     * * `users` - The list of users which are considered to be members of the
     * room and should receive the room key.
     *
     * * `settings` - The settings that should be used for the room key.
     */
    func shareRoomKey(roomId: String, users: [String], settings: EncryptionSettings) throws  -> [Request]
    
    /**
     * Sign the given message using our device key and if available cross
     * signing master key.
     */
    func sign(message: String) throws  -> [String: [String: String]]
    
    /**
     * Start short auth string verification with a device without going
     * through a verification request first.
     *
     * **Note**: This has been largely deprecated and the
     * [request_verification_with_device()] method should be used instead.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to start the
     * SAS verification.
     *
     * * `device_id` - The ID of device we would like to verify.
     *
     * [request_verification_with_device()]: Self::request_verification_with_device
     */
    func startSasWithDevice(userId: String, deviceId: String) throws  -> StartSasResult?
    
    /**
     * Add the given list of users to be tracked, triggering a key query
     * request for them.
     *
     * The OlmMachine maintains a list of users whose devices we are keeping
     * track of: these are known as "tracked users". These must be users
     * that we share a room with, so that the server sends us updates for
     * their device lists.
     *
     * *Note*: Only users that aren't already tracked will be considered for an
     * update. It's safe to call this with already tracked users, it won't
     * result in excessive `/keys/query` requests.
     *
     * # Arguments
     *
     * `users` - The users that should be queued up for a key query.
     */
    func updateTrackedUsers(users: [String]) throws 
    
    /**
     * Get the user ID of the owner of this `OlmMachine`.
     */
    func userId()  -> String
    
    /**
     * Get an m.key.verification.request content for the given user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user which we would like to request to
     * verify.
     *
     * * `methods` - The list of verification methods we want to advertise to
     * support.
     */
    func verificationRequestContent(userId: String, methods: [String]) throws  -> String?
    
    /**
     * Check if the given backup has been verified by us or by another of our
     * devices that we trust.
     *
     * The `backup_info` should be a JSON encoded object with the following
     * format:
     *
     * ```json
     * {
     * "algorithm": "m.megolm_backup.v1.curve25519-aes-sha2",
     * "auth_data": {
     * "public_key":"XjhWTCjW7l59pbfx9tlCBQolfnIQWARoKOzjTOPSlWM",
     * "signatures": {}
     * }
     * }
     * ```
     */
    func verifyBackup(backupInfo: String) throws  -> SignatureVerification
    
    /**
     * Manually the device of the given user with the given device ID.
     *
     * This method will attempt to sign the device using our private cross
     * signing key.
     *
     * This method will always fail if the device belongs to someone else, we
     * can only sign our own devices.
     *
     * It can also fail if we don't have the private part of our self-signing
     * key.
     *
     * Returns a request that needs to be sent out for the device to be marked
     * as verified.
     */
    func verifyDevice(userId: String, deviceId: String) throws  -> SignatureUploadRequest
    
    /**
     * Manually the user with the given user ID.
     *
     * This method will attempt to sign the user identity using either our
     * private cross signing key, for other user identities, or our device keys
     * for our own user identity.
     *
     * This method can fail if we don't have the private part of our
     * user-signing key.
     *
     * Returns a request that needs to be sent out for the user identity to be
     * marked as verified.
     */
    func verifyIdentity(userId: String) throws  -> SignatureUploadRequest
    
}

/**
 * A high level state machine that handles E2EE for Matrix.
 */
open class OlmMachine:
    OlmMachineProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_olmmachine(self.pointer, $0) }
    }
    /**
     * Create a new `OlmMachine`
     *
     * # Arguments
     *
     * * `user_id` - The unique ID of the user that owns this machine.
     *
     * * `device_id` - The unique ID of the device that owns this machine.
     *
     * * `path` - The path where the state of the machine should be persisted.
     *
     * * `passphrase` - The passphrase that should be used to encrypt the data
     * at rest in the crypto store. **Warning**, if no passphrase is given,
     * the store and all its data will remain unencrypted.
     */
    public convenience init(userId: String, deviceId: String, path: String, passphrase: String?) throws  {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_olmmachine_new(
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterString.lower(path),
        FfiConverterOptionString.lower(passphrase),$0)
})
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_olmmachine(pointer, $0) }
    }

    

    
    
    /**
     * Are we able to encrypt room keys.
     *
     * This returns true if we have an active `BackupKey` and backup version
     * registered with the state machine.
     */
    open func backupEnabled()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_backup_enabled(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Encrypt a batch of room keys and return a request that needs to be sent
     * out to backup the room keys.
     */
    open func backupRoomKeys() throws  -> Request? {
        return try  FfiConverterOptionTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_backup_room_keys(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Create a new private cross signing identity and create a request to
     * upload the public part of it to the server.
     */
    open func bootstrapCrossSigning() throws  -> BootstrapCrossSigningResult {
        return try  FfiConverterTypeBootstrapCrossSigningResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_bootstrap_cross_signing(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Encrypt the given event with the given type and content for the given
     * device. This method is used to send an event to a specific device.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user who owns the target device.
     * * `device_id` - The ID of the device to which the message will be sent.
     * * `event_type` - The event type.
     * * `content` - The serialized content of the event.
     *
     * # Returns
     * A `Result` containing the request to be sent out if the encryption was
     * successful. If the device is not found, the result will be `Ok(None)`.
     *
     * The caller should ensure that there is an olm session (see
     * `get_missing_sessions`) with the target device before calling this
     * method.
     */
    open func createEncryptedToDeviceRequest(userId: String, deviceId: String, eventType: String, content: String) throws  -> Request? {
        return try  FfiConverterOptionTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_create_encrypted_to_device_request(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterString.lower(eventType),
        FfiConverterString.lower(content),$0
    )
}
        )
    }
    /**
     * Get the status of the private cross signing keys.
     *
     * This can be used to check which private cross signing keys we have
     * stored locally.
     */
    open func crossSigningStatus()  -> CrossSigningStatus {
        return try!  FfiConverterTypeCrossSigningStatus.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_cross_signing_status(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Decrypt the given event that was sent in the given room.
     *
     * # Arguments
     *
     * * `event` - The serialized encrypted version of the event.
     *
     * * `room_id` - The unique id of the room where the event was sent to.
     *
     * * `strict_shields` - If `true`, messages will be decorated with strict
     * warnings (use `false` to match legacy behaviour where unsafe keys have
     * lower severity warnings and unverified identities are not decorated).
     */
    open func decryptRoomEvent(event: String, roomId: String, handleVerificationEvents: Bool, strictShields: Bool) throws  -> DecryptedEvent {
        return try  FfiConverterTypeDecryptedEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeDecryptionError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_decrypt_room_event(self.uniffiClonePointer(), 
        FfiConverterString.lower(event),
        FfiConverterString.lower(roomId),
        FfiConverterBool.lower(handleVerificationEvents),
        FfiConverterBool.lower(strictShields),$0
    )
}
        )
    }
    /**
     * Manage dehydrated devices.
     */
    open func dehydratedDevices()  -> DehydratedDevices {
        return try!  FfiConverterTypeDehydratedDevices.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_dehydrated_devices(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the device ID of the device of this `OlmMachine`.
     */
    open func deviceId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_device_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Disable and reset our backup state.
     *
     * This will remove any pending backup request, remove the backup key and
     * reset the backup state of each room key we have.
     */
    open func disableBackup() throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_disable_backup(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Discard the currently active room key for the given room if there is
     * one.
     */
    open func discardRoomKey(roomId: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_discard_room_key(self.uniffiClonePointer(), 
        FfiConverterString.lower(roomId),$0
    )
}
    }
    /**
     * Activate the given backup key to be used with the given backup version.
     *
     * **Warning**: The caller needs to make sure that the given `BackupKey` is
     * trusted, otherwise we might be encrypting room keys that a malicious
     * party could decrypt.
     *
     * The [`OlmMachine::verify_backup`] method can be used to so.
     */
    open func enableBackupV1(key: MegolmV1BackupKey, version: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeDecodeError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_enable_backup_v1(self.uniffiClonePointer(), 
        FfiConverterTypeMegolmV1BackupKey.lower(key),
        FfiConverterString.lower(version),$0
    )
}
    }
    /**
     * Encrypt the given event with the given type and content for the given
     * room.
     *
     * **Note**: A room key needs to be shared with the group of users that are
     * members in the given room. If this is not done this method will panic.
     *
     * The usual flow to encrypt an event using this state machine is as
     * follows:
     *
     * 1. Get the one-time key claim request to establish 1:1 Olm sessions for
     * the room members of the room we wish to participate in. This is done
     * using the [`get_missing_sessions()`](Self::get_missing_sessions)
     * method. This method call should be locked per call.
     *
     * 2. Share a room key with all the room members using the
     * [`share_room_key()`](Self::share_room_key). This method call should
     * be locked per room.
     *
     * 3. Encrypt the event using this method.
     *
     * 4. Send the encrypted event to the server.
     *
     * After the room key is shared steps 1 and 2 will become noops, unless
     * there's some changes in the room membership or in the list of devices a
     * member has.
     *
     * # Arguments
     *
     * * `room_id` - The unique id of the room where the event will be sent to.
     *
     * * `even_type` - The type of the event.
     *
     * * `content` - The serialized content of the event.
     */
    open func encrypt(roomId: String, eventType: String, content: String) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_encrypt(self.uniffiClonePointer(), 
        FfiConverterString.lower(roomId),
        FfiConverterString.lower(eventType),
        FfiConverterString.lower(content),$0
    )
}
        )
    }
    /**
     * Export all our private cross signing keys.
     *
     * The export will contain the seed for the ed25519 keys as a base64
     * encoded string.
     *
     * This method returns `None` if we don't have any private cross signing
     * keys.
     */
    open func exportCrossSigningKeys() throws  -> CrossSigningKeyExport? {
        return try  FfiConverterOptionTypeCrossSigningKeyExport.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_export_cross_signing_keys(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Export all of our room keys.
     *
     * # Arguments
     *
     * * `passphrase` - The passphrase that should be used to encrypt the key
     * export.
     *
     * * `rounds` - The number of rounds that should be used when expanding the
     * passphrase into an key.
     */
    open func exportRoomKeys(passphrase: String, rounds: Int32) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_export_room_keys(self.uniffiClonePointer(), 
        FfiConverterString.lower(passphrase),
        FfiConverterInt32.lower(rounds),$0
    )
}
        )
    }
    /**
     * Get the backup keys we have saved in our crypto store.
     */
    open func getBackupKeys() throws  -> BackupKeys? {
        return try  FfiConverterOptionTypeBackupKeys.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_backup_keys(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get a `Device` from the store.
     *
     * # Arguments
     *
     * * `user_id` - The id of the device owner.
     *
     * * `device_id` - The id of the device itself.
     *
     * * `timeout` - The time in seconds we should wait before returning if
     * the user's device list has been marked as stale. Passing a 0 as the
     * timeout means that we won't wait at all. **Note**, this assumes that
     * the requests from [`OlmMachine::outgoing_requests`] are being processed
     * and sent out. Namely, this waits for a `/keys/query` response to be
     * received.
     */
    open func getDevice(userId: String, deviceId: String, timeout: UInt32) throws  -> Device? {
        return try  FfiConverterOptionTypeDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_device(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterUInt32.lower(timeout),$0
    )
}
        )
    }
    /**
     * Get a cross signing user identity for the given user ID.
     *
     * # Arguments
     *
     * * `user_id` - The unique id of the user that the identity belongs to
     *
     * * `timeout` - The time in seconds we should wait before returning if
     * the user's device list has been marked as stale. Passing a 0 as the
     * timeout means that we won't wait at all. **Note**, this assumes that
     * the requests from [`OlmMachine::outgoing_requests`] are being processed
     * and sent out. Namely, this waits for a `/keys/query` response to be
     * received.
     */
    open func getIdentity(userId: String, timeout: UInt32) throws  -> UserIdentity? {
        return try  FfiConverterOptionTypeUserIdentity.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_identity(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterUInt32.lower(timeout),$0
    )
}
        )
    }
    /**
     * Generate one-time key claiming requests for all the users we are missing
     * sessions for.
     *
     * After the request was sent out and a successful response was received
     * the response body should be passed back to the state machine using the
     * [mark_request_as_sent()](Self::mark_request_as_sent) method.
     *
     * This method should be called every time before a call to
     * [`share_room_key()`](Self::share_room_key) is made.
     *
     * # Arguments
     *
     * * `users` - The list of users for which we would like to establish 1:1
     * Olm sessions for.
     */
    open func getMissingSessions(users: [String]) throws  -> Request? {
        return try  FfiConverterOptionTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_missing_sessions(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(users),$0
    )
}
        )
    }
    /**
     * Check whether there is a global flag to only encrypt messages for
     * trusted devices or for everyone.
     *
     * Note that if the global flag is false, individual rooms may still be
     * encrypting only for trusted devices, depending on the per-room
     * `only_allow_trusted_devices` flag.
     */
    open func getOnlyAllowTrustedDevices() throws  -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_only_allow_trusted_devices(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the stored room settings, such as the encryption algorithm or
     * whether to encrypt only for trusted devices.
     *
     * These settings can be modified via
     * [set_room_algorithm()](Self::set_room_algorithm) and
     * [set_room_only_allow_trusted_devices()](Self::set_room_only_allow_trusted_devices)
     * methods.
     */
    open func getRoomSettings(roomId: String) throws  -> RoomSettings? {
        return try  FfiConverterOptionTypeRoomSettings.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_room_settings(self.uniffiClonePointer(), 
        FfiConverterString.lower(roomId),$0
    )
}
        )
    }
    /**
     * Get all devices of an user.
     *
     * # Arguments
     *
     * * `user_id` - The id of the device owner.
     *
     * * `timeout` - The time in seconds we should wait before returning if
     * the user's device list has been marked as stale. Passing a 0 as the
     * timeout means that we won't wait at all. **Note**, this assumes that
     * the requests from [`OlmMachine::outgoing_requests`] are being processed
     * and sent out. Namely, this waits for a `/keys/query` response to be
     * received.
     */
    open func getUserDevices(userId: String, timeout: UInt32) throws  -> [Device] {
        return try  FfiConverterSequenceTypeDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_user_devices(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterUInt32.lower(timeout),$0
    )
}
        )
    }
    /**
     * Get a verification flow object for the given user with the given flow
     * id.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to fetch the
     * verification.
     *
     * * `flow_id` - The ID that uniquely identifies the verification flow.
     */
    open func getVerification(userId: String, flowId: String)  -> Verification? {
        return try!  FfiConverterOptionTypeVerification.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_verification(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(flowId),$0
    )
}
        )
    }
    /**
     * Get a verification requests that we share with the given user with the
     * given flow id.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to fetch the
     * verification requests.
     *
     * * `flow_id` - The ID that uniquely identifies the verification flow.
     */
    open func getVerificationRequest(userId: String, flowId: String)  -> VerificationRequest? {
        return try!  FfiConverterOptionTypeVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_verification_request(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(flowId),$0
    )
}
        )
    }
    /**
     * Get all the verification requests that we share with the given user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to fetch the
     * verification requests.
     */
    open func getVerificationRequests(userId: String)  -> [VerificationRequest] {
        return try!  FfiConverterSequenceTypeVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_verification_requests(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }
    /**
     * Get our own identity keys.
     */
    open func identityKeys()  -> [String: String] {
        return try!  FfiConverterDictionaryStringString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_identity_keys(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Import our private cross signing keys.
     *
     * The export needs to contain the seed for the ed25519 keys as a base64
     * encoded string.
     */
    open func importCrossSigningKeys(export: CrossSigningKeyExport) throws  {
        try 
    rustCallWithError(FfiConverterTypeSecretImportError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_import_cross_signing_keys(self.uniffiClonePointer(), 
        FfiConverterTypeCrossSigningKeyExport.lower(export),$0
    )
}
    }
    /**
     * Import room keys from the given serialized unencrypted key export.
     *
     * This method is the same as [`OlmMachine::import_room_keys`] but the
     * decryption step is skipped and should be performed by the caller. This
     * should be used if the room keys are coming from the server-side backup,
     * the method will mark all imported room keys as backed up.
     *
     * # Arguments
     *
     * * `keys` - The serialized version of the unencrypted key export.
     *
     * * `progress_listener` - A callback that can be used to introspect the
     * progress of the key import.
     */
    open func importDecryptedRoomKeys(keys: String, progressListener: ProgressListener) throws  -> KeysImportResult {
        return try  FfiConverterTypeKeysImportResult.lift(
            try 
    rustCallWithError(FfiConverterTypeKeyImportError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_import_decrypted_room_keys(self.uniffiClonePointer(), 
        FfiConverterString.lower(keys),
        FfiConverterCallbackInterfaceProgressListener.lower(progressListener),$0
    )
}
        )
    }
    /**
     * Import room keys from the given serialized key export.
     *
     * # Arguments
     *
     * * `keys` - The serialized version of the key export.
     *
     * * `passphrase` - The passphrase that was used to encrypt the key export.
     *
     * * `progress_listener` - A callback that can be used to introspect the
     * progress of the key import.
     */
    open func importRoomKeys(keys: String, passphrase: String, progressListener: ProgressListener) throws  -> KeysImportResult {
        return try  FfiConverterTypeKeysImportResult.lift(
            try 
    rustCallWithError(FfiConverterTypeKeyImportError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_import_room_keys(self.uniffiClonePointer(), 
        FfiConverterString.lower(keys),
        FfiConverterString.lower(passphrase),
        FfiConverterCallbackInterfaceProgressListener.lower(progressListener),$0
    )
}
        )
    }
    /**
     * Check if a user identity is considered to be verified by us.
     */
    open func isIdentityVerified(userId: String) throws  -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_is_identity_verified(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }
    /**
     * Check if the given user is considered to be tracked.
     *
     * A user can be marked for tracking using the
     * [`OlmMachine::update_tracked_users()`] method.
     */
    open func isUserTracked(userId: String) throws  -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_is_user_tracked(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }
    /**
     * Mark a request that was sent to the server as sent.
     *
     * # Arguments
     *
     * * `request_id` - The unique ID of the request that was sent out. This
     * needs to be an UUID.
     *
     * * `request_type` - The type of the request that was sent out.
     *
     * * `response_body` - The body of the response that was received.
     */
    open func markRequestAsSent(requestId: String, requestType: RequestType, responseBody: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_mark_request_as_sent(self.uniffiClonePointer(), 
        FfiConverterString.lower(requestId),
        FfiConverterTypeRequestType.lower(requestType),
        FfiConverterString.lower(responseBody),$0
    )
}
    }
    /**
     * Get the list of outgoing requests that need to be sent to the
     * homeserver.
     *
     * After the request was sent out and a successful response was received
     * the response body should be passed back to the state machine using the
     * [mark_request_as_sent()](Self::mark_request_as_sent) method.
     *
     * **Note**: This method call should be locked per call.
     */
    open func outgoingRequests() throws  -> [Request] {
        return try  FfiConverterSequenceTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_outgoing_requests(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Request missing local secrets from our devices (cross signing private
     * keys, megolm backup). This will ask the sdk to create outgoing
     * request to get the missing secrets.
     *
     * The requests will be processed as soon as `outgoing_requests()` is
     * called to process them.
     */
    open func queryMissingSecretsFromOtherSessions() throws  -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_query_missing_secrets_from_other_sessions(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Let the state machine know about E2EE related sync changes that we
     * received from the server.
     *
     * This needs to be called after every sync, ideally before processing
     * any other sync changes.
     *
     * # Arguments
     *
     * * `events` - A serialized array of to-device events we received in the
     * current sync response.
     *
     * * `device_changes` - The list of devices that have changed in some way
     * since the previous sync.
     *
     * * `key_counts` - The map of uploaded one-time key types and counts.
     */
    open func receiveSyncChanges(events: String, deviceChanges: DeviceLists, keyCounts: [String: Int32], unusedFallbackKeys: [String]?, nextBatchToken: String) throws  -> SyncChangesResult {
        return try  FfiConverterTypeSyncChangesResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_receive_sync_changes(self.uniffiClonePointer(), 
        FfiConverterString.lower(events),
        FfiConverterTypeDeviceLists.lower(deviceChanges),
        FfiConverterDictionaryStringInt32.lower(keyCounts),
        FfiConverterOptionSequenceString.lower(unusedFallbackKeys),
        FfiConverterString.lower(nextBatchToken),$0
    )
}
        )
    }
    /**
     * Receive an unencrypted verification event.
     *
     * This method can be used to pass verification events that are happening
     * in unencrypted rooms to the `OlmMachine`.
     *
     * **Note**: This has been deprecated.
     */
    open func receiveUnencryptedVerificationEvent(event: String, roomId: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_receive_unencrypted_verification_event(self.uniffiClonePointer(), 
        FfiConverterString.lower(event),
        FfiConverterString.lower(roomId),$0
    )
}
    }
    /**
     * Receive a verification event.
     *
     * This method can be used to pass verification events that are happening
     * in rooms to the `OlmMachine`. The event should be in the decrypted form.
     */
    open func receiveVerificationEvent(event: String, roomId: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_receive_verification_event(self.uniffiClonePointer(), 
        FfiConverterString.lower(event),
        FfiConverterString.lower(roomId),$0
    )
}
    }
    /**
     * Request or re-request a room key that was used to encrypt the given
     * event.
     *
     * # Arguments
     *
     * * `event` - The undecryptable event that we would wish to request a room
     * key for.
     *
     * * `room_id` - The id of the room the event was sent to.
     */
    open func requestRoomKey(event: String, roomId: String) throws  -> KeyRequestPair {
        return try  FfiConverterTypeKeyRequestPair.lift(
            try 
    rustCallWithError(FfiConverterTypeDecryptionError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_request_room_key(self.uniffiClonePointer(), 
        FfiConverterString.lower(event),
        FfiConverterString.lower(roomId),$0
    )
}
        )
    }
    /**
     * Request a verification flow to begin with our other devices.
     *
     * # Arguments
     *
     * `methods` - The list of verification methods we want to advertise to
     * support.
     */
    open func requestSelfVerification(methods: [String]) throws  -> RequestVerificationResult? {
        return try  FfiConverterOptionTypeRequestVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_request_self_verification(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }
    /**
     * Request a verification flow to begin with the given user in the given
     * room.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user which we would like to request to
     * verify.
     *
     * * `room_id` - The ID of the room that represents a DM with the given
     * user.
     *
     * * `event_id` - The event ID of the `m.key.verification.request` event
     * that we sent out to request the verification to begin. The content for
     * this request can be created using the [verification_request_content()]
     * method.
     *
     * * `methods` - The list of verification methods we advertised as
     * supported in the `m.key.verification.request` event.
     *
     * [verification_request_content()]: Self::verification_request_content
     */
    open func requestVerification(userId: String, roomId: String, eventId: String, methods: [String]) throws  -> VerificationRequest? {
        return try  FfiConverterOptionTypeVerificationRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_request_verification(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(roomId),
        FfiConverterString.lower(eventId),
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }
    /**
     * Request a verification flow to begin with the given user's device.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user which we would like to request to
     * verify.
     *
     * * `device_id` - The ID of the device that we wish to verify.
     *
     * * `methods` - The list of verification methods we advertised as
     * supported in the `m.key.verification.request` event.
     */
    open func requestVerificationWithDevice(userId: String, deviceId: String, methods: [String]) throws  -> RequestVerificationResult? {
        return try  FfiConverterOptionTypeRequestVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_request_verification_with_device(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }
    /**
     * Get the number of backed up room keys and the total number of room keys.
     */
    open func roomKeyCounts() throws  -> RoomKeyCounts {
        return try  FfiConverterTypeRoomKeyCounts.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_room_key_counts(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Store the recovery key in the crypto store.
     *
     * This is useful if the client wants to support gossiping of the backup
     * key.
     */
    open func saveRecoveryKey(key: BackupRecoveryKey?, version: String?) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_save_recovery_key(self.uniffiClonePointer(), 
        FfiConverterOptionTypeBackupRecoveryKey.lower(key),
        FfiConverterOptionString.lower(version),$0
    )
}
    }
    /**
     * Set local trust state for the device of the given user without creating
     * or uploading any signatures if verified
     */
    open func setLocalTrust(userId: String, deviceId: String, trustState: LocalTrust) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_set_local_trust(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterTypeLocalTrust_lower(trustState),$0
    )
}
    }
    /**
     * Set global flag whether to encrypt messages for untrusted devices, or
     * whether they should be excluded from the conversation.
     *
     * Note that if enabled, it will override any per-room settings.
     */
    open func setOnlyAllowTrustedDevices(onlyAllowTrustedDevices: Bool) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_set_only_allow_trusted_devices(self.uniffiClonePointer(), 
        FfiConverterBool.lower(onlyAllowTrustedDevices),$0
    )
}
    }
    /**
     * Set the room algorithm used for encrypting messages to one of the
     * available variants
     */
    open func setRoomAlgorithm(roomId: String, algorithm: EventEncryptionAlgorithm) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_set_room_algorithm(self.uniffiClonePointer(), 
        FfiConverterString.lower(roomId),
        FfiConverterTypeEventEncryptionAlgorithm.lower(algorithm),$0
    )
}
    }
    /**
     * Set flag whether this room should encrypt messages for untrusted
     * devices, or whether they should be excluded from the conversation.
     *
     * Note that per-room setting may be overridden by a global
     * [set_only_allow_trusted_devices()](Self::set_only_allow_trusted_devices)
     * method.
     */
    open func setRoomOnlyAllowTrustedDevices(roomId: String, onlyAllowTrustedDevices: Bool) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_set_room_only_allow_trusted_devices(self.uniffiClonePointer(), 
        FfiConverterString.lower(roomId),
        FfiConverterBool.lower(onlyAllowTrustedDevices),$0
    )
}
    }
    /**
     * Shares historical room keys used in previous sessions with the list of
     * users for the given room.
     *
     * After the request was sent out and a successful response was received
     * the response body should be passed back to the state machine using the
     * [mark_request_as_sent()](Self::mark_request_as_sent) method.
     *
     * This method should be called after users have been invited to the room.
     *
     * # Arguments
     *
     * * `room_id` - The unique id of the room of which previous room keys
     * will be sent out.
     *
     * * `users` - The list of users which are considered to be members of the
     * room and should receive previous room keys.
     */
    open func shareRoomHistoryKeys(roomId: String, users: [String]) throws  -> [Request] {
        return try  FfiConverterSequenceTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_share_room_history_keys(self.uniffiClonePointer(), 
        FfiConverterString.lower(roomId),
        FfiConverterSequenceString.lower(users),$0
    )
}
        )
    }
    /**
     * Share a room key with the given list of users for the given room.
     *
     * After the request was sent out and a successful response was received
     * the response body should be passed back to the state machine using the
     * [mark_request_as_sent()](Self::mark_request_as_sent) method.
     *
     * This method should be called every time before a call to
     * [`encrypt()`](Self::encrypt) with the given `room_id` is made.
     *
     * # Arguments
     *
     * * `room_id` - The unique id of the room, note that this doesn't strictly
     * need to be a Matrix room, it just needs to be an unique identifier for
     * the group that will participate in the conversation.
     *
     * * `users` - The list of users which are considered to be members of the
     * room and should receive the room key.
     *
     * * `settings` - The settings that should be used for the room key.
     */
    open func shareRoomKey(roomId: String, users: [String], settings: EncryptionSettings) throws  -> [Request] {
        return try  FfiConverterSequenceTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_share_room_key(self.uniffiClonePointer(), 
        FfiConverterString.lower(roomId),
        FfiConverterSequenceString.lower(users),
        FfiConverterTypeEncryptionSettings.lower(settings),$0
    )
}
        )
    }
    /**
     * Sign the given message using our device key and if available cross
     * signing master key.
     */
    open func sign(message: String) throws  -> [String: [String: String]] {
        return try  FfiConverterDictionaryStringDictionaryStringString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_sign(self.uniffiClonePointer(), 
        FfiConverterString.lower(message),$0
    )
}
        )
    }
    /**
     * Start short auth string verification with a device without going
     * through a verification request first.
     *
     * **Note**: This has been largely deprecated and the
     * [request_verification_with_device()] method should be used instead.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to start the
     * SAS verification.
     *
     * * `device_id` - The ID of device we would like to verify.
     *
     * [request_verification_with_device()]: Self::request_verification_with_device
     */
    open func startSasWithDevice(userId: String, deviceId: String) throws  -> StartSasResult? {
        return try  FfiConverterOptionTypeStartSasResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_start_sas_with_device(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),$0
    )
}
        )
    }
    /**
     * Add the given list of users to be tracked, triggering a key query
     * request for them.
     *
     * The OlmMachine maintains a list of users whose devices we are keeping
     * track of: these are known as "tracked users". These must be users
     * that we share a room with, so that the server sends us updates for
     * their device lists.
     *
     * *Note*: Only users that aren't already tracked will be considered for an
     * update. It's safe to call this with already tracked users, it won't
     * result in excessive `/keys/query` requests.
     *
     * # Arguments
     *
     * `users` - The users that should be queued up for a key query.
     */
    open func updateTrackedUsers(users: [String]) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_update_tracked_users(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(users),$0
    )
}
    }
    /**
     * Get the user ID of the owner of this `OlmMachine`.
     */
    open func userId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_user_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get an m.key.verification.request content for the given user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user which we would like to request to
     * verify.
     *
     * * `methods` - The list of verification methods we want to advertise to
     * support.
     */
    open func verificationRequestContent(userId: String, methods: [String]) throws  -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_verification_request_content(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }
    /**
     * Check if the given backup has been verified by us or by another of our
     * devices that we trust.
     *
     * The `backup_info` should be a JSON encoded object with the following
     * format:
     *
     * ```json
     * {
     * "algorithm": "m.megolm_backup.v1.curve25519-aes-sha2",
     * "auth_data": {
     * "public_key":"XjhWTCjW7l59pbfx9tlCBQolfnIQWARoKOzjTOPSlWM",
     * "signatures": {}
     * }
     * }
     * ```
     */
    open func verifyBackup(backupInfo: String) throws  -> SignatureVerification {
        return try  FfiConverterTypeSignatureVerification.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_verify_backup(self.uniffiClonePointer(), 
        FfiConverterString.lower(backupInfo),$0
    )
}
        )
    }
    /**
     * Manually the device of the given user with the given device ID.
     *
     * This method will attempt to sign the device using our private cross
     * signing key.
     *
     * This method will always fail if the device belongs to someone else, we
     * can only sign our own devices.
     *
     * It can also fail if we don't have the private part of our self-signing
     * key.
     *
     * Returns a request that needs to be sent out for the device to be marked
     * as verified.
     */
    open func verifyDevice(userId: String, deviceId: String) throws  -> SignatureUploadRequest {
        return try  FfiConverterTypeSignatureUploadRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeSignatureError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_verify_device(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),$0
    )
}
        )
    }
    /**
     * Manually the user with the given user ID.
     *
     * This method will attempt to sign the user identity using either our
     * private cross signing key, for other user identities, or our device keys
     * for our own user identity.
     *
     * This method can fail if we don't have the private part of our
     * user-signing key.
     *
     * Returns a request that needs to be sent out for the user identity to be
     * marked as verified.
     */
    open func verifyIdentity(userId: String) throws  -> SignatureUploadRequest {
        return try  FfiConverterTypeSignatureUploadRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeSignatureError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_verify_identity(self.uniffiClonePointer(), 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

}

public struct FfiConverterTypeOlmMachine: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OlmMachine

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OlmMachine {
        return OlmMachine(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OlmMachine) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlmMachine {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OlmMachine, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOlmMachine_lift(_ pointer: UnsafeMutableRawPointer) throws -> OlmMachine {
    return try FfiConverterTypeOlmMachine.lift(pointer)
}

public func FfiConverterTypeOlmMachine_lower(_ value: OlmMachine) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOlmMachine.lower(value)
}




/**
 * The `m.qr_code.scan.v1`, `m.qr_code.show.v1`, and `m.reciprocate.v1`
 * verification flow.
 */
public protocol QrCodeProtocol : AnyObject {
    
    /**
     * Cancel the QR code verification using the given cancel code.
     *
     * # Arguments
     *
     * * `cancel_code` - The error code for why the verification was cancelled,
     * manual cancellatio usually happens with `m.user` cancel code. The full
     * list of cancel codes can be found in the [spec]
     *
     * [spec]: https://spec.matrix.org/unstable/client-server-api/#mkeyverificationcancel
     */
    func cancel(cancelCode: String)  -> OutgoingVerificationRequest?
    
    /**
     * Get the CancelInfo of this QR code verification object.
     *
     * Will be `None` if the flow has not been cancelled.
     */
    func cancelInfo()  -> CancelInfo?
    
    /**
     * Confirm a verification was successful.
     *
     * This method should be called if we want to confirm that the other side
     * has scanned our QR code.
     */
    func confirm()  -> ConfirmVerificationResult?
    
    /**
     * Get the unique ID that identifies this QR code verification flow.
     */
    func flowId()  -> String
    
    /**
     * Generate data that should be encoded as a QR code.
     *
     * This method should be called right before a QR code should be displayed,
     * the returned data is base64 encoded (without padding) and needs to be
     * decoded on the other side before it can be put through a QR code
     * generator.
     */
    func generateQrCode()  -> String?
    
    /**
     * Has the QR verification been scanned by the other side.
     *
     * When the verification object is in this state it's required that the
     * user confirms that the other side has scanned the QR code.
     */
    func hasBeenScanned()  -> Bool
    
    /**
     * Has the verification flow been cancelled.
     */
    func isCancelled()  -> Bool
    
    /**
     * Is the QR code verification done.
     */
    func isDone()  -> Bool
    
    /**
     * Get the device ID of the other side.
     */
    func otherDeviceId()  -> String
    
    /**
     * Get the user id of the other side.
     */
    func otherUserId()  -> String
    
    /**
     * Have we successfully scanned the QR code and are able to send a
     * reciprocation event.
     */
    func reciprocated()  -> Bool
    
    /**
     * Get the room id if the verification is happening inside a room.
     */
    func roomId()  -> String?
    
    /**
     * Set a listener for changes in the QrCode verification process.
     *
     * The given callback will be called whenever the state changes.
     */
    func setChangesListener(listener: QrCodeListener) 
    
    /**
     * Get the current state of the QrCode verification process.
     */
    func state()  -> QrCodeState
    
    /**
     * Did we initiate the verification flow.
     */
    func weStarted()  -> Bool
    
}

/**
 * The `m.qr_code.scan.v1`, `m.qr_code.show.v1`, and `m.reciprocate.v1`
 * verification flow.
 */
open class QrCode:
    QrCodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_qrcode(self.pointer, $0) }
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_qrcode(pointer, $0) }
    }

    

    
    
    /**
     * Cancel the QR code verification using the given cancel code.
     *
     * # Arguments
     *
     * * `cancel_code` - The error code for why the verification was cancelled,
     * manual cancellatio usually happens with `m.user` cancel code. The full
     * list of cancel codes can be found in the [spec]
     *
     * [spec]: https://spec.matrix.org/unstable/client-server-api/#mkeyverificationcancel
     */
    open func cancel(cancelCode: String)  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_cancel(self.uniffiClonePointer(), 
        FfiConverterString.lower(cancelCode),$0
    )
}
        )
    }
    /**
     * Get the CancelInfo of this QR code verification object.
     *
     * Will be `None` if the flow has not been cancelled.
     */
    open func cancelInfo()  -> CancelInfo? {
        return try!  FfiConverterOptionTypeCancelInfo.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_cancel_info(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Confirm a verification was successful.
     *
     * This method should be called if we want to confirm that the other side
     * has scanned our QR code.
     */
    open func confirm()  -> ConfirmVerificationResult? {
        return try!  FfiConverterOptionTypeConfirmVerificationResult.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_confirm(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the unique ID that identifies this QR code verification flow.
     */
    open func flowId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_flow_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Generate data that should be encoded as a QR code.
     *
     * This method should be called right before a QR code should be displayed,
     * the returned data is base64 encoded (without padding) and needs to be
     * decoded on the other side before it can be put through a QR code
     * generator.
     */
    open func generateQrCode()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_generate_qr_code(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Has the QR verification been scanned by the other side.
     *
     * When the verification object is in this state it's required that the
     * user confirms that the other side has scanned the QR code.
     */
    open func hasBeenScanned()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_has_been_scanned(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Has the verification flow been cancelled.
     */
    open func isCancelled()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_is_cancelled(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Is the QR code verification done.
     */
    open func isDone()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_is_done(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the device ID of the other side.
     */
    open func otherDeviceId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_other_device_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the user id of the other side.
     */
    open func otherUserId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_other_user_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Have we successfully scanned the QR code and are able to send a
     * reciprocation event.
     */
    open func reciprocated()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_reciprocated(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the room id if the verification is happening inside a room.
     */
    open func roomId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_room_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Set a listener for changes in the QrCode verification process.
     *
     * The given callback will be called whenever the state changes.
     */
    open func setChangesListener(listener: QrCodeListener)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_set_changes_listener(self.uniffiClonePointer(), 
        FfiConverterCallbackInterfaceQrCodeListener.lower(listener),$0
    )
}
    }
    /**
     * Get the current state of the QrCode verification process.
     */
    open func state()  -> QrCodeState {
        return try!  FfiConverterTypeQrCodeState.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_state(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Did we initiate the verification flow.
     */
    open func weStarted()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_we_started(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeQrCode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = QrCode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> QrCode {
        return QrCode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: QrCode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: QrCode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeQrCode_lift(_ pointer: UnsafeMutableRawPointer) throws -> QrCode {
    return try FfiConverterTypeQrCode.lift(pointer)
}

public func FfiConverterTypeQrCode_lower(_ value: QrCode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeQrCode.lower(value)
}




public protocol RehydratedDeviceProtocol : AnyObject {
    
    func receiveEvents(events: String) throws 
    
}

open class RehydratedDevice:
    RehydratedDeviceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_rehydrateddevice(self.pointer, $0) }
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_rehydrateddevice(pointer, $0) }
    }

    

    
    
    open func receiveEvents(events: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_rehydrateddevice_receive_events(self.uniffiClonePointer(), 
        FfiConverterString.lower(events),$0
    )
}
    }

}

public struct FfiConverterTypeRehydratedDevice: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RehydratedDevice

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RehydratedDevice {
        return RehydratedDevice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RehydratedDevice) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RehydratedDevice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RehydratedDevice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRehydratedDevice_lift(_ pointer: UnsafeMutableRawPointer) throws -> RehydratedDevice {
    return try FfiConverterTypeRehydratedDevice.lift(pointer)
}

public func FfiConverterTypeRehydratedDevice_lower(_ value: RehydratedDevice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRehydratedDevice.lower(value)
}




/**
 * The `m.sas.v1` verification flow.
 */
public protocol SasProtocol : AnyObject {
    
    /**
     * Accept that we're going forward with the short auth string verification.
     */
    func accept()  -> OutgoingVerificationRequest?
    
    /**
     * Cancel the SAS verification using the given cancel code.
     *
     * # Arguments
     *
     * * `cancel_code` - The error code for why the verification was cancelled,
     * manual cancellatio usually happens with `m.user` cancel code. The full
     * list of cancel codes can be found in the [spec]
     *
     * [spec]: https://spec.matrix.org/unstable/client-server-api/#mkeyverificationcancel
     */
    func cancel(cancelCode: String)  -> OutgoingVerificationRequest?
    
    /**
     * Confirm a verification was successful.
     *
     * This method should be called if a short auth string should be confirmed
     * as matching.
     */
    func confirm() throws  -> ConfirmVerificationResult?
    
    /**
     * Get the unique ID that identifies this SAS verification flow.
     */
    func flowId()  -> String
    
    /**
     * Get the decimal representation of the short auth string.
     *
     * *Note*: A SAS verification needs to be started and in the presentable
     * state for this to return the list of decimals, otherwise returns
     * `None`.
     */
    func getDecimals()  -> [Int32]?
    
    /**
     * Get a list of emoji indices of the emoji representation of the short
     * auth string.
     *
     * *Note*: A SAS verification needs to be started and in the presentable
     * state for this to return the list of emoji indices, otherwise returns
     * `None`.
     */
    func getEmojiIndices()  -> [Int32]?
    
    /**
     * Is the SAS flow done.
     */
    func isDone()  -> Bool
    
    /**
     * Get the device ID of the other side.
     */
    func otherDeviceId()  -> String
    
    /**
     * Get the user id of the other side.
     */
    func otherUserId()  -> String
    
    /**
     * Get the room id if the verification is happening inside a room.
     */
    func roomId()  -> String?
    
    /**
     * Set a listener for changes in the SAS verification process.
     *
     * The given callback will be called whenever the state changes.
     *
     * This method can be used to react to changes in the state of the
     * verification process, or rather the method can be used to handle
     * each step of the verification process.
     *
     * This method will spawn a tokio task on the Rust side, once we reach the
     * Done or Cancelled state, the task will stop listening for changes.
     *
     * # Flowchart
     *
     * The flow of the verification process is pictured bellow. Please note
     * that the process can be cancelled at each step of the process.
     * Either side can cancel the process.
     *
     * ```text
     * 
     * Started
     * 
     * 
     * 
     * Accepted
     * 
     * 
     * 
     * Keys Exchanged
     * 
     * 
     * ________________
     *                         
     *    Does the short  ______Cancelled
     *  auth string match  no   
     * _________________
     * yes
     * 
     * 
     * Confirmed
     * 
     * 
     * 
     *   Done 
     * 
     * ```
     */
    func setChangesListener(listener: SasListener) 
    
    /**
     * Get the current state of the SAS verification process.
     */
    func state()  -> SasState
    
    /**
     * Did we initiate the verification flow.
     */
    func weStarted()  -> Bool
    
}

/**
 * The `m.sas.v1` verification flow.
 */
open class Sas:
    SasProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_sas(self.pointer, $0) }
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_sas(pointer, $0) }
    }

    

    
    
    /**
     * Accept that we're going forward with the short auth string verification.
     */
    open func accept()  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_accept(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Cancel the SAS verification using the given cancel code.
     *
     * # Arguments
     *
     * * `cancel_code` - The error code for why the verification was cancelled,
     * manual cancellatio usually happens with `m.user` cancel code. The full
     * list of cancel codes can be found in the [spec]
     *
     * [spec]: https://spec.matrix.org/unstable/client-server-api/#mkeyverificationcancel
     */
    open func cancel(cancelCode: String)  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_cancel(self.uniffiClonePointer(), 
        FfiConverterString.lower(cancelCode),$0
    )
}
        )
    }
    /**
     * Confirm a verification was successful.
     *
     * This method should be called if a short auth string should be confirmed
     * as matching.
     */
    open func confirm() throws  -> ConfirmVerificationResult? {
        return try  FfiConverterOptionTypeConfirmVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_confirm(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the unique ID that identifies this SAS verification flow.
     */
    open func flowId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_flow_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the decimal representation of the short auth string.
     *
     * *Note*: A SAS verification needs to be started and in the presentable
     * state for this to return the list of decimals, otherwise returns
     * `None`.
     */
    open func getDecimals()  -> [Int32]? {
        return try!  FfiConverterOptionSequenceInt32.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_get_decimals(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get a list of emoji indices of the emoji representation of the short
     * auth string.
     *
     * *Note*: A SAS verification needs to be started and in the presentable
     * state for this to return the list of emoji indices, otherwise returns
     * `None`.
     */
    open func getEmojiIndices()  -> [Int32]? {
        return try!  FfiConverterOptionSequenceInt32.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_get_emoji_indices(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Is the SAS flow done.
     */
    open func isDone()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_is_done(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the device ID of the other side.
     */
    open func otherDeviceId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_other_device_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the user id of the other side.
     */
    open func otherUserId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_other_user_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the room id if the verification is happening inside a room.
     */
    open func roomId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_room_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Set a listener for changes in the SAS verification process.
     *
     * The given callback will be called whenever the state changes.
     *
     * This method can be used to react to changes in the state of the
     * verification process, or rather the method can be used to handle
     * each step of the verification process.
     *
     * This method will spawn a tokio task on the Rust side, once we reach the
     * Done or Cancelled state, the task will stop listening for changes.
     *
     * # Flowchart
     *
     * The flow of the verification process is pictured bellow. Please note
     * that the process can be cancelled at each step of the process.
     * Either side can cancel the process.
     *
     * ```text
     * 
     * Started
     * 
     * 
     * 
     * Accepted
     * 
     * 
     * 
     * Keys Exchanged
     * 
     * 
     * ________________
     *                         
     *    Does the short  ______Cancelled
     *  auth string match  no   
     * _________________
     * yes
     * 
     * 
     * Confirmed
     * 
     * 
     * 
     *   Done 
     * 
     * ```
     */
    open func setChangesListener(listener: SasListener)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_set_changes_listener(self.uniffiClonePointer(), 
        FfiConverterCallbackInterfaceSasListener.lower(listener),$0
    )
}
    }
    /**
     * Get the current state of the SAS verification process.
     */
    open func state()  -> SasState {
        return try!  FfiConverterTypeSasState.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_state(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Did we initiate the verification flow.
     */
    open func weStarted()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_we_started(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeSas: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Sas

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Sas {
        return Sas(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Sas) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sas {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Sas, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSas_lift(_ pointer: UnsafeMutableRawPointer) throws -> Sas {
    return try FfiConverterTypeSas.lift(pointer)
}

public func FfiConverterTypeSas_lower(_ value: Sas) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSas.lower(value)
}




/**
 * Enum representing the different verification flows we support.
 */
public protocol VerificationProtocol : AnyObject {
    
    /**
     * Try to represent the `Verification` as an `QrCode` verification object,
     * returns `None` if the verification is not a `QrCode` verification.
     */
    func asQr()  -> QrCode?
    
    /**
     * Try to represent the `Verification` as an `Sas` verification object,
     * returns `None` if the verification is not a `Sas` verification.
     */
    func asSas()  -> Sas?
    
}

/**
 * Enum representing the different verification flows we support.
 */
open class Verification:
    VerificationProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_verification(self.pointer, $0) }
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_verification(pointer, $0) }
    }

    

    
    
    /**
     * Try to represent the `Verification` as an `QrCode` verification object,
     * returns `None` if the verification is not a `QrCode` verification.
     */
    open func asQr()  -> QrCode? {
        return try!  FfiConverterOptionTypeQrCode.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verification_as_qr(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Try to represent the `Verification` as an `Sas` verification object,
     * returns `None` if the verification is not a `Sas` verification.
     */
    open func asSas()  -> Sas? {
        return try!  FfiConverterOptionTypeSas.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verification_as_sas(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeVerification: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Verification

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Verification {
        return Verification(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Verification) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Verification {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Verification, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeVerification_lift(_ pointer: UnsafeMutableRawPointer) throws -> Verification {
    return try FfiConverterTypeVerification.lift(pointer)
}

public func FfiConverterTypeVerification_lower(_ value: Verification) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVerification.lower(value)
}




/**
 * The verificatoin request object which then can transition into some concrete
 * verification method
 */
public protocol VerificationRequestProtocol : AnyObject {
    
    /**
     * Accept a verification requests that we share with the given user with
     * the given flow id.
     *
     * This will move the verification request into the ready state.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to accept the
     * verification requests.
     *
     * * `flow_id` - The ID that uniquely identifies the verification flow.
     *
     * * `methods` - A list of verification methods that we want to advertise
     * as supported.
     */
    func accept(methods: [String])  -> OutgoingVerificationRequest?
    
    /**
     * Cancel a verification for the given user with the given flow id using
     * the given cancel code.
     */
    func cancel()  -> OutgoingVerificationRequest?
    
    /**
     * Get info about the cancellation if the verification request has been
     * cancelled.
     */
    func cancelInfo()  -> CancelInfo?
    
    /**
     * Get the unique ID of this verification request
     */
    func flowId()  -> String
    
    /**
     * Has the verification flow that been cancelled.
     */
    func isCancelled()  -> Bool
    
    /**
     * Has the verification flow that was started with this request finished.
     */
    func isDone()  -> Bool
    
    /**
     * Has the verification request been answered by another device.
     */
    func isPassive()  -> Bool
    
    /**
     * Is the verification request ready to start a verification flow.
     */
    func isReady()  -> Bool
    
    /**
     * The id of the other device that is participating in this verification.
     */
    func otherDeviceId()  -> String?
    
    /**
     * The id of the other user that is participating in this verification
     * request.
     */
    func otherUserId()  -> String
    
    /**
     * Get our own supported verification methods that we advertised.
     *
     * Will be present only we requested the verification or if we're in the
     * ready state.
     */
    func ourSupportedMethods()  -> [String]?
    
    /**
     * Get the room id if the verification is happening inside a room.
     */
    func roomId()  -> String?
    
    /**
     * Pass data from a scanned QR code to an active verification request and
     * transition into QR code verification.
     *
     * This requires an active `VerificationRequest` to succeed, returns `None`
     * if no `VerificationRequest` is found or if the QR code data is invalid.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to start the
     * QR code verification.
     *
     * * `flow_id` - The ID of the verification request that initiated the
     * verification flow.
     *
     * * `data` - The data that was extracted from the scanned QR code as an
     * base64 encoded string, without padding.
     */
    func scanQrCode(data: String)  -> ScanResult?
    
    /**
     * Set a listener for changes in the verification request
     *
     * The given callback will be called whenever the state changes.
     */
    func setChangesListener(listener: VerificationRequestListener) 
    
    /**
     * Transition from a verification request into QR code verification.
     *
     * This method should be called when one wants to display a QR code so the
     * other side can scan it and move the QR code verification forward.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to start the
     * QR code verification.
     *
     * * `flow_id` - The ID of the verification request that initiated the
     * verification flow.
     */
    func startQrVerification() throws  -> QrCode?
    
    /**
     * Transition from a verification request into short auth string based
     * verification.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to start the
     * SAS verification.
     *
     * * `flow_id` - The ID of the verification request that initiated the
     * verification flow.
     */
    func startSasVerification() throws  -> StartSasResult?
    
    /**
     * Get the current state of the verification request.
     */
    func state()  -> VerificationRequestState
    
    /**
     * Get the supported verification methods of the other side.
     *
     * Will be present only if the other side requested the verification or if
     * we're in the ready state.
     */
    func theirSupportedMethods()  -> [String]?
    
    /**
     * Did we initiate the verification request
     */
    func weStarted()  -> Bool
    
}

/**
 * The verificatoin request object which then can transition into some concrete
 * verification method
 */
open class VerificationRequest:
    VerificationRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_clone_verificationrequest(self.pointer, $0) }
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_verificationrequest(pointer, $0) }
    }

    

    
    
    /**
     * Accept a verification requests that we share with the given user with
     * the given flow id.
     *
     * This will move the verification request into the ready state.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to accept the
     * verification requests.
     *
     * * `flow_id` - The ID that uniquely identifies the verification flow.
     *
     * * `methods` - A list of verification methods that we want to advertise
     * as supported.
     */
    open func accept(methods: [String])  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_accept(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }
    /**
     * Cancel a verification for the given user with the given flow id using
     * the given cancel code.
     */
    open func cancel()  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_cancel(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get info about the cancellation if the verification request has been
     * cancelled.
     */
    open func cancelInfo()  -> CancelInfo? {
        return try!  FfiConverterOptionTypeCancelInfo.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_cancel_info(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the unique ID of this verification request
     */
    open func flowId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_flow_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Has the verification flow that been cancelled.
     */
    open func isCancelled()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_is_cancelled(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Has the verification flow that was started with this request finished.
     */
    open func isDone()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_is_done(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Has the verification request been answered by another device.
     */
    open func isPassive()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_is_passive(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Is the verification request ready to start a verification flow.
     */
    open func isReady()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_is_ready(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * The id of the other device that is participating in this verification.
     */
    open func otherDeviceId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_other_device_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * The id of the other user that is participating in this verification
     * request.
     */
    open func otherUserId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_other_user_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get our own supported verification methods that we advertised.
     *
     * Will be present only we requested the verification or if we're in the
     * ready state.
     */
    open func ourSupportedMethods()  -> [String]? {
        return try!  FfiConverterOptionSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_our_supported_methods(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the room id if the verification is happening inside a room.
     */
    open func roomId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_room_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Pass data from a scanned QR code to an active verification request and
     * transition into QR code verification.
     *
     * This requires an active `VerificationRequest` to succeed, returns `None`
     * if no `VerificationRequest` is found or if the QR code data is invalid.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to start the
     * QR code verification.
     *
     * * `flow_id` - The ID of the verification request that initiated the
     * verification flow.
     *
     * * `data` - The data that was extracted from the scanned QR code as an
     * base64 encoded string, without padding.
     */
    open func scanQrCode(data: String)  -> ScanResult? {
        return try!  FfiConverterOptionTypeScanResult.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_scan_qr_code(self.uniffiClonePointer(), 
        FfiConverterString.lower(data),$0
    )
}
        )
    }
    /**
     * Set a listener for changes in the verification request
     *
     * The given callback will be called whenever the state changes.
     */
    open func setChangesListener(listener: VerificationRequestListener)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_set_changes_listener(self.uniffiClonePointer(), 
        FfiConverterCallbackInterfaceVerificationRequestListener.lower(listener),$0
    )
}
    }
    /**
     * Transition from a verification request into QR code verification.
     *
     * This method should be called when one wants to display a QR code so the
     * other side can scan it and move the QR code verification forward.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to start the
     * QR code verification.
     *
     * * `flow_id` - The ID of the verification request that initiated the
     * verification flow.
     */
    open func startQrVerification() throws  -> QrCode? {
        return try  FfiConverterOptionTypeQrCode.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_start_qr_verification(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Transition from a verification request into short auth string based
     * verification.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user for which we would like to start the
     * SAS verification.
     *
     * * `flow_id` - The ID of the verification request that initiated the
     * verification flow.
     */
    open func startSasVerification() throws  -> StartSasResult? {
        return try  FfiConverterOptionTypeStartSasResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_start_sas_verification(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the current state of the verification request.
     */
    open func state()  -> VerificationRequestState {
        return try!  FfiConverterTypeVerificationRequestState.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_state(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the supported verification methods of the other side.
     *
     * Will be present only if the other side requested the verification or if
     * we're in the ready state.
     */
    open func theirSupportedMethods()  -> [String]? {
        return try!  FfiConverterOptionSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_their_supported_methods(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Did we initiate the verification request
     */
    open func weStarted()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_we_started(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeVerificationRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VerificationRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VerificationRequest {
        return VerificationRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VerificationRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VerificationRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeVerificationRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> VerificationRequest {
    return try FfiConverterTypeVerificationRequest.lift(pointer)
}

public func FfiConverterTypeVerificationRequest_lower(_ value: VerificationRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVerificationRequest.lower(value)
}


public struct BootstrapCrossSigningResult {
    /**
     * Optional request to upload some device keys alongside.
     *
     * Must be sent first if present, and marked with `mark_request_as_sent`.
     */
    public var uploadKeysRequest: Request?
    /**
     * Request to upload the signing keys. Must be sent second.
     */
    public var uploadSigningKeysRequest: UploadSigningKeysRequest
    /**
     * Request to upload the keys signatures, including for the signing keys
     * and optionally for the device keys. Must be sent last.
     */
    public var uploadSignatureRequest: SignatureUploadRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional request to upload some device keys alongside.
         *
         * Must be sent first if present, and marked with `mark_request_as_sent`.
         */uploadKeysRequest: Request?, 
        /**
         * Request to upload the signing keys. Must be sent second.
         */uploadSigningKeysRequest: UploadSigningKeysRequest, 
        /**
         * Request to upload the keys signatures, including for the signing keys
         * and optionally for the device keys. Must be sent last.
         */uploadSignatureRequest: SignatureUploadRequest) {
        self.uploadKeysRequest = uploadKeysRequest
        self.uploadSigningKeysRequest = uploadSigningKeysRequest
        self.uploadSignatureRequest = uploadSignatureRequest
    }
}


extension BootstrapCrossSigningResult: Equatable, Hashable {
    public static func ==(lhs: BootstrapCrossSigningResult, rhs: BootstrapCrossSigningResult) -> Bool {
        if lhs.uploadKeysRequest != rhs.uploadKeysRequest {
            return false
        }
        if lhs.uploadSigningKeysRequest != rhs.uploadSigningKeysRequest {
            return false
        }
        if lhs.uploadSignatureRequest != rhs.uploadSignatureRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uploadKeysRequest)
        hasher.combine(uploadSigningKeysRequest)
        hasher.combine(uploadSignatureRequest)
    }
}


public struct FfiConverterTypeBootstrapCrossSigningResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BootstrapCrossSigningResult {
        return
            try BootstrapCrossSigningResult(
                uploadKeysRequest: FfiConverterOptionTypeRequest.read(from: &buf), 
                uploadSigningKeysRequest: FfiConverterTypeUploadSigningKeysRequest.read(from: &buf), 
                uploadSignatureRequest: FfiConverterTypeSignatureUploadRequest.read(from: &buf)
        )
    }

    public static func write(_ value: BootstrapCrossSigningResult, into buf: inout [UInt8]) {
        FfiConverterOptionTypeRequest.write(value.uploadKeysRequest, into: &buf)
        FfiConverterTypeUploadSigningKeysRequest.write(value.uploadSigningKeysRequest, into: &buf)
        FfiConverterTypeSignatureUploadRequest.write(value.uploadSignatureRequest, into: &buf)
    }
}


public func FfiConverterTypeBootstrapCrossSigningResult_lift(_ buf: RustBuffer) throws -> BootstrapCrossSigningResult {
    return try FfiConverterTypeBootstrapCrossSigningResult.lift(buf)
}

public func FfiConverterTypeBootstrapCrossSigningResult_lower(_ value: BootstrapCrossSigningResult) -> RustBuffer {
    return FfiConverterTypeBootstrapCrossSigningResult.lower(value)
}


/**
 * Information on why a verification flow has been cancelled and by whom.
 */
public struct CancelInfo {
    /**
     * The textual representation of the cancel reason
     */
    public var reason: String
    /**
     * The code describing the cancel reason
     */
    public var cancelCode: String
    /**
     * Was the verification flow cancelled by us
     */
    public var cancelledByUs: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The textual representation of the cancel reason
         */reason: String, 
        /**
         * The code describing the cancel reason
         */cancelCode: String, 
        /**
         * Was the verification flow cancelled by us
         */cancelledByUs: Bool) {
        self.reason = reason
        self.cancelCode = cancelCode
        self.cancelledByUs = cancelledByUs
    }
}


extension CancelInfo: Equatable, Hashable {
    public static func ==(lhs: CancelInfo, rhs: CancelInfo) -> Bool {
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.cancelCode != rhs.cancelCode {
            return false
        }
        if lhs.cancelledByUs != rhs.cancelledByUs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reason)
        hasher.combine(cancelCode)
        hasher.combine(cancelledByUs)
    }
}


public struct FfiConverterTypeCancelInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelInfo {
        return
            try CancelInfo(
                reason: FfiConverterString.read(from: &buf), 
                cancelCode: FfiConverterString.read(from: &buf), 
                cancelledByUs: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CancelInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reason, into: &buf)
        FfiConverterString.write(value.cancelCode, into: &buf)
        FfiConverterBool.write(value.cancelledByUs, into: &buf)
    }
}


public func FfiConverterTypeCancelInfo_lift(_ buf: RustBuffer) throws -> CancelInfo {
    return try FfiConverterTypeCancelInfo.lift(buf)
}

public func FfiConverterTypeCancelInfo_lower(_ value: CancelInfo) -> RustBuffer {
    return FfiConverterTypeCancelInfo.lower(value)
}


/**
 * A result type for confirming verifications.
 */
public struct ConfirmVerificationResult {
    /**
     * The requests that needs to be sent out to notify the other side that we
     * confirmed the verification.
     */
    public var requests: [OutgoingVerificationRequest]
    /**
     * A request that will upload signatures of the verified device or user, if
     * the verification is completed and we're able to sign devices or users
     */
    public var signatureRequest: SignatureUploadRequest?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requests that needs to be sent out to notify the other side that we
         * confirmed the verification.
         */requests: [OutgoingVerificationRequest], 
        /**
         * A request that will upload signatures of the verified device or user, if
         * the verification is completed and we're able to sign devices or users
         */signatureRequest: SignatureUploadRequest?) {
        self.requests = requests
        self.signatureRequest = signatureRequest
    }
}


extension ConfirmVerificationResult: Equatable, Hashable {
    public static func ==(lhs: ConfirmVerificationResult, rhs: ConfirmVerificationResult) -> Bool {
        if lhs.requests != rhs.requests {
            return false
        }
        if lhs.signatureRequest != rhs.signatureRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requests)
        hasher.combine(signatureRequest)
    }
}


public struct FfiConverterTypeConfirmVerificationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmVerificationResult {
        return
            try ConfirmVerificationResult(
                requests: FfiConverterSequenceTypeOutgoingVerificationRequest.read(from: &buf), 
                signatureRequest: FfiConverterOptionTypeSignatureUploadRequest.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmVerificationResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeOutgoingVerificationRequest.write(value.requests, into: &buf)
        FfiConverterOptionTypeSignatureUploadRequest.write(value.signatureRequest, into: &buf)
    }
}


public func FfiConverterTypeConfirmVerificationResult_lift(_ buf: RustBuffer) throws -> ConfirmVerificationResult {
    return try FfiConverterTypeConfirmVerificationResult.lift(buf)
}

public func FfiConverterTypeConfirmVerificationResult_lower(_ value: ConfirmVerificationResult) -> RustBuffer {
    return FfiConverterTypeConfirmVerificationResult.lower(value)
}


/**
 * A struct containing private cross signing keys that can be backed up or
 * uploaded to the secret store.
 */
public struct CrossSigningKeyExport {
    /**
     * The seed of the master key encoded as unpadded base64.
     */
    public var masterKey: String?
    /**
     * The seed of the self signing key encoded as unpadded base64.
     */
    public var selfSigningKey: String?
    /**
     * The seed of the user signing key encoded as unpadded base64.
     */
    public var userSigningKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The seed of the master key encoded as unpadded base64.
         */masterKey: String?, 
        /**
         * The seed of the self signing key encoded as unpadded base64.
         */selfSigningKey: String?, 
        /**
         * The seed of the user signing key encoded as unpadded base64.
         */userSigningKey: String?) {
        self.masterKey = masterKey
        self.selfSigningKey = selfSigningKey
        self.userSigningKey = userSigningKey
    }
}


extension CrossSigningKeyExport: Equatable, Hashable {
    public static func ==(lhs: CrossSigningKeyExport, rhs: CrossSigningKeyExport) -> Bool {
        if lhs.masterKey != rhs.masterKey {
            return false
        }
        if lhs.selfSigningKey != rhs.selfSigningKey {
            return false
        }
        if lhs.userSigningKey != rhs.userSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterKey)
        hasher.combine(selfSigningKey)
        hasher.combine(userSigningKey)
    }
}


public struct FfiConverterTypeCrossSigningKeyExport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CrossSigningKeyExport {
        return
            try CrossSigningKeyExport(
                masterKey: FfiConverterOptionString.read(from: &buf), 
                selfSigningKey: FfiConverterOptionString.read(from: &buf), 
                userSigningKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CrossSigningKeyExport, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.masterKey, into: &buf)
        FfiConverterOptionString.write(value.selfSigningKey, into: &buf)
        FfiConverterOptionString.write(value.userSigningKey, into: &buf)
    }
}


public func FfiConverterTypeCrossSigningKeyExport_lift(_ buf: RustBuffer) throws -> CrossSigningKeyExport {
    return try FfiConverterTypeCrossSigningKeyExport.lift(buf)
}

public func FfiConverterTypeCrossSigningKeyExport_lower(_ value: CrossSigningKeyExport) -> RustBuffer {
    return FfiConverterTypeCrossSigningKeyExport.lower(value)
}


/**
 * Struct representing the state of our private cross signing keys, it shows
 * which private cross signing keys we have locally stored.
 */
public struct CrossSigningStatus {
    /**
     * Do we have the master key.
     */
    public var hasMaster: Bool
    /**
     * Do we have the self signing key, this one is necessary to sign our own
     * devices.
     */
    public var hasSelfSigning: Bool
    /**
     * Do we have the user signing key, this one is necessary to sign other
     * users.
     */
    public var hasUserSigning: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Do we have the master key.
         */hasMaster: Bool, 
        /**
         * Do we have the self signing key, this one is necessary to sign our own
         * devices.
         */hasSelfSigning: Bool, 
        /**
         * Do we have the user signing key, this one is necessary to sign other
         * users.
         */hasUserSigning: Bool) {
        self.hasMaster = hasMaster
        self.hasSelfSigning = hasSelfSigning
        self.hasUserSigning = hasUserSigning
    }
}


extension CrossSigningStatus: Equatable, Hashable {
    public static func ==(lhs: CrossSigningStatus, rhs: CrossSigningStatus) -> Bool {
        if lhs.hasMaster != rhs.hasMaster {
            return false
        }
        if lhs.hasSelfSigning != rhs.hasSelfSigning {
            return false
        }
        if lhs.hasUserSigning != rhs.hasUserSigning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hasMaster)
        hasher.combine(hasSelfSigning)
        hasher.combine(hasUserSigning)
    }
}


public struct FfiConverterTypeCrossSigningStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CrossSigningStatus {
        return
            try CrossSigningStatus(
                hasMaster: FfiConverterBool.read(from: &buf), 
                hasSelfSigning: FfiConverterBool.read(from: &buf), 
                hasUserSigning: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CrossSigningStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.hasMaster, into: &buf)
        FfiConverterBool.write(value.hasSelfSigning, into: &buf)
        FfiConverterBool.write(value.hasUserSigning, into: &buf)
    }
}


public func FfiConverterTypeCrossSigningStatus_lift(_ buf: RustBuffer) throws -> CrossSigningStatus {
    return try FfiConverterTypeCrossSigningStatus.lift(buf)
}

public func FfiConverterTypeCrossSigningStatus_lower(_ value: CrossSigningStatus) -> RustBuffer {
    return FfiConverterTypeCrossSigningStatus.lower(value)
}


/**
 * An event that was successfully decrypted.
 */
public struct DecryptedEvent {
    /**
     * The decrypted version of the event.
     */
    public var clearEvent: String
    /**
     * The claimed curve25519 key of the sender.
     */
    public var senderCurve25519Key: String
    /**
     * The claimed ed25519 key of the sender.
     */
    public var claimedEd25519Key: String?
    /**
     * The curve25519 chain of the senders that forwarded the Megolm decryption
     * key to us. Is empty if the key came directly from the sender of the
     * event.
     */
    public var forwardingCurve25519Chain: [String]
    /**
     * The shield state (color and message to display to user) for the event,
     * representing the event's authenticity. Computed from the properties of
     * the sender user identity and their Olm device.
     *
     * Note that this is computed at time of decryption, so the value reflects
     * the computed event authenticity at that time. Authenticity-related
     * properties can change later on, such as when a user identity is
     * subsequently verified or a device is deleted.
     */
    public var shieldState: ShieldState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The decrypted version of the event.
         */clearEvent: String, 
        /**
         * The claimed curve25519 key of the sender.
         */senderCurve25519Key: String, 
        /**
         * The claimed ed25519 key of the sender.
         */claimedEd25519Key: String?, 
        /**
         * The curve25519 chain of the senders that forwarded the Megolm decryption
         * key to us. Is empty if the key came directly from the sender of the
         * event.
         */forwardingCurve25519Chain: [String], 
        /**
         * The shield state (color and message to display to user) for the event,
         * representing the event's authenticity. Computed from the properties of
         * the sender user identity and their Olm device.
         *
         * Note that this is computed at time of decryption, so the value reflects
         * the computed event authenticity at that time. Authenticity-related
         * properties can change later on, such as when a user identity is
         * subsequently verified or a device is deleted.
         */shieldState: ShieldState) {
        self.clearEvent = clearEvent
        self.senderCurve25519Key = senderCurve25519Key
        self.claimedEd25519Key = claimedEd25519Key
        self.forwardingCurve25519Chain = forwardingCurve25519Chain
        self.shieldState = shieldState
    }
}


extension DecryptedEvent: Equatable, Hashable {
    public static func ==(lhs: DecryptedEvent, rhs: DecryptedEvent) -> Bool {
        if lhs.clearEvent != rhs.clearEvent {
            return false
        }
        if lhs.senderCurve25519Key != rhs.senderCurve25519Key {
            return false
        }
        if lhs.claimedEd25519Key != rhs.claimedEd25519Key {
            return false
        }
        if lhs.forwardingCurve25519Chain != rhs.forwardingCurve25519Chain {
            return false
        }
        if lhs.shieldState != rhs.shieldState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clearEvent)
        hasher.combine(senderCurve25519Key)
        hasher.combine(claimedEd25519Key)
        hasher.combine(forwardingCurve25519Chain)
        hasher.combine(shieldState)
    }
}


public struct FfiConverterTypeDecryptedEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptedEvent {
        return
            try DecryptedEvent(
                clearEvent: FfiConverterString.read(from: &buf), 
                senderCurve25519Key: FfiConverterString.read(from: &buf), 
                claimedEd25519Key: FfiConverterOptionString.read(from: &buf), 
                forwardingCurve25519Chain: FfiConverterSequenceString.read(from: &buf), 
                shieldState: FfiConverterTypeShieldState.read(from: &buf)
        )
    }

    public static func write(_ value: DecryptedEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.clearEvent, into: &buf)
        FfiConverterString.write(value.senderCurve25519Key, into: &buf)
        FfiConverterOptionString.write(value.claimedEd25519Key, into: &buf)
        FfiConverterSequenceString.write(value.forwardingCurve25519Chain, into: &buf)
        FfiConverterTypeShieldState.write(value.shieldState, into: &buf)
    }
}


public func FfiConverterTypeDecryptedEvent_lift(_ buf: RustBuffer) throws -> DecryptedEvent {
    return try FfiConverterTypeDecryptedEvent.lift(buf)
}

public func FfiConverterTypeDecryptedEvent_lower(_ value: DecryptedEvent) -> RustBuffer {
    return FfiConverterTypeDecryptedEvent.lower(value)
}


/**
 * An E2EE capable Matrix device.
 */
public struct Device {
    /**
     * The device owner.
     */
    public var userId: String
    /**
     * The unique ID of the device.
     */
    public var deviceId: String
    /**
     * The published public identity keys of the devices
     *
     * A map from the key type (e.g. curve25519) to the base64 encoded key.
     */
    public var keys: [String: String]
    /**
     * The supported algorithms of the device.
     */
    public var algorithms: [String]
    /**
     * The human readable name of the device.
     */
    public var displayName: String?
    /**
     * A flag indicating if the device has been blocked, blocked devices don't
     * receive any room keys from us.
     */
    public var isBlocked: Bool
    /**
     * Is the device locally trusted
     */
    public var locallyTrusted: Bool
    /**
     * Is our cross signing identity trusted and does the identity trust the
     * device.
     */
    public var crossSigningTrusted: Bool
    /**
     * The first time this device was seen in local timestamp, milliseconds
     * since epoch.
     */
    public var firstTimeSeenTs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The device owner.
         */userId: String, 
        /**
         * The unique ID of the device.
         */deviceId: String, 
        /**
         * The published public identity keys of the devices
         *
         * A map from the key type (e.g. curve25519) to the base64 encoded key.
         */keys: [String: String], 
        /**
         * The supported algorithms of the device.
         */algorithms: [String], 
        /**
         * The human readable name of the device.
         */displayName: String?, 
        /**
         * A flag indicating if the device has been blocked, blocked devices don't
         * receive any room keys from us.
         */isBlocked: Bool, 
        /**
         * Is the device locally trusted
         */locallyTrusted: Bool, 
        /**
         * Is our cross signing identity trusted and does the identity trust the
         * device.
         */crossSigningTrusted: Bool, 
        /**
         * The first time this device was seen in local timestamp, milliseconds
         * since epoch.
         */firstTimeSeenTs: UInt64) {
        self.userId = userId
        self.deviceId = deviceId
        self.keys = keys
        self.algorithms = algorithms
        self.displayName = displayName
        self.isBlocked = isBlocked
        self.locallyTrusted = locallyTrusted
        self.crossSigningTrusted = crossSigningTrusted
        self.firstTimeSeenTs = firstTimeSeenTs
    }
}


extension Device: Equatable, Hashable {
    public static func ==(lhs: Device, rhs: Device) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        if lhs.algorithms != rhs.algorithms {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.isBlocked != rhs.isBlocked {
            return false
        }
        if lhs.locallyTrusted != rhs.locallyTrusted {
            return false
        }
        if lhs.crossSigningTrusted != rhs.crossSigningTrusted {
            return false
        }
        if lhs.firstTimeSeenTs != rhs.firstTimeSeenTs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(keys)
        hasher.combine(algorithms)
        hasher.combine(displayName)
        hasher.combine(isBlocked)
        hasher.combine(locallyTrusted)
        hasher.combine(crossSigningTrusted)
        hasher.combine(firstTimeSeenTs)
    }
}


public struct FfiConverterTypeDevice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Device {
        return
            try Device(
                userId: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                keys: FfiConverterDictionaryStringString.read(from: &buf), 
                algorithms: FfiConverterSequenceString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                isBlocked: FfiConverterBool.read(from: &buf), 
                locallyTrusted: FfiConverterBool.read(from: &buf), 
                crossSigningTrusted: FfiConverterBool.read(from: &buf), 
                firstTimeSeenTs: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Device, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterDictionaryStringString.write(value.keys, into: &buf)
        FfiConverterSequenceString.write(value.algorithms, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterBool.write(value.isBlocked, into: &buf)
        FfiConverterBool.write(value.locallyTrusted, into: &buf)
        FfiConverterBool.write(value.crossSigningTrusted, into: &buf)
        FfiConverterUInt64.write(value.firstTimeSeenTs, into: &buf)
    }
}


public func FfiConverterTypeDevice_lift(_ buf: RustBuffer) throws -> Device {
    return try FfiConverterTypeDevice.lift(buf)
}

public func FfiConverterTypeDevice_lower(_ value: Device) -> RustBuffer {
    return FfiConverterTypeDevice.lower(value)
}


public struct DeviceLists {
    public var changed: [String]
    public var left: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(changed: [String], left: [String]) {
        self.changed = changed
        self.left = left
    }
}


extension DeviceLists: Equatable, Hashable {
    public static func ==(lhs: DeviceLists, rhs: DeviceLists) -> Bool {
        if lhs.changed != rhs.changed {
            return false
        }
        if lhs.left != rhs.left {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(changed)
        hasher.combine(left)
    }
}


public struct FfiConverterTypeDeviceLists: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceLists {
        return
            try DeviceLists(
                changed: FfiConverterSequenceString.read(from: &buf), 
                left: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceLists, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.changed, into: &buf)
        FfiConverterSequenceString.write(value.left, into: &buf)
    }
}


public func FfiConverterTypeDeviceLists_lift(_ buf: RustBuffer) throws -> DeviceLists {
    return try FfiConverterTypeDeviceLists.lift(buf)
}

public func FfiConverterTypeDeviceLists_lower(_ value: DeviceLists) -> RustBuffer {
    return FfiConverterTypeDeviceLists.lower(value)
}


/**
 * Settings that should be used when a room key is shared.
 *
 * These settings control which algorithm the room key should use, how long a
 * room key should be used and some other important information that determines
 * the lifetime of a room key.
 */
public struct EncryptionSettings {
    /**
     * The encryption algorithm that should be used in the room.
     */
    public var algorithm: EventEncryptionAlgorithm
    /**
     * How long can the room key be used before it should be rotated. Time in
     * seconds.
     */
    public var rotationPeriod: UInt64
    /**
     * How many messages should be sent before the room key should be rotated.
     */
    public var rotationPeriodMsgs: UInt64
    /**
     * The current history visibility of the room. The visibility will be
     * tracked by the room key and the key will be rotated if the visibility
     * changes.
     */
    public var historyVisibility: HistoryVisibility
    /**
     * Should untrusted devices receive the room key, or should they be
     * excluded from the conversation.
     */
    public var onlyAllowTrustedDevices: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The encryption algorithm that should be used in the room.
         */algorithm: EventEncryptionAlgorithm, 
        /**
         * How long can the room key be used before it should be rotated. Time in
         * seconds.
         */rotationPeriod: UInt64, 
        /**
         * How many messages should be sent before the room key should be rotated.
         */rotationPeriodMsgs: UInt64, 
        /**
         * The current history visibility of the room. The visibility will be
         * tracked by the room key and the key will be rotated if the visibility
         * changes.
         */historyVisibility: HistoryVisibility, 
        /**
         * Should untrusted devices receive the room key, or should they be
         * excluded from the conversation.
         */onlyAllowTrustedDevices: Bool) {
        self.algorithm = algorithm
        self.rotationPeriod = rotationPeriod
        self.rotationPeriodMsgs = rotationPeriodMsgs
        self.historyVisibility = historyVisibility
        self.onlyAllowTrustedDevices = onlyAllowTrustedDevices
    }
}


extension EncryptionSettings: Equatable, Hashable {
    public static func ==(lhs: EncryptionSettings, rhs: EncryptionSettings) -> Bool {
        if lhs.algorithm != rhs.algorithm {
            return false
        }
        if lhs.rotationPeriod != rhs.rotationPeriod {
            return false
        }
        if lhs.rotationPeriodMsgs != rhs.rotationPeriodMsgs {
            return false
        }
        if lhs.historyVisibility != rhs.historyVisibility {
            return false
        }
        if lhs.onlyAllowTrustedDevices != rhs.onlyAllowTrustedDevices {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(algorithm)
        hasher.combine(rotationPeriod)
        hasher.combine(rotationPeriodMsgs)
        hasher.combine(historyVisibility)
        hasher.combine(onlyAllowTrustedDevices)
    }
}


public struct FfiConverterTypeEncryptionSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionSettings {
        return
            try EncryptionSettings(
                algorithm: FfiConverterTypeEventEncryptionAlgorithm.read(from: &buf), 
                rotationPeriod: FfiConverterUInt64.read(from: &buf), 
                rotationPeriodMsgs: FfiConverterUInt64.read(from: &buf), 
                historyVisibility: FfiConverterTypeHistoryVisibility.read(from: &buf), 
                onlyAllowTrustedDevices: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptionSettings, into buf: inout [UInt8]) {
        FfiConverterTypeEventEncryptionAlgorithm.write(value.algorithm, into: &buf)
        FfiConverterUInt64.write(value.rotationPeriod, into: &buf)
        FfiConverterUInt64.write(value.rotationPeriodMsgs, into: &buf)
        FfiConverterTypeHistoryVisibility.write(value.historyVisibility, into: &buf)
        FfiConverterBool.write(value.onlyAllowTrustedDevices, into: &buf)
    }
}


public func FfiConverterTypeEncryptionSettings_lift(_ buf: RustBuffer) throws -> EncryptionSettings {
    return try FfiConverterTypeEncryptionSettings.lift(buf)
}

public func FfiConverterTypeEncryptionSettings_lower(_ value: EncryptionSettings) -> RustBuffer {
    return FfiConverterTypeEncryptionSettings.lower(value)
}


/**
 * A pair of outgoing room key requests, both of those are sendToDevice
 * requests.
 */
public struct KeyRequestPair {
    /**
     * The optional cancellation, this is None if no previous key request was
     * sent out for this key, thus it doesn't need to be cancelled.
     */
    public var cancellation: Request?
    /**
     * The actual key request.
     */
    public var keyRequest: Request

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The optional cancellation, this is None if no previous key request was
         * sent out for this key, thus it doesn't need to be cancelled.
         */cancellation: Request?, 
        /**
         * The actual key request.
         */keyRequest: Request) {
        self.cancellation = cancellation
        self.keyRequest = keyRequest
    }
}


extension KeyRequestPair: Equatable, Hashable {
    public static func ==(lhs: KeyRequestPair, rhs: KeyRequestPair) -> Bool {
        if lhs.cancellation != rhs.cancellation {
            return false
        }
        if lhs.keyRequest != rhs.keyRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cancellation)
        hasher.combine(keyRequest)
    }
}


public struct FfiConverterTypeKeyRequestPair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyRequestPair {
        return
            try KeyRequestPair(
                cancellation: FfiConverterOptionTypeRequest.read(from: &buf), 
                keyRequest: FfiConverterTypeRequest.read(from: &buf)
        )
    }

    public static func write(_ value: KeyRequestPair, into buf: inout [UInt8]) {
        FfiConverterOptionTypeRequest.write(value.cancellation, into: &buf)
        FfiConverterTypeRequest.write(value.keyRequest, into: &buf)
    }
}


public func FfiConverterTypeKeyRequestPair_lift(_ buf: RustBuffer) throws -> KeyRequestPair {
    return try FfiConverterTypeKeyRequestPair.lift(buf)
}

public func FfiConverterTypeKeyRequestPair_lower(_ value: KeyRequestPair) -> RustBuffer {
    return FfiConverterTypeKeyRequestPair.lower(value)
}


public struct KeysImportResult {
    /**
     * The number of room keys that were imported.
     */
    public var imported: Int64
    /**
     * The total number of room keys that were found in the export.
     */
    public var total: Int64
    /**
     * The map of keys that were imported.
     *
     * It's a map from room id to a map of the sender key to a list of session
     * ids.
     */
    public var keys: [String: [String: [String]]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The number of room keys that were imported.
         */imported: Int64, 
        /**
         * The total number of room keys that were found in the export.
         */total: Int64, 
        /**
         * The map of keys that were imported.
         *
         * It's a map from room id to a map of the sender key to a list of session
         * ids.
         */keys: [String: [String: [String]]]) {
        self.imported = imported
        self.total = total
        self.keys = keys
    }
}


extension KeysImportResult: Equatable, Hashable {
    public static func ==(lhs: KeysImportResult, rhs: KeysImportResult) -> Bool {
        if lhs.imported != rhs.imported {
            return false
        }
        if lhs.total != rhs.total {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(imported)
        hasher.combine(total)
        hasher.combine(keys)
    }
}


public struct FfiConverterTypeKeysImportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeysImportResult {
        return
            try KeysImportResult(
                imported: FfiConverterInt64.read(from: &buf), 
                total: FfiConverterInt64.read(from: &buf), 
                keys: FfiConverterDictionaryStringDictionaryStringSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: KeysImportResult, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.imported, into: &buf)
        FfiConverterInt64.write(value.total, into: &buf)
        FfiConverterDictionaryStringDictionaryStringSequenceString.write(value.keys, into: &buf)
    }
}


public func FfiConverterTypeKeysImportResult_lift(_ buf: RustBuffer) throws -> KeysImportResult {
    return try FfiConverterTypeKeysImportResult.lift(buf)
}

public func FfiConverterTypeKeysImportResult_lower(_ value: KeysImportResult) -> RustBuffer {
    return FfiConverterTypeKeysImportResult.lower(value)
}


/**
 * The public part of the backup key.
 */
public struct MegolmV1BackupKey {
    /**
     * The actual base64 encoded public key.
     */
    public var publicKey: String
    /**
     * Signatures that have signed our backup key.
     */
    public var signatures: [String: [String: String]]
    /**
     * The passphrase info, if the key was derived from one.
     */
    public var passphraseInfo: PassphraseInfo?
    /**
     * Get the full name of the backup algorithm this backup key supports.
     */
    public var backupAlgorithm: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The actual base64 encoded public key.
         */publicKey: String, 
        /**
         * Signatures that have signed our backup key.
         */signatures: [String: [String: String]], 
        /**
         * The passphrase info, if the key was derived from one.
         */passphraseInfo: PassphraseInfo?, 
        /**
         * Get the full name of the backup algorithm this backup key supports.
         */backupAlgorithm: String) {
        self.publicKey = publicKey
        self.signatures = signatures
        self.passphraseInfo = passphraseInfo
        self.backupAlgorithm = backupAlgorithm
    }
}


extension MegolmV1BackupKey: Equatable, Hashable {
    public static func ==(lhs: MegolmV1BackupKey, rhs: MegolmV1BackupKey) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.signatures != rhs.signatures {
            return false
        }
        if lhs.passphraseInfo != rhs.passphraseInfo {
            return false
        }
        if lhs.backupAlgorithm != rhs.backupAlgorithm {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(signatures)
        hasher.combine(passphraseInfo)
        hasher.combine(backupAlgorithm)
    }
}


public struct FfiConverterTypeMegolmV1BackupKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MegolmV1BackupKey {
        return
            try MegolmV1BackupKey(
                publicKey: FfiConverterString.read(from: &buf), 
                signatures: FfiConverterDictionaryStringDictionaryStringString.read(from: &buf), 
                passphraseInfo: FfiConverterOptionTypePassphraseInfo.read(from: &buf), 
                backupAlgorithm: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MegolmV1BackupKey, into buf: inout [UInt8]) {
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterDictionaryStringDictionaryStringString.write(value.signatures, into: &buf)
        FfiConverterOptionTypePassphraseInfo.write(value.passphraseInfo, into: &buf)
        FfiConverterString.write(value.backupAlgorithm, into: &buf)
    }
}


public func FfiConverterTypeMegolmV1BackupKey_lift(_ buf: RustBuffer) throws -> MegolmV1BackupKey {
    return try FfiConverterTypeMegolmV1BackupKey.lift(buf)
}

public func FfiConverterTypeMegolmV1BackupKey_lower(_ value: MegolmV1BackupKey) -> RustBuffer {
    return FfiConverterTypeMegolmV1BackupKey.lower(value)
}


/**
 * Struct collecting data that is important to migrate to the rust-sdk
 */
public struct MigrationData {
    /**
     * The pickled version of the Olm Account
     */
    public var account: PickledAccount
    /**
     * The list of pickleds Olm Sessions.
     */
    public var sessions: [PickledSession]
    /**
     * The list of Megolm inbound group sessions.
     */
    public var inboundGroupSessions: [PickledInboundGroupSession]
    /**
     * The Olm pickle key that was used to pickle all the Olm objects.
     */
    public var pickleKey: Data
    /**
     * The backup version that is currently active.
     */
    public var backupVersion: String?
    public var backupRecoveryKey: String?
    /**
     * The private cross signing keys.
     */
    public var crossSigning: CrossSigningKeyExport
    /**
     * The list of users that the Rust SDK should track.
     */
    public var trackedUsers: [String]
    /**
     * Map of room settings
     */
    public var roomSettings: [String: RoomSettings]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The pickled version of the Olm Account
         */account: PickledAccount, 
        /**
         * The list of pickleds Olm Sessions.
         */sessions: [PickledSession], 
        /**
         * The list of Megolm inbound group sessions.
         */inboundGroupSessions: [PickledInboundGroupSession], 
        /**
         * The Olm pickle key that was used to pickle all the Olm objects.
         */pickleKey: Data, 
        /**
         * The backup version that is currently active.
         */backupVersion: String?, backupRecoveryKey: String?, 
        /**
         * The private cross signing keys.
         */crossSigning: CrossSigningKeyExport, 
        /**
         * The list of users that the Rust SDK should track.
         */trackedUsers: [String], 
        /**
         * Map of room settings
         */roomSettings: [String: RoomSettings]) {
        self.account = account
        self.sessions = sessions
        self.inboundGroupSessions = inboundGroupSessions
        self.pickleKey = pickleKey
        self.backupVersion = backupVersion
        self.backupRecoveryKey = backupRecoveryKey
        self.crossSigning = crossSigning
        self.trackedUsers = trackedUsers
        self.roomSettings = roomSettings
    }
}


extension MigrationData: Equatable, Hashable {
    public static func ==(lhs: MigrationData, rhs: MigrationData) -> Bool {
        if lhs.account != rhs.account {
            return false
        }
        if lhs.sessions != rhs.sessions {
            return false
        }
        if lhs.inboundGroupSessions != rhs.inboundGroupSessions {
            return false
        }
        if lhs.pickleKey != rhs.pickleKey {
            return false
        }
        if lhs.backupVersion != rhs.backupVersion {
            return false
        }
        if lhs.backupRecoveryKey != rhs.backupRecoveryKey {
            return false
        }
        if lhs.crossSigning != rhs.crossSigning {
            return false
        }
        if lhs.trackedUsers != rhs.trackedUsers {
            return false
        }
        if lhs.roomSettings != rhs.roomSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(account)
        hasher.combine(sessions)
        hasher.combine(inboundGroupSessions)
        hasher.combine(pickleKey)
        hasher.combine(backupVersion)
        hasher.combine(backupRecoveryKey)
        hasher.combine(crossSigning)
        hasher.combine(trackedUsers)
        hasher.combine(roomSettings)
    }
}


public struct FfiConverterTypeMigrationData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MigrationData {
        return
            try MigrationData(
                account: FfiConverterTypePickledAccount.read(from: &buf), 
                sessions: FfiConverterSequenceTypePickledSession.read(from: &buf), 
                inboundGroupSessions: FfiConverterSequenceTypePickledInboundGroupSession.read(from: &buf), 
                pickleKey: FfiConverterData.read(from: &buf), 
                backupVersion: FfiConverterOptionString.read(from: &buf), 
                backupRecoveryKey: FfiConverterOptionString.read(from: &buf), 
                crossSigning: FfiConverterTypeCrossSigningKeyExport.read(from: &buf), 
                trackedUsers: FfiConverterSequenceString.read(from: &buf), 
                roomSettings: FfiConverterDictionaryStringTypeRoomSettings.read(from: &buf)
        )
    }

    public static func write(_ value: MigrationData, into buf: inout [UInt8]) {
        FfiConverterTypePickledAccount.write(value.account, into: &buf)
        FfiConverterSequenceTypePickledSession.write(value.sessions, into: &buf)
        FfiConverterSequenceTypePickledInboundGroupSession.write(value.inboundGroupSessions, into: &buf)
        FfiConverterData.write(value.pickleKey, into: &buf)
        FfiConverterOptionString.write(value.backupVersion, into: &buf)
        FfiConverterOptionString.write(value.backupRecoveryKey, into: &buf)
        FfiConverterTypeCrossSigningKeyExport.write(value.crossSigning, into: &buf)
        FfiConverterSequenceString.write(value.trackedUsers, into: &buf)
        FfiConverterDictionaryStringTypeRoomSettings.write(value.roomSettings, into: &buf)
    }
}


public func FfiConverterTypeMigrationData_lift(_ buf: RustBuffer) throws -> MigrationData {
    return try FfiConverterTypeMigrationData.lift(buf)
}

public func FfiConverterTypeMigrationData_lower(_ value: MigrationData) -> RustBuffer {
    return FfiConverterTypeMigrationData.lower(value)
}


/**
 * Struct containing info about the way the backup key got derived from a
 * passphrase.
 */
public struct PassphraseInfo {
    /**
     * The salt that was used during key derivation.
     */
    public var privateKeySalt: String
    /**
     * The number of PBKDF rounds that were used for key derivation.
     */
    public var privateKeyIterations: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The salt that was used during key derivation.
         */privateKeySalt: String, 
        /**
         * The number of PBKDF rounds that were used for key derivation.
         */privateKeyIterations: Int32) {
        self.privateKeySalt = privateKeySalt
        self.privateKeyIterations = privateKeyIterations
    }
}


extension PassphraseInfo: Equatable, Hashable {
    public static func ==(lhs: PassphraseInfo, rhs: PassphraseInfo) -> Bool {
        if lhs.privateKeySalt != rhs.privateKeySalt {
            return false
        }
        if lhs.privateKeyIterations != rhs.privateKeyIterations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(privateKeySalt)
        hasher.combine(privateKeyIterations)
    }
}


public struct FfiConverterTypePassphraseInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PassphraseInfo {
        return
            try PassphraseInfo(
                privateKeySalt: FfiConverterString.read(from: &buf), 
                privateKeyIterations: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PassphraseInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.privateKeySalt, into: &buf)
        FfiConverterInt32.write(value.privateKeyIterations, into: &buf)
    }
}


public func FfiConverterTypePassphraseInfo_lift(_ buf: RustBuffer) throws -> PassphraseInfo {
    return try FfiConverterTypePassphraseInfo.lift(buf)
}

public func FfiConverterTypePassphraseInfo_lower(_ value: PassphraseInfo) -> RustBuffer {
    return FfiConverterTypePassphraseInfo.lower(value)
}


/**
 * A pickled version of an `Account`.
 *
 * Holds all the information that needs to be stored in a database to restore
 * an account.
 */
public struct PickledAccount {
    /**
     * The user id of the account owner.
     */
    public var userId: String
    /**
     * The device ID of the account owner.
     */
    public var deviceId: String
    /**
     * The pickled version of the Olm account.
     */
    public var pickle: String
    /**
     * Was the account shared.
     */
    public var shared: Bool
    /**
     * The number of uploaded one-time keys we have on the server.
     */
    public var uploadedSignedKeyCount: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user id of the account owner.
         */userId: String, 
        /**
         * The device ID of the account owner.
         */deviceId: String, 
        /**
         * The pickled version of the Olm account.
         */pickle: String, 
        /**
         * Was the account shared.
         */shared: Bool, 
        /**
         * The number of uploaded one-time keys we have on the server.
         */uploadedSignedKeyCount: Int64) {
        self.userId = userId
        self.deviceId = deviceId
        self.pickle = pickle
        self.shared = shared
        self.uploadedSignedKeyCount = uploadedSignedKeyCount
    }
}


extension PickledAccount: Equatable, Hashable {
    public static func ==(lhs: PickledAccount, rhs: PickledAccount) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.shared != rhs.shared {
            return false
        }
        if lhs.uploadedSignedKeyCount != rhs.uploadedSignedKeyCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(pickle)
        hasher.combine(shared)
        hasher.combine(uploadedSignedKeyCount)
    }
}


public struct FfiConverterTypePickledAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledAccount {
        return
            try PickledAccount(
                userId: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                pickle: FfiConverterString.read(from: &buf), 
                shared: FfiConverterBool.read(from: &buf), 
                uploadedSignedKeyCount: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PickledAccount, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterString.write(value.pickle, into: &buf)
        FfiConverterBool.write(value.shared, into: &buf)
        FfiConverterInt64.write(value.uploadedSignedKeyCount, into: &buf)
    }
}


public func FfiConverterTypePickledAccount_lift(_ buf: RustBuffer) throws -> PickledAccount {
    return try FfiConverterTypePickledAccount.lift(buf)
}

public func FfiConverterTypePickledAccount_lower(_ value: PickledAccount) -> RustBuffer {
    return FfiConverterTypePickledAccount.lower(value)
}


/**
 * A pickled version of an `InboundGroupSession`.
 *
 * Holds all the information that needs to be stored in a database to restore
 * an InboundGroupSession.
 */
public struct PickledInboundGroupSession {
    /**
     * The pickle string holding the InboundGroupSession.
     */
    public var pickle: String
    /**
     * The public curve25519 key of the account that sent us the session
     */
    public var senderKey: String
    /**
     * The public ed25519 key of the account that sent us the session.
     */
    public var signingKey: [String: String]
    /**
     * The id of the room that the session is used in.
     */
    public var roomId: String
    /**
     * The list of claimed ed25519 that forwarded us this key. Will be empty if
     * we directly received this session.
     */
    public var forwardingChains: [String]
    /**
     * Flag remembering if the session was directly sent to us by the sender
     * or if it was imported.
     */
    public var imported: Bool
    /**
     * Flag remembering if the session has been backed up.
     */
    public var backedUp: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The pickle string holding the InboundGroupSession.
         */pickle: String, 
        /**
         * The public curve25519 key of the account that sent us the session
         */senderKey: String, 
        /**
         * The public ed25519 key of the account that sent us the session.
         */signingKey: [String: String], 
        /**
         * The id of the room that the session is used in.
         */roomId: String, 
        /**
         * The list of claimed ed25519 that forwarded us this key. Will be empty if
         * we directly received this session.
         */forwardingChains: [String], 
        /**
         * Flag remembering if the session was directly sent to us by the sender
         * or if it was imported.
         */imported: Bool, 
        /**
         * Flag remembering if the session has been backed up.
         */backedUp: Bool) {
        self.pickle = pickle
        self.senderKey = senderKey
        self.signingKey = signingKey
        self.roomId = roomId
        self.forwardingChains = forwardingChains
        self.imported = imported
        self.backedUp = backedUp
    }
}


extension PickledInboundGroupSession: Equatable, Hashable {
    public static func ==(lhs: PickledInboundGroupSession, rhs: PickledInboundGroupSession) -> Bool {
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.senderKey != rhs.senderKey {
            return false
        }
        if lhs.signingKey != rhs.signingKey {
            return false
        }
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.forwardingChains != rhs.forwardingChains {
            return false
        }
        if lhs.imported != rhs.imported {
            return false
        }
        if lhs.backedUp != rhs.backedUp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pickle)
        hasher.combine(senderKey)
        hasher.combine(signingKey)
        hasher.combine(roomId)
        hasher.combine(forwardingChains)
        hasher.combine(imported)
        hasher.combine(backedUp)
    }
}


public struct FfiConverterTypePickledInboundGroupSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledInboundGroupSession {
        return
            try PickledInboundGroupSession(
                pickle: FfiConverterString.read(from: &buf), 
                senderKey: FfiConverterString.read(from: &buf), 
                signingKey: FfiConverterDictionaryStringString.read(from: &buf), 
                roomId: FfiConverterString.read(from: &buf), 
                forwardingChains: FfiConverterSequenceString.read(from: &buf), 
                imported: FfiConverterBool.read(from: &buf), 
                backedUp: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PickledInboundGroupSession, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pickle, into: &buf)
        FfiConverterString.write(value.senderKey, into: &buf)
        FfiConverterDictionaryStringString.write(value.signingKey, into: &buf)
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterSequenceString.write(value.forwardingChains, into: &buf)
        FfiConverterBool.write(value.imported, into: &buf)
        FfiConverterBool.write(value.backedUp, into: &buf)
    }
}


public func FfiConverterTypePickledInboundGroupSession_lift(_ buf: RustBuffer) throws -> PickledInboundGroupSession {
    return try FfiConverterTypePickledInboundGroupSession.lift(buf)
}

public func FfiConverterTypePickledInboundGroupSession_lower(_ value: PickledInboundGroupSession) -> RustBuffer {
    return FfiConverterTypePickledInboundGroupSession.lower(value)
}


/**
 * A pickled version of a `Session`.
 *
 * Holds all the information that needs to be stored in a database to restore
 * a Session.
 */
public struct PickledSession {
    /**
     * The pickle string holding the Olm Session.
     */
    public var pickle: String
    /**
     * The curve25519 key of the other user that we share this session with.
     */
    public var senderKey: String
    /**
     * Was the session created using a fallback key.
     */
    public var createdUsingFallbackKey: Bool
    /**
     * Unix timestamp (in seconds) when the session was created.
     */
    public var creationTime: UInt64
    /**
     * Unix timestamp (in seconds) when the session was last used.
     */
    public var lastUseTime: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The pickle string holding the Olm Session.
         */pickle: String, 
        /**
         * The curve25519 key of the other user that we share this session with.
         */senderKey: String, 
        /**
         * Was the session created using a fallback key.
         */createdUsingFallbackKey: Bool, 
        /**
         * Unix timestamp (in seconds) when the session was created.
         */creationTime: UInt64, 
        /**
         * Unix timestamp (in seconds) when the session was last used.
         */lastUseTime: UInt64) {
        self.pickle = pickle
        self.senderKey = senderKey
        self.createdUsingFallbackKey = createdUsingFallbackKey
        self.creationTime = creationTime
        self.lastUseTime = lastUseTime
    }
}


extension PickledSession: Equatable, Hashable {
    public static func ==(lhs: PickledSession, rhs: PickledSession) -> Bool {
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.senderKey != rhs.senderKey {
            return false
        }
        if lhs.createdUsingFallbackKey != rhs.createdUsingFallbackKey {
            return false
        }
        if lhs.creationTime != rhs.creationTime {
            return false
        }
        if lhs.lastUseTime != rhs.lastUseTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pickle)
        hasher.combine(senderKey)
        hasher.combine(createdUsingFallbackKey)
        hasher.combine(creationTime)
        hasher.combine(lastUseTime)
    }
}


public struct FfiConverterTypePickledSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledSession {
        return
            try PickledSession(
                pickle: FfiConverterString.read(from: &buf), 
                senderKey: FfiConverterString.read(from: &buf), 
                createdUsingFallbackKey: FfiConverterBool.read(from: &buf), 
                creationTime: FfiConverterUInt64.read(from: &buf), 
                lastUseTime: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PickledSession, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pickle, into: &buf)
        FfiConverterString.write(value.senderKey, into: &buf)
        FfiConverterBool.write(value.createdUsingFallbackKey, into: &buf)
        FfiConverterUInt64.write(value.creationTime, into: &buf)
        FfiConverterUInt64.write(value.lastUseTime, into: &buf)
    }
}


public func FfiConverterTypePickledSession_lift(_ buf: RustBuffer) throws -> PickledSession {
    return try FfiConverterTypePickledSession.lift(buf)
}

public func FfiConverterTypePickledSession_lower(_ value: PickledSession) -> RustBuffer {
    return FfiConverterTypePickledSession.lower(value)
}


/**
 * A result type for requesting verifications.
 */
public struct RequestVerificationResult {
    /**
     * The verification request object that got created.
     */
    public var verification: VerificationRequest
    /**
     * The request that needs to be sent out to notify the other side that
     * we're requesting verification to begin.
     */
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The verification request object that got created.
         */verification: VerificationRequest, 
        /**
         * The request that needs to be sent out to notify the other side that
         * we're requesting verification to begin.
         */request: OutgoingVerificationRequest) {
        self.verification = verification
        self.request = request
    }
}



public struct FfiConverterTypeRequestVerificationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestVerificationResult {
        return
            try RequestVerificationResult(
                verification: FfiConverterTypeVerificationRequest.read(from: &buf), 
                request: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: RequestVerificationResult, into buf: inout [UInt8]) {
        FfiConverterTypeVerificationRequest.write(value.verification, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.request, into: &buf)
    }
}


public func FfiConverterTypeRequestVerificationResult_lift(_ buf: RustBuffer) throws -> RequestVerificationResult {
    return try FfiConverterTypeRequestVerificationResult.lift(buf)
}

public func FfiConverterTypeRequestVerificationResult_lower(_ value: RequestVerificationResult) -> RustBuffer {
    return FfiConverterTypeRequestVerificationResult.lower(value)
}


/**
 * Struct holding the number of room keys we have.
 */
public struct RoomKeyCounts {
    /**
     * The total number of room keys.
     */
    public var total: Int64
    /**
     * The number of backed up room keys.
     */
    public var backedUp: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The total number of room keys.
         */total: Int64, 
        /**
         * The number of backed up room keys.
         */backedUp: Int64) {
        self.total = total
        self.backedUp = backedUp
    }
}


extension RoomKeyCounts: Equatable, Hashable {
    public static func ==(lhs: RoomKeyCounts, rhs: RoomKeyCounts) -> Bool {
        if lhs.total != rhs.total {
            return false
        }
        if lhs.backedUp != rhs.backedUp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(total)
        hasher.combine(backedUp)
    }
}


public struct FfiConverterTypeRoomKeyCounts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomKeyCounts {
        return
            try RoomKeyCounts(
                total: FfiConverterInt64.read(from: &buf), 
                backedUp: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoomKeyCounts, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.total, into: &buf)
        FfiConverterInt64.write(value.backedUp, into: &buf)
    }
}


public func FfiConverterTypeRoomKeyCounts_lift(_ buf: RustBuffer) throws -> RoomKeyCounts {
    return try FfiConverterTypeRoomKeyCounts.lift(buf)
}

public func FfiConverterTypeRoomKeyCounts_lower(_ value: RoomKeyCounts) -> RustBuffer {
    return FfiConverterTypeRoomKeyCounts.lower(value)
}


/**
 * Information on a room key that has been received or imported.
 */
public struct RoomKeyInfo {
    /**
     * The [messaging algorithm] that this key is used for. Will be one of the
     * `m.megolm.*` algorithms.
     *
     * [messaging algorithm]: https://spec.matrix.org/v1.6/client-server-api/#messaging-algorithms
     */
    public var algorithm: String
    /**
     * The room where the key is used.
     */
    public var roomId: String
    /**
     * The Curve25519 key of the device which initiated the session originally.
     */
    public var senderKey: String
    /**
     * The ID of the session that the key is for.
     */
    public var sessionId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The [messaging algorithm] that this key is used for. Will be one of the
         * `m.megolm.*` algorithms.
         *
         * [messaging algorithm]: https://spec.matrix.org/v1.6/client-server-api/#messaging-algorithms
         */algorithm: String, 
        /**
         * The room where the key is used.
         */roomId: String, 
        /**
         * The Curve25519 key of the device which initiated the session originally.
         */senderKey: String, 
        /**
         * The ID of the session that the key is for.
         */sessionId: String) {
        self.algorithm = algorithm
        self.roomId = roomId
        self.senderKey = senderKey
        self.sessionId = sessionId
    }
}


extension RoomKeyInfo: Equatable, Hashable {
    public static func ==(lhs: RoomKeyInfo, rhs: RoomKeyInfo) -> Bool {
        if lhs.algorithm != rhs.algorithm {
            return false
        }
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.senderKey != rhs.senderKey {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(algorithm)
        hasher.combine(roomId)
        hasher.combine(senderKey)
        hasher.combine(sessionId)
    }
}


public struct FfiConverterTypeRoomKeyInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomKeyInfo {
        return
            try RoomKeyInfo(
                algorithm: FfiConverterString.read(from: &buf), 
                roomId: FfiConverterString.read(from: &buf), 
                senderKey: FfiConverterString.read(from: &buf), 
                sessionId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RoomKeyInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.algorithm, into: &buf)
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterString.write(value.senderKey, into: &buf)
        FfiConverterString.write(value.sessionId, into: &buf)
    }
}


public func FfiConverterTypeRoomKeyInfo_lift(_ buf: RustBuffer) throws -> RoomKeyInfo {
    return try FfiConverterTypeRoomKeyInfo.lift(buf)
}

public func FfiConverterTypeRoomKeyInfo_lower(_ value: RoomKeyInfo) -> RustBuffer {
    return FfiConverterTypeRoomKeyInfo.lower(value)
}


/**
 * Room encryption settings which are modified by state events or user options
 */
public struct RoomSettings {
    /**
     * The encryption algorithm that should be used in the room.
     */
    public var algorithm: EventEncryptionAlgorithm
    /**
     * Should untrusted devices receive the room key, or should they be
     * excluded from the conversation.
     */
    public var onlyAllowTrustedDevices: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The encryption algorithm that should be used in the room.
         */algorithm: EventEncryptionAlgorithm, 
        /**
         * Should untrusted devices receive the room key, or should they be
         * excluded from the conversation.
         */onlyAllowTrustedDevices: Bool) {
        self.algorithm = algorithm
        self.onlyAllowTrustedDevices = onlyAllowTrustedDevices
    }
}


extension RoomSettings: Equatable, Hashable {
    public static func ==(lhs: RoomSettings, rhs: RoomSettings) -> Bool {
        if lhs.algorithm != rhs.algorithm {
            return false
        }
        if lhs.onlyAllowTrustedDevices != rhs.onlyAllowTrustedDevices {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(algorithm)
        hasher.combine(onlyAllowTrustedDevices)
    }
}


public struct FfiConverterTypeRoomSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomSettings {
        return
            try RoomSettings(
                algorithm: FfiConverterTypeEventEncryptionAlgorithm.read(from: &buf), 
                onlyAllowTrustedDevices: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RoomSettings, into buf: inout [UInt8]) {
        FfiConverterTypeEventEncryptionAlgorithm.write(value.algorithm, into: &buf)
        FfiConverterBool.write(value.onlyAllowTrustedDevices, into: &buf)
    }
}


public func FfiConverterTypeRoomSettings_lift(_ buf: RustBuffer) throws -> RoomSettings {
    return try FfiConverterTypeRoomSettings.lift(buf)
}

public func FfiConverterTypeRoomSettings_lower(_ value: RoomSettings) -> RustBuffer {
    return FfiConverterTypeRoomSettings.lower(value)
}


/**
 * A result type for scanning QR codes.
 */
public struct ScanResult {
    /**
     * The QR code verification object that got created.
     */
    public var qr: QrCode
    /**
     * The request that needs to be sent out to notify the other side that a
     * QR code verification should start.
     */
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The QR code verification object that got created.
         */qr: QrCode, 
        /**
         * The request that needs to be sent out to notify the other side that a
         * QR code verification should start.
         */request: OutgoingVerificationRequest) {
        self.qr = qr
        self.request = request
    }
}



public struct FfiConverterTypeScanResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanResult {
        return
            try ScanResult(
                qr: FfiConverterTypeQrCode.read(from: &buf), 
                request: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: ScanResult, into buf: inout [UInt8]) {
        FfiConverterTypeQrCode.write(value.qr, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.request, into: &buf)
    }
}


public func FfiConverterTypeScanResult_lift(_ buf: RustBuffer) throws -> ScanResult {
    return try FfiConverterTypeScanResult.lift(buf)
}

public func FfiConverterTypeScanResult_lower(_ value: ScanResult) -> RustBuffer {
    return FfiConverterTypeScanResult.lower(value)
}


/**
 * Struct collecting data that is important to migrate sessions to the rust-sdk
 */
public struct SessionMigrationData {
    /**
     * The user id that the data belongs to.
     */
    public var userId: String
    /**
     * The device id that the data belongs to.
     */
    public var deviceId: String
    /**
     * The Curve25519 public key of the Account that owns this data.
     */
    public var curve25519Key: String
    /**
     * The Ed25519 public key of the Account that owns this data.
     */
    public var ed25519Key: String
    /**
     * The list of pickleds Olm Sessions.
     */
    public var sessions: [PickledSession]
    /**
     * The list of pickled Megolm inbound group sessions.
     */
    public var inboundGroupSessions: [PickledInboundGroupSession]
    /**
     * The Olm pickle key that was used to pickle all the Olm objects.
     */
    public var pickleKey: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user id that the data belongs to.
         */userId: String, 
        /**
         * The device id that the data belongs to.
         */deviceId: String, 
        /**
         * The Curve25519 public key of the Account that owns this data.
         */curve25519Key: String, 
        /**
         * The Ed25519 public key of the Account that owns this data.
         */ed25519Key: String, 
        /**
         * The list of pickleds Olm Sessions.
         */sessions: [PickledSession], 
        /**
         * The list of pickled Megolm inbound group sessions.
         */inboundGroupSessions: [PickledInboundGroupSession], 
        /**
         * The Olm pickle key that was used to pickle all the Olm objects.
         */pickleKey: Data) {
        self.userId = userId
        self.deviceId = deviceId
        self.curve25519Key = curve25519Key
        self.ed25519Key = ed25519Key
        self.sessions = sessions
        self.inboundGroupSessions = inboundGroupSessions
        self.pickleKey = pickleKey
    }
}


extension SessionMigrationData: Equatable, Hashable {
    public static func ==(lhs: SessionMigrationData, rhs: SessionMigrationData) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.curve25519Key != rhs.curve25519Key {
            return false
        }
        if lhs.ed25519Key != rhs.ed25519Key {
            return false
        }
        if lhs.sessions != rhs.sessions {
            return false
        }
        if lhs.inboundGroupSessions != rhs.inboundGroupSessions {
            return false
        }
        if lhs.pickleKey != rhs.pickleKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(curve25519Key)
        hasher.combine(ed25519Key)
        hasher.combine(sessions)
        hasher.combine(inboundGroupSessions)
        hasher.combine(pickleKey)
    }
}


public struct FfiConverterTypeSessionMigrationData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionMigrationData {
        return
            try SessionMigrationData(
                userId: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                curve25519Key: FfiConverterString.read(from: &buf), 
                ed25519Key: FfiConverterString.read(from: &buf), 
                sessions: FfiConverterSequenceTypePickledSession.read(from: &buf), 
                inboundGroupSessions: FfiConverterSequenceTypePickledInboundGroupSession.read(from: &buf), 
                pickleKey: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SessionMigrationData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterString.write(value.curve25519Key, into: &buf)
        FfiConverterString.write(value.ed25519Key, into: &buf)
        FfiConverterSequenceTypePickledSession.write(value.sessions, into: &buf)
        FfiConverterSequenceTypePickledInboundGroupSession.write(value.inboundGroupSessions, into: &buf)
        FfiConverterData.write(value.pickleKey, into: &buf)
    }
}


public func FfiConverterTypeSessionMigrationData_lift(_ buf: RustBuffer) throws -> SessionMigrationData {
    return try FfiConverterTypeSessionMigrationData.lift(buf)
}

public func FfiConverterTypeSessionMigrationData_lower(_ value: SessionMigrationData) -> RustBuffer {
    return FfiConverterTypeSessionMigrationData.lower(value)
}


/**
 * Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]
 * for more info.
 */
public struct ShieldState {
    public var color: ShieldColor
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(color: ShieldColor, message: String?) {
        self.color = color
        self.message = message
    }
}


extension ShieldState: Equatable, Hashable {
    public static func ==(lhs: ShieldState, rhs: ShieldState) -> Bool {
        if lhs.color != rhs.color {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(color)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeShieldState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldState {
        return
            try ShieldState(
                color: FfiConverterTypeShieldColor.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ShieldState, into buf: inout [UInt8]) {
        FfiConverterTypeShieldColor.write(value.color, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeShieldState_lift(_ buf: RustBuffer) throws -> ShieldState {
    return try FfiConverterTypeShieldState.lift(buf)
}

public func FfiConverterTypeShieldState_lower(_ value: ShieldState) -> RustBuffer {
    return FfiConverterTypeShieldState.lower(value)
}


public struct SignatureUploadRequest {
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String) {
        self.body = body
    }
}


extension SignatureUploadRequest: Equatable, Hashable {
    public static func ==(lhs: SignatureUploadRequest, rhs: SignatureUploadRequest) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
    }
}


public struct FfiConverterTypeSignatureUploadRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureUploadRequest {
        return
            try SignatureUploadRequest(
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureUploadRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeSignatureUploadRequest_lift(_ buf: RustBuffer) throws -> SignatureUploadRequest {
    return try FfiConverterTypeSignatureUploadRequest.lift(buf)
}

public func FfiConverterTypeSignatureUploadRequest_lower(_ value: SignatureUploadRequest) -> RustBuffer {
    return FfiConverterTypeSignatureUploadRequest.lower(value)
}


/**
 * The result of a signature verification of a signed JSON object.
 */
public struct SignatureVerification {
    /**
     * The result of the signature verification using the public key of our own
     * device.
     */
    public var deviceSignature: SignatureState
    /**
     * The result of the signature verification using the public key of our own
     * user identity.
     */
    public var userIdentitySignature: SignatureState
    /**
     * The result of the signature verification using public keys of other
     * devices we own.
     */
    public var otherDevicesSignatures: [String: SignatureState]
    /**
     * Is the signed JSON object trusted.
     *
     * This flag tells us if the result has a valid signature from any of the
     * following:
     *
     * * Our own device
     * * Our own user identity, provided the identity is trusted as well
     * * Any of our own devices, provided the device is trusted as well
     */
    public var trusted: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The result of the signature verification using the public key of our own
         * device.
         */deviceSignature: SignatureState, 
        /**
         * The result of the signature verification using the public key of our own
         * user identity.
         */userIdentitySignature: SignatureState, 
        /**
         * The result of the signature verification using public keys of other
         * devices we own.
         */otherDevicesSignatures: [String: SignatureState], 
        /**
         * Is the signed JSON object trusted.
         *
         * This flag tells us if the result has a valid signature from any of the
         * following:
         *
         * * Our own device
         * * Our own user identity, provided the identity is trusted as well
         * * Any of our own devices, provided the device is trusted as well
         */trusted: Bool) {
        self.deviceSignature = deviceSignature
        self.userIdentitySignature = userIdentitySignature
        self.otherDevicesSignatures = otherDevicesSignatures
        self.trusted = trusted
    }
}


extension SignatureVerification: Equatable, Hashable {
    public static func ==(lhs: SignatureVerification, rhs: SignatureVerification) -> Bool {
        if lhs.deviceSignature != rhs.deviceSignature {
            return false
        }
        if lhs.userIdentitySignature != rhs.userIdentitySignature {
            return false
        }
        if lhs.otherDevicesSignatures != rhs.otherDevicesSignatures {
            return false
        }
        if lhs.trusted != rhs.trusted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deviceSignature)
        hasher.combine(userIdentitySignature)
        hasher.combine(otherDevicesSignatures)
        hasher.combine(trusted)
    }
}


public struct FfiConverterTypeSignatureVerification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureVerification {
        return
            try SignatureVerification(
                deviceSignature: FfiConverterTypeSignatureState.read(from: &buf), 
                userIdentitySignature: FfiConverterTypeSignatureState.read(from: &buf), 
                otherDevicesSignatures: FfiConverterDictionaryStringTypeSignatureState.read(from: &buf), 
                trusted: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureVerification, into buf: inout [UInt8]) {
        FfiConverterTypeSignatureState.write(value.deviceSignature, into: &buf)
        FfiConverterTypeSignatureState.write(value.userIdentitySignature, into: &buf)
        FfiConverterDictionaryStringTypeSignatureState.write(value.otherDevicesSignatures, into: &buf)
        FfiConverterBool.write(value.trusted, into: &buf)
    }
}


public func FfiConverterTypeSignatureVerification_lift(_ buf: RustBuffer) throws -> SignatureVerification {
    return try FfiConverterTypeSignatureVerification.lift(buf)
}

public func FfiConverterTypeSignatureVerification_lower(_ value: SignatureVerification) -> RustBuffer {
    return FfiConverterTypeSignatureVerification.lower(value)
}


/**
 * A result type for starting SAS verifications.
 */
public struct StartSasResult {
    /**
     * The SAS verification object that got created.
     */
    public var sas: Sas
    /**
     * The request that needs to be sent out to notify the other side that a
     * SAS verification should start.
     */
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The SAS verification object that got created.
         */sas: Sas, 
        /**
         * The request that needs to be sent out to notify the other side that a
         * SAS verification should start.
         */request: OutgoingVerificationRequest) {
        self.sas = sas
        self.request = request
    }
}



public struct FfiConverterTypeStartSasResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StartSasResult {
        return
            try StartSasResult(
                sas: FfiConverterTypeSas.read(from: &buf), 
                request: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: StartSasResult, into buf: inout [UInt8]) {
        FfiConverterTypeSas.write(value.sas, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.request, into: &buf)
    }
}


public func FfiConverterTypeStartSasResult_lift(_ buf: RustBuffer) throws -> StartSasResult {
    return try FfiConverterTypeStartSasResult.lift(buf)
}

public func FfiConverterTypeStartSasResult_lower(_ value: StartSasResult) -> RustBuffer {
    return FfiConverterTypeStartSasResult.lower(value)
}


/**
 * The return value for the [`OlmMachine::receive_sync_changes()`] method.
 *
 * Will contain various information about the `/sync` changes the
 * [`OlmMachine`] processed.
 */
public struct SyncChangesResult {
    /**
     * The, now possibly decrypted, to-device events the [`OlmMachine`]
     * received, decrypted, and processed.
     */
    public var toDeviceEvents: [String]
    /**
     * Information about the room keys that were extracted out of the to-device
     * events.
     */
    public var roomKeyInfos: [RoomKeyInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The, now possibly decrypted, to-device events the [`OlmMachine`]
         * received, decrypted, and processed.
         */toDeviceEvents: [String], 
        /**
         * Information about the room keys that were extracted out of the to-device
         * events.
         */roomKeyInfos: [RoomKeyInfo]) {
        self.toDeviceEvents = toDeviceEvents
        self.roomKeyInfos = roomKeyInfos
    }
}


extension SyncChangesResult: Equatable, Hashable {
    public static func ==(lhs: SyncChangesResult, rhs: SyncChangesResult) -> Bool {
        if lhs.toDeviceEvents != rhs.toDeviceEvents {
            return false
        }
        if lhs.roomKeyInfos != rhs.roomKeyInfos {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(toDeviceEvents)
        hasher.combine(roomKeyInfos)
    }
}


public struct FfiConverterTypeSyncChangesResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncChangesResult {
        return
            try SyncChangesResult(
                toDeviceEvents: FfiConverterSequenceString.read(from: &buf), 
                roomKeyInfos: FfiConverterSequenceTypeRoomKeyInfo.read(from: &buf)
        )
    }

    public static func write(_ value: SyncChangesResult, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.toDeviceEvents, into: &buf)
        FfiConverterSequenceTypeRoomKeyInfo.write(value.roomKeyInfos, into: &buf)
    }
}


public func FfiConverterTypeSyncChangesResult_lift(_ buf: RustBuffer) throws -> SyncChangesResult {
    return try FfiConverterTypeSyncChangesResult.lift(buf)
}

public func FfiConverterTypeSyncChangesResult_lower(_ value: SyncChangesResult) -> RustBuffer {
    return FfiConverterTypeSyncChangesResult.lower(value)
}


public struct UploadDehydratedDeviceRequest {
    /**
     * The serialized JSON body of the request.
     */
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The serialized JSON body of the request.
         */body: String) {
        self.body = body
    }
}


extension UploadDehydratedDeviceRequest: Equatable, Hashable {
    public static func ==(lhs: UploadDehydratedDeviceRequest, rhs: UploadDehydratedDeviceRequest) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
    }
}


public struct FfiConverterTypeUploadDehydratedDeviceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadDehydratedDeviceRequest {
        return
            try UploadDehydratedDeviceRequest(
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UploadDehydratedDeviceRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeUploadDehydratedDeviceRequest_lift(_ buf: RustBuffer) throws -> UploadDehydratedDeviceRequest {
    return try FfiConverterTypeUploadDehydratedDeviceRequest.lift(buf)
}

public func FfiConverterTypeUploadDehydratedDeviceRequest_lower(_ value: UploadDehydratedDeviceRequest) -> RustBuffer {
    return FfiConverterTypeUploadDehydratedDeviceRequest.lower(value)
}


public struct UploadSigningKeysRequest {
    public var masterKey: String
    public var selfSigningKey: String
    public var userSigningKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(masterKey: String, selfSigningKey: String, userSigningKey: String) {
        self.masterKey = masterKey
        self.selfSigningKey = selfSigningKey
        self.userSigningKey = userSigningKey
    }
}


extension UploadSigningKeysRequest: Equatable, Hashable {
    public static func ==(lhs: UploadSigningKeysRequest, rhs: UploadSigningKeysRequest) -> Bool {
        if lhs.masterKey != rhs.masterKey {
            return false
        }
        if lhs.selfSigningKey != rhs.selfSigningKey {
            return false
        }
        if lhs.userSigningKey != rhs.userSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterKey)
        hasher.combine(selfSigningKey)
        hasher.combine(userSigningKey)
    }
}


public struct FfiConverterTypeUploadSigningKeysRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadSigningKeysRequest {
        return
            try UploadSigningKeysRequest(
                masterKey: FfiConverterString.read(from: &buf), 
                selfSigningKey: FfiConverterString.read(from: &buf), 
                userSigningKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UploadSigningKeysRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.masterKey, into: &buf)
        FfiConverterString.write(value.selfSigningKey, into: &buf)
        FfiConverterString.write(value.userSigningKey, into: &buf)
    }
}


public func FfiConverterTypeUploadSigningKeysRequest_lift(_ buf: RustBuffer) throws -> UploadSigningKeysRequest {
    return try FfiConverterTypeUploadSigningKeysRequest.lift(buf)
}

public func FfiConverterTypeUploadSigningKeysRequest_lower(_ value: UploadSigningKeysRequest) -> RustBuffer {
    return FfiConverterTypeUploadSigningKeysRequest.lower(value)
}


/**
 * Build-time information about important crates that are used.
 */
public struct VersionInfo {
    /**
     * The version of the matrix-sdk-crypto crate.
     */
    public var version: String
    /**
     * The version of the vodozemac crate.
     */
    public var vodozemacVersion: String
    /**
     * The Git commit hash of the crate's source tree at build time.
     */
    public var gitSha: String
    /**
     * The build-time output of the `git describe` command of the source tree
     * of crate.
     */
    public var gitDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The version of the matrix-sdk-crypto crate.
         */version: String, 
        /**
         * The version of the vodozemac crate.
         */vodozemacVersion: String, 
        /**
         * The Git commit hash of the crate's source tree at build time.
         */gitSha: String, 
        /**
         * The build-time output of the `git describe` command of the source tree
         * of crate.
         */gitDescription: String) {
        self.version = version
        self.vodozemacVersion = vodozemacVersion
        self.gitSha = gitSha
        self.gitDescription = gitDescription
    }
}


extension VersionInfo: Equatable, Hashable {
    public static func ==(lhs: VersionInfo, rhs: VersionInfo) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.vodozemacVersion != rhs.vodozemacVersion {
            return false
        }
        if lhs.gitSha != rhs.gitSha {
            return false
        }
        if lhs.gitDescription != rhs.gitDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(vodozemacVersion)
        hasher.combine(gitSha)
        hasher.combine(gitDescription)
    }
}


public struct FfiConverterTypeVersionInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VersionInfo {
        return
            try VersionInfo(
                version: FfiConverterString.read(from: &buf), 
                vodozemacVersion: FfiConverterString.read(from: &buf), 
                gitSha: FfiConverterString.read(from: &buf), 
                gitDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: VersionInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterString.write(value.vodozemacVersion, into: &buf)
        FfiConverterString.write(value.gitSha, into: &buf)
        FfiConverterString.write(value.gitDescription, into: &buf)
    }
}


public func FfiConverterTypeVersionInfo_lift(_ buf: RustBuffer) throws -> VersionInfo {
    return try FfiConverterTypeVersionInfo.lift(buf)
}

public func FfiConverterTypeVersionInfo_lower(_ value: VersionInfo) -> RustBuffer {
    return FfiConverterTypeVersionInfo.lower(value)
}


public enum CryptoStoreError {

    
    
    case OpenStore(message: String)
    
    case CryptoStore(message: String)
    
    case OlmError(message: String)
    
    case Serialization(message: String)
    
    case InvalidUserId(message: String)
    
    case Identifier(message: String)
    
}


public struct FfiConverterTypeCryptoStoreError: FfiConverterRustBuffer {
    typealias SwiftType = CryptoStoreError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CryptoStoreError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .OpenStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .OlmError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Serialization(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidUserId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .Identifier(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CryptoStoreError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .OpenStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .OlmError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Serialization(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidUserId(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .Identifier(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))

        
        }
    }
}


extension CryptoStoreError: Equatable, Hashable {}

extension CryptoStoreError: Error { }


/**
 * Error type for the decoding and storing of the backup key.
 */
public enum DecodeError {

    
    
    /**
     * An error happened while decoding the recovery key.
     */
    case Decode(message: String)
    
    /**
     * An error happened in the storage layer while trying to save the
     * decoded recovery key.
     */
    case CryptoStore(message: String)
    
}


public struct FfiConverterTypeDecodeError: FfiConverterRustBuffer {
    typealias SwiftType = DecodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Decode(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodeError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Decode(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


extension DecodeError: Equatable, Hashable {}

extension DecodeError: Error { }


public enum DecryptionError {

    
    
    case Serialization(error: String
    )
    case Identifier(error: String
    )
    case Megolm(error: String
    )
    case MissingRoomKey(error: String, withheldCode: String?
    )
    case Store(error: String
    )
}


public struct FfiConverterTypeDecryptionError: FfiConverterRustBuffer {
    typealias SwiftType = DecryptionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Serialization(
            error: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Identifier(
            error: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Megolm(
            error: try FfiConverterString.read(from: &buf)
            )
        case 4: return .MissingRoomKey(
            error: try FfiConverterString.read(from: &buf), 
            withheldCode: try FfiConverterOptionString.read(from: &buf)
            )
        case 5: return .Store(
            error: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecryptionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Serialization(error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .Identifier(error):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .Megolm(error):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .MissingRoomKey(error,withheldCode):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(error, into: &buf)
            FfiConverterOptionString.write(withheldCode, into: &buf)
            
        
        case let .Store(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


extension DecryptionError: Equatable, Hashable {}

extension DecryptionError: Error { }


public enum DehydrationError {

    
    
    case Pickle(message: String)
    
    case MissingSigningKey(message: String)
    
    case Json(message: String)
    
    case Store(message: String)
    
    case PickleKeyLength(message: String)
    
}


public struct FfiConverterTypeDehydrationError: FfiConverterRustBuffer {
    typealias SwiftType = DehydrationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DehydrationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Pickle(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .MissingSigningKey(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Json(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Store(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .PickleKeyLength(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DehydrationError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Pickle(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .MissingSigningKey(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Json(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Store(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .PickleKeyLength(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


extension DehydrationError: Equatable, Hashable {}

extension DehydrationError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An encryption algorithm to be used to encrypt messages sent to a room.
 */

public enum EventEncryptionAlgorithm {
    
    /**
     * Olm version 1 using Curve25519, AES-256, and SHA-256.
     */
    case olmV1Curve25519AesSha2
    /**
     * Megolm version 1 using AES-256 and SHA-256.
     */
    case megolmV1AesSha2
}


public struct FfiConverterTypeEventEncryptionAlgorithm: FfiConverterRustBuffer {
    typealias SwiftType = EventEncryptionAlgorithm

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventEncryptionAlgorithm {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .olmV1Curve25519AesSha2
        
        case 2: return .megolmV1AesSha2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventEncryptionAlgorithm, into buf: inout [UInt8]) {
        switch value {
        
        
        case .olmV1Curve25519AesSha2:
            writeInt(&buf, Int32(1))
        
        
        case .megolmV1AesSha2:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeEventEncryptionAlgorithm_lift(_ buf: RustBuffer) throws -> EventEncryptionAlgorithm {
    return try FfiConverterTypeEventEncryptionAlgorithm.lift(buf)
}

public func FfiConverterTypeEventEncryptionAlgorithm_lower(_ value: EventEncryptionAlgorithm) -> RustBuffer {
    return FfiConverterTypeEventEncryptionAlgorithm.lower(value)
}


extension EventEncryptionAlgorithm: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Who can see a room's history.
 */

public enum HistoryVisibility {
    
    /**
     * Previous events are accessible to newly joined members from the point
     * they were invited onwards.
     *
     * Events stop being accessible when the member's state changes to
     * something other than *invite* or *join*.
     */
    case invited
    /**
     * Previous events are accessible to newly joined members from the point
     * they joined the room onwards.
     * Events stop being accessible when the member's state changes to
     * something other than *join*.
     */
    case joined
    /**
     * Previous events are always accessible to newly joined members.
     *
     * All events in the room are accessible, even those sent when the member
     * was not a part of the room.
     */
    case shared
    /**
     * All events while this is the `HistoryVisibility` value may be shared by
     * any participating homeserver with anyone, regardless of whether they
     * have ever joined the room.
     */
    case worldReadable
}


public struct FfiConverterTypeHistoryVisibility: FfiConverterRustBuffer {
    typealias SwiftType = HistoryVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoryVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invited
        
        case 2: return .joined
        
        case 3: return .shared
        
        case 4: return .worldReadable
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HistoryVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invited:
            writeInt(&buf, Int32(1))
        
        
        case .joined:
            writeInt(&buf, Int32(2))
        
        
        case .shared:
            writeInt(&buf, Int32(3))
        
        
        case .worldReadable:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeHistoryVisibility_lift(_ buf: RustBuffer) throws -> HistoryVisibility {
    return try FfiConverterTypeHistoryVisibility.lift(buf)
}

public func FfiConverterTypeHistoryVisibility_lower(_ value: HistoryVisibility) -> RustBuffer {
    return FfiConverterTypeHistoryVisibility.lower(value)
}


extension HistoryVisibility: Equatable, Hashable {}




public enum KeyImportError {

    
    
    case Export(message: String)
    
    case CryptoStore(message: String)
    
    case Json(message: String)
    
}


public struct FfiConverterTypeKeyImportError: FfiConverterRustBuffer {
    typealias SwiftType = KeyImportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyImportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Export(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Json(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyImportError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Export(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Json(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


extension KeyImportError: Equatable, Hashable {}

extension KeyImportError: Error { }


/**
 * Error type for the migration process.
 */
public enum MigrationError {

    
    
    /**
     * Generic catch all error variant.
     */
    case Generic(
        /**
         * The error message
         */errorMessage: String
    )
}


public struct FfiConverterTypeMigrationError: FfiConverterRustBuffer {
    typealias SwiftType = MigrationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MigrationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MigrationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


extension MigrationError: Equatable, Hashable {}

extension MigrationError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OutgoingVerificationRequest {
    
    case toDevice(requestId: String, eventType: String, body: String
    )
    case inRoom(requestId: String, roomId: String, eventType: String, content: String
    )
}


public struct FfiConverterTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingVerificationRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutgoingVerificationRequest {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toDevice(requestId: try FfiConverterString.read(from: &buf), eventType: try FfiConverterString.read(from: &buf), body: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .inRoom(requestId: try FfiConverterString.read(from: &buf), roomId: try FfiConverterString.read(from: &buf), eventType: try FfiConverterString.read(from: &buf), content: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OutgoingVerificationRequest, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .toDevice(requestId,eventType,body):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .inRoom(requestId,roomId,eventType,content):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(roomId, into: &buf)
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(content, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOutgoingVerificationRequest_lift(_ buf: RustBuffer) throws -> OutgoingVerificationRequest {
    return try FfiConverterTypeOutgoingVerificationRequest.lift(buf)
}

public func FfiConverterTypeOutgoingVerificationRequest_lower(_ value: OutgoingVerificationRequest) -> RustBuffer {
    return FfiConverterTypeOutgoingVerificationRequest.lower(value)
}


extension OutgoingVerificationRequest: Equatable, Hashable {}




/**
 * Error type for the decryption of backed up room keys.
 */
public enum PkDecryptionError {

    
    
    /**
     * An internal libolm error happened during decryption.
     */
    case Olm(message: String)
    
}


public struct FfiConverterTypePkDecryptionError: FfiConverterRustBuffer {
    typealias SwiftType = PkDecryptionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PkDecryptionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Olm(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PkDecryptionError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Olm(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension PkDecryptionError: Equatable, Hashable {}

extension PkDecryptionError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An Enum describing the state the QrCode verification is in.
 */

public enum QrCodeState {
    
    /**
     * The QR verification has been started.
     */
    case started
    /**
     * The QR verification has been scanned by the other side.
     */
    case scanned
    /**
     * The scanning of the QR code has been confirmed by us.
     */
    case confirmed
    /**
     * We have successfully scanned the QR code and are able to send a
     * reciprocation event.
     */
    case reciprocated
    /**
     * The verification process has been successfully concluded.
     */
    case done
    /**
     * The verification process has been cancelled.
     */
    case cancelled(
        /**
         * Information about the reason of the cancellation.
         */cancelInfo: CancelInfo
    )
}


public struct FfiConverterTypeQrCodeState: FfiConverterRustBuffer {
    typealias SwiftType = QrCodeState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCodeState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .started
        
        case 2: return .scanned
        
        case 3: return .confirmed
        
        case 4: return .reciprocated
        
        case 5: return .done
        
        case 6: return .cancelled(cancelInfo: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrCodeState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .started:
            writeInt(&buf, Int32(1))
        
        
        case .scanned:
            writeInt(&buf, Int32(2))
        
        
        case .confirmed:
            writeInt(&buf, Int32(3))
        
        
        case .reciprocated:
            writeInt(&buf, Int32(4))
        
        
        case .done:
            writeInt(&buf, Int32(5))
        
        
        case let .cancelled(cancelInfo):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCancelInfo.write(cancelInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeQrCodeState_lift(_ buf: RustBuffer) throws -> QrCodeState {
    return try FfiConverterTypeQrCodeState.lift(buf)
}

public func FfiConverterTypeQrCodeState_lower(_ value: QrCodeState) -> RustBuffer {
    return FfiConverterTypeQrCodeState.lower(value)
}


extension QrCodeState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Request {
    
    case toDevice(requestId: String, eventType: String, body: String
    )
    case keysUpload(requestId: String, body: String
    )
    case keysQuery(requestId: String, users: [String]
    )
    case keysClaim(requestId: String, oneTimeKeys: [String: [String: String]]
    )
    case keysBackup(requestId: String, version: String, rooms: String
    )
    case roomMessage(requestId: String, roomId: String, eventType: String, content: String
    )
    case signatureUpload(requestId: String, body: String
    )
}


public struct FfiConverterTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = Request

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Request {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toDevice(requestId: try FfiConverterString.read(from: &buf), eventType: try FfiConverterString.read(from: &buf), body: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .keysUpload(requestId: try FfiConverterString.read(from: &buf), body: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .keysQuery(requestId: try FfiConverterString.read(from: &buf), users: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 4: return .keysClaim(requestId: try FfiConverterString.read(from: &buf), oneTimeKeys: try FfiConverterDictionaryStringDictionaryStringString.read(from: &buf)
        )
        
        case 5: return .keysBackup(requestId: try FfiConverterString.read(from: &buf), version: try FfiConverterString.read(from: &buf), rooms: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .roomMessage(requestId: try FfiConverterString.read(from: &buf), roomId: try FfiConverterString.read(from: &buf), eventType: try FfiConverterString.read(from: &buf), content: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .signatureUpload(requestId: try FfiConverterString.read(from: &buf), body: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Request, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .toDevice(requestId,eventType,body):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .keysUpload(requestId,body):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .keysQuery(requestId,users):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterSequenceString.write(users, into: &buf)
            
        
        case let .keysClaim(requestId,oneTimeKeys):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterDictionaryStringDictionaryStringString.write(oneTimeKeys, into: &buf)
            
        
        case let .keysBackup(requestId,version,rooms):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(version, into: &buf)
            FfiConverterString.write(rooms, into: &buf)
            
        
        case let .roomMessage(requestId,roomId,eventType,content):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(roomId, into: &buf)
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(content, into: &buf)
            
        
        case let .signatureUpload(requestId,body):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRequest_lift(_ buf: RustBuffer) throws -> Request {
    return try FfiConverterTypeRequest.lift(buf)
}

public func FfiConverterTypeRequest_lower(_ value: Request) -> RustBuffer {
    return FfiConverterTypeRequest.lower(value)
}


extension Request: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RequestType {
    
    case keysQuery
    case keysClaim
    case keysUpload
    case toDevice
    case signatureUpload
    case keysBackup
    case roomMessage
}


public struct FfiConverterTypeRequestType: FfiConverterRustBuffer {
    typealias SwiftType = RequestType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .keysQuery
        
        case 2: return .keysClaim
        
        case 3: return .keysUpload
        
        case 4: return .toDevice
        
        case 5: return .signatureUpload
        
        case 6: return .keysBackup
        
        case 7: return .roomMessage
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .keysQuery:
            writeInt(&buf, Int32(1))
        
        
        case .keysClaim:
            writeInt(&buf, Int32(2))
        
        
        case .keysUpload:
            writeInt(&buf, Int32(3))
        
        
        case .toDevice:
            writeInt(&buf, Int32(4))
        
        
        case .signatureUpload:
            writeInt(&buf, Int32(5))
        
        
        case .keysBackup:
            writeInt(&buf, Int32(6))
        
        
        case .roomMessage:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeRequestType_lift(_ buf: RustBuffer) throws -> RequestType {
    return try FfiConverterTypeRequestType.lift(buf)
}

public func FfiConverterTypeRequestType_lower(_ value: RequestType) -> RustBuffer {
    return FfiConverterTypeRequestType.lower(value)
}


extension RequestType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An Enum describing the state the SAS verification is in.
 */

public enum SasState {
    
    /**
     * The verification has been started, the protocols that should be used
     * have been proposed and can be accepted.
     */
    case started
    /**
     * The verification has been accepted and both sides agreed to a set of
     * protocols that will be used for the verification process.
     */
    case accepted
    /**
     * The public keys have been exchanged and the short auth string can be
     * presented to the user.
     */
    case keysExchanged(
        /**
         * The emojis that represent the short auth string, will be `None` if
         * the emoji SAS method wasn't one of accepted protocols.
         */emojis: [Int32]?, 
        /**
         * The list of decimals that represent the short auth string.
         */decimals: [Int32]
    )
    /**
     * The verification process has been confirmed from our side, we're waiting
     * for the other side to confirm as well.
     */
    case confirmed
    /**
     * The verification process has been successfully concluded.
     */
    case done
    /**
     * The verification process has been cancelled.
     */
    case cancelled(
        /**
         * Information about the reason of the cancellation.
         */cancelInfo: CancelInfo
    )
}


public struct FfiConverterTypeSasState: FfiConverterRustBuffer {
    typealias SwiftType = SasState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SasState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .started
        
        case 2: return .accepted
        
        case 3: return .keysExchanged(emojis: try FfiConverterOptionSequenceInt32.read(from: &buf), decimals: try FfiConverterSequenceInt32.read(from: &buf)
        )
        
        case 4: return .confirmed
        
        case 5: return .done
        
        case 6: return .cancelled(cancelInfo: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SasState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .started:
            writeInt(&buf, Int32(1))
        
        
        case .accepted:
            writeInt(&buf, Int32(2))
        
        
        case let .keysExchanged(emojis,decimals):
            writeInt(&buf, Int32(3))
            FfiConverterOptionSequenceInt32.write(emojis, into: &buf)
            FfiConverterSequenceInt32.write(decimals, into: &buf)
            
        
        case .confirmed:
            writeInt(&buf, Int32(4))
        
        
        case .done:
            writeInt(&buf, Int32(5))
        
        
        case let .cancelled(cancelInfo):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCancelInfo.write(cancelInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSasState_lift(_ buf: RustBuffer) throws -> SasState {
    return try FfiConverterTypeSasState.lift(buf)
}

public func FfiConverterTypeSasState_lower(_ value: SasState) -> RustBuffer {
    return FfiConverterTypeSasState.lower(value)
}


extension SasState: Equatable, Hashable {}




public enum SecretImportError {

    
    
    case CryptoStore(message: String)
    
    case Import(message: String)
    
}


public struct FfiConverterTypeSecretImportError: FfiConverterRustBuffer {
    typealias SwiftType = SecretImportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretImportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Import(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecretImportError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Import(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


extension SecretImportError: Equatable, Hashable {}

extension SecretImportError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]
 * for more info.
 */

public enum ShieldColor {
    
    case red
    case grey
    case none
}


public struct FfiConverterTypeShieldColor: FfiConverterRustBuffer {
    typealias SwiftType = ShieldColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red
        
        case 2: return .grey
        
        case 3: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShieldColor, into buf: inout [UInt8]) {
        switch value {
        
        
        case .red:
            writeInt(&buf, Int32(1))
        
        
        case .grey:
            writeInt(&buf, Int32(2))
        
        
        case .none:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeShieldColor_lift(_ buf: RustBuffer) throws -> ShieldColor {
    return try FfiConverterTypeShieldColor.lift(buf)
}

public func FfiConverterTypeShieldColor_lower(_ value: ShieldColor) -> RustBuffer {
    return FfiConverterTypeShieldColor.lower(value)
}


extension ShieldColor: Equatable, Hashable {}




public enum SignatureError {

    
    
    case Signature(message: String)
    
    case Identifier(message: String)
    
    case CryptoStore(message: String)
    
    case UnknownDevice(message: String)
    
    case UnknownUserIdentity(message: String)
    
}


public struct FfiConverterTypeSignatureError: FfiConverterRustBuffer {
    typealias SwiftType = SignatureError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Signature(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Identifier(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .UnknownDevice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .UnknownUserIdentity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Signature(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Identifier(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .UnknownDevice(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .UnknownUserIdentity(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


extension SignatureError: Equatable, Hashable {}

extension SignatureError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing cross signing identities of our own user or some other
 * user.
 */

public enum UserIdentity {
    
    /**
     * Our own user identity.
     */
    case own(
        /**
         * The unique id of our own user.
         */userId: String, 
        /**
         * Does our own user identity trust our own device.
         */trustsOurOwnDevice: Bool, 
        /**
         * The public master key of our identity.
         */masterKey: String, 
        /**
         * The public user-signing key of our identity.
         */userSigningKey: String, 
        /**
         * The public self-signing key of our identity.
         */selfSigningKey: String
    )
    /**
     * The user identity of other users.
     */
    case other(
        /**
         * The unique id of the user.
         */userId: String, 
        /**
         * The public master key of the identity.
         */masterKey: String, 
        /**
         * The public self-signing key of our identity.
         */selfSigningKey: String
    )
}


public struct FfiConverterTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserIdentity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .own(userId: try FfiConverterString.read(from: &buf), trustsOurOwnDevice: try FfiConverterBool.read(from: &buf), masterKey: try FfiConverterString.read(from: &buf), userSigningKey: try FfiConverterString.read(from: &buf), selfSigningKey: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .other(userId: try FfiConverterString.read(from: &buf), masterKey: try FfiConverterString.read(from: &buf), selfSigningKey: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UserIdentity, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .own(userId,trustsOurOwnDevice,masterKey,userSigningKey,selfSigningKey):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterBool.write(trustsOurOwnDevice, into: &buf)
            FfiConverterString.write(masterKey, into: &buf)
            FfiConverterString.write(userSigningKey, into: &buf)
            FfiConverterString.write(selfSigningKey, into: &buf)
            
        
        case let .other(userId,masterKey,selfSigningKey):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterString.write(masterKey, into: &buf)
            FfiConverterString.write(selfSigningKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUserIdentity_lift(_ buf: RustBuffer) throws -> UserIdentity {
    return try FfiConverterTypeUserIdentity.lift(buf)
}

public func FfiConverterTypeUserIdentity_lower(_ value: UserIdentity) -> RustBuffer {
    return FfiConverterTypeUserIdentity.lower(value)
}


extension UserIdentity: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An Enum describing the state the QrCode verification is in.
 */

public enum VerificationRequestState {
    
    /**
     * The verification request was sent
     */
    case requested
    /**
     * The verification request is ready to start a verification flow.
     */
    case ready(
        /**
         * The verification methods supported by the other side.
         */theirMethods: [String], 
        /**
         * The verification methods supported by the us.
         */ourMethods: [String]
    )
    /**
     * The verification flow that was started with this request has finished.
     */
    case done
    /**
     * The verification process has been cancelled.
     */
    case cancelled(
        /**
         * Information about the reason of the cancellation.
         */cancelInfo: CancelInfo
    )
}


public struct FfiConverterTypeVerificationRequestState: FfiConverterRustBuffer {
    typealias SwiftType = VerificationRequestState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationRequestState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .requested
        
        case 2: return .ready(theirMethods: try FfiConverterSequenceString.read(from: &buf), ourMethods: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 3: return .done
        
        case 4: return .cancelled(cancelInfo: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerificationRequestState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .requested:
            writeInt(&buf, Int32(1))
        
        
        case let .ready(theirMethods,ourMethods):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceString.write(theirMethods, into: &buf)
            FfiConverterSequenceString.write(ourMethods, into: &buf)
            
        
        case .done:
            writeInt(&buf, Int32(3))
        
        
        case let .cancelled(cancelInfo):
            writeInt(&buf, Int32(4))
            FfiConverterTypeCancelInfo.write(cancelInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeVerificationRequestState_lift(_ buf: RustBuffer) throws -> VerificationRequestState {
    return try FfiConverterTypeVerificationRequestState.lift(buf)
}

public func FfiConverterTypeVerificationRequestState_lower(_ value: VerificationRequestState) -> RustBuffer {
    return FfiConverterTypeVerificationRequestState.lower(value)
}


extension VerificationRequestState: Equatable, Hashable {}






/**
 * Trait that can be used to forward Rust logs over FFI to a language specific
 * logger.
 */
public protocol Logger : AnyObject {
    
    /**
     * Called every time the Rust side wants to post a log line.
     */
    func log(logLine: String) 
    
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogger {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLogger = UniffiVTableCallbackInterfaceLogger(
        log: { (
            uniffiHandle: UInt64,
            logLine: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let uniffiObj: Logger
            do {
                try uniffiObj = FfiConverterCallbackInterfaceLogger.handleMap.get(handle: uniffiHandle)
            } catch {
                uniffiCallStatus.pointee.code = CALL_UNEXPECTED_ERROR
                uniffiCallStatus.pointee.errorBuf = FfiConverterString.lower("Callback handle map error: \(error)")
                return
            }
            let makeCall = { uniffiObj.log(
                 logLine: try FfiConverterString.lift(logLine)
            ) }
            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Logger: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLogger() {
    uniffi_matrix_sdk_crypto_ffi_fn_init_callback_vtable_logger(&UniffiCallbackInterfaceLogger.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceLogger {
    fileprivate static var handleMap = UniffiHandleMap<Logger>()
}

extension FfiConverterCallbackInterfaceLogger : FfiConverter {
    typealias SwiftType = Logger
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * Callback that will be passed over the FFI to report progress
 */
public protocol ProgressListener : AnyObject {
    
    /**
     * The callback that should be called on the Rust side
     *
     * # Arguments
     *
     * * `progress` - The current number of items that have been handled
     *
     * * `total` - The total number of items that will be handled
     */
    func onProgress(progress: Int32, total: Int32) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceProgressListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceProgressListener = UniffiVTableCallbackInterfaceProgressListener(
        onProgress: { (
            uniffiHandle: UInt64,
            progress: Int32,
            total: Int32,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let uniffiObj: ProgressListener
            do {
                try uniffiObj = FfiConverterCallbackInterfaceProgressListener.handleMap.get(handle: uniffiHandle)
            } catch {
                uniffiCallStatus.pointee.code = CALL_UNEXPECTED_ERROR
                uniffiCallStatus.pointee.errorBuf = FfiConverterString.lower("Callback handle map error: \(error)")
                return
            }
            let makeCall = { uniffiObj.onProgress(
                 progress: try FfiConverterInt32.lift(progress),
                 total: try FfiConverterInt32.lift(total)
            ) }
            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceProgressListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ProgressListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitProgressListener() {
    uniffi_matrix_sdk_crypto_ffi_fn_init_callback_vtable_progresslistener(&UniffiCallbackInterfaceProgressListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceProgressListener {
    fileprivate static var handleMap = UniffiHandleMap<ProgressListener>()
}

extension FfiConverterCallbackInterfaceProgressListener : FfiConverter {
    typealias SwiftType = ProgressListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * Listener that will be passed over the FFI to report changes to a QrCode
 * verification.
 */
public protocol QrCodeListener : AnyObject {
    
    /**
     * The callback that should be called on the Rust side
     *
     * # Arguments
     *
     * * `state` - The current state of the QrCode verification.
     */
    func onChange(state: QrCodeState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceQrCodeListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceQrCodeListener = UniffiVTableCallbackInterfaceQrCodeListener(
        onChange: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let uniffiObj: QrCodeListener
            do {
                try uniffiObj = FfiConverterCallbackInterfaceQrCodeListener.handleMap.get(handle: uniffiHandle)
            } catch {
                uniffiCallStatus.pointee.code = CALL_UNEXPECTED_ERROR
                uniffiCallStatus.pointee.errorBuf = FfiConverterString.lower("Callback handle map error: \(error)")
                return
            }
            let makeCall = { uniffiObj.onChange(
                 state: try FfiConverterTypeQrCodeState.lift(state)
            ) }
            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceQrCodeListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface QrCodeListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitQrCodeListener() {
    uniffi_matrix_sdk_crypto_ffi_fn_init_callback_vtable_qrcodelistener(&UniffiCallbackInterfaceQrCodeListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceQrCodeListener {
    fileprivate static var handleMap = UniffiHandleMap<QrCodeListener>()
}

extension FfiConverterCallbackInterfaceQrCodeListener : FfiConverter {
    typealias SwiftType = QrCodeListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * Listener that will be passed over the FFI to report changes to a SAS
 * verification.
 */
public protocol SasListener : AnyObject {
    
    /**
     * The callback that should be called on the Rust side
     *
     * # Arguments
     *
     * * `state` - The current state of the SAS verification.
     */
    func onChange(state: SasState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSasListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSasListener = UniffiVTableCallbackInterfaceSasListener(
        onChange: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let uniffiObj: SasListener
            do {
                try uniffiObj = FfiConverterCallbackInterfaceSasListener.handleMap.get(handle: uniffiHandle)
            } catch {
                uniffiCallStatus.pointee.code = CALL_UNEXPECTED_ERROR
                uniffiCallStatus.pointee.errorBuf = FfiConverterString.lower("Callback handle map error: \(error)")
                return
            }
            let makeCall = { uniffiObj.onChange(
                 state: try FfiConverterTypeSasState.lift(state)
            ) }
            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceSasListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SasListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSasListener() {
    uniffi_matrix_sdk_crypto_ffi_fn_init_callback_vtable_saslistener(&UniffiCallbackInterfaceSasListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSasListener {
    fileprivate static var handleMap = UniffiHandleMap<SasListener>()
}

extension FfiConverterCallbackInterfaceSasListener : FfiConverter {
    typealias SwiftType = SasListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * Listener that will be passed over the FFI to report changes to a
 * verification request.
 */
public protocol VerificationRequestListener : AnyObject {
    
    /**
     * The callback that should be called on the Rust side
     *
     * # Arguments
     *
     * * `state` - The current state of the verification request.
     */
    func onChange(state: VerificationRequestState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceVerificationRequestListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceVerificationRequestListener = UniffiVTableCallbackInterfaceVerificationRequestListener(
        onChange: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let uniffiObj: VerificationRequestListener
            do {
                try uniffiObj = FfiConverterCallbackInterfaceVerificationRequestListener.handleMap.get(handle: uniffiHandle)
            } catch {
                uniffiCallStatus.pointee.code = CALL_UNEXPECTED_ERROR
                uniffiCallStatus.pointee.errorBuf = FfiConverterString.lower("Callback handle map error: \(error)")
                return
            }
            let makeCall = { uniffiObj.onChange(
                 state: try FfiConverterTypeVerificationRequestState.lift(state)
            ) }
            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceVerificationRequestListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface VerificationRequestListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitVerificationRequestListener() {
    uniffi_matrix_sdk_crypto_ffi_fn_init_callback_vtable_verificationrequestlistener(&UniffiCallbackInterfaceVerificationRequestListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceVerificationRequestListener {
    fileprivate static var handleMap = UniffiHandleMap<VerificationRequestListener>()
}

extension FfiConverterCallbackInterfaceVerificationRequestListener : FfiConverter {
    typealias SwiftType = VerificationRequestListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackupKeys: FfiConverterRustBuffer {
    typealias SwiftType = BackupKeys?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackupKeys.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupKeys.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackupRecoveryKey: FfiConverterRustBuffer {
    typealias SwiftType = BackupRecoveryKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackupRecoveryKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupRecoveryKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeQrCode: FfiConverterRustBuffer {
    typealias SwiftType = QrCode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeQrCode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeQrCode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSas: FfiConverterRustBuffer {
    typealias SwiftType = Sas?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSas.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSas.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerification: FfiConverterRustBuffer {
    typealias SwiftType = Verification?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVerification.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerification.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = VerificationRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVerificationRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerificationRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCancelInfo: FfiConverterRustBuffer {
    typealias SwiftType = CancelInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCancelInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCancelInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeConfirmVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmVerificationResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConfirmVerificationResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConfirmVerificationResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCrossSigningKeyExport: FfiConverterRustBuffer {
    typealias SwiftType = CrossSigningKeyExport?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCrossSigningKeyExport.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCrossSigningKeyExport.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDevice: FfiConverterRustBuffer {
    typealias SwiftType = Device?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDevice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDevice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePassphraseInfo: FfiConverterRustBuffer {
    typealias SwiftType = PassphraseInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePassphraseInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePassphraseInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRequestVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = RequestVerificationResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequestVerificationResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequestVerificationResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomSettings: FfiConverterRustBuffer {
    typealias SwiftType = RoomSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeScanResult: FfiConverterRustBuffer {
    typealias SwiftType = ScanResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeScanResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeScanResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSignatureUploadRequest: FfiConverterRustBuffer {
    typealias SwiftType = SignatureUploadRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignatureUploadRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignatureUploadRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeStartSasResult: FfiConverterRustBuffer {
    typealias SwiftType = StartSasResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStartSasResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStartSasResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingVerificationRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutgoingVerificationRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = Request?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserIdentity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserIdentity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]

    public static func write(_ value: [Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int32] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = [VerificationRequest]

    public static func write(_ value: [VerificationRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerificationRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerificationRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerificationRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerificationRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDevice: FfiConverterRustBuffer {
    typealias SwiftType = [Device]

    public static func write(_ value: [Device], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDevice.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Device] {
        let len: Int32 = try readInt(&buf)
        var seq = [Device]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDevice.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePickledInboundGroupSession: FfiConverterRustBuffer {
    typealias SwiftType = [PickledInboundGroupSession]

    public static func write(_ value: [PickledInboundGroupSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePickledInboundGroupSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PickledInboundGroupSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [PickledInboundGroupSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePickledInboundGroupSession.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePickledSession: FfiConverterRustBuffer {
    typealias SwiftType = [PickledSession]

    public static func write(_ value: [PickledSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePickledSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PickledSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [PickledSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePickledSession.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomKeyInfo: FfiConverterRustBuffer {
    typealias SwiftType = [RoomKeyInfo]

    public static func write(_ value: [RoomKeyInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomKeyInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomKeyInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomKeyInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomKeyInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = [OutgoingVerificationRequest]

    public static func write(_ value: [OutgoingVerificationRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutgoingVerificationRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutgoingVerificationRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutgoingVerificationRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutgoingVerificationRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = [Request]

    public static func write(_ value: [Request], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Request] {
        let len: Int32 = try readInt(&buf)
        var seq = [Request]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringInt32: FfiConverterRustBuffer {
    public static func write(_ value: [String: Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterInt32.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Int32] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Int32]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterInt32.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeRoomSettings: FfiConverterRustBuffer {
    public static func write(_ value: [String: RoomSettings], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeRoomSettings.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: RoomSettings] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: RoomSettings]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeRoomSettings.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: [String]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: [String]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: [String]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeSignatureState: FfiConverterRustBuffer {
    public static func write(_ value: [String: SignatureState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeSignatureState.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: SignatureState] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: SignatureState]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeSignatureState.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}




/**
 * Migrate a libolm based setup to a vodozemac based setup stored in a SQLite
 * store.
 *
 * # Arguments
 *
 * * `data` - The data that should be migrated over to the SQLite store.
 *
 * * `path` - The path where the SQLite store should be created.
 *
 * * `passphrase` - The passphrase that should be used to encrypt the data at
 * rest in the SQLite store. **Warning**, if no passphrase is given, the store
 * and all its data will remain unencrypted.
 *
 * * `progress_listener` - A callback that can be used to introspect the
 * progress of the migration.
 */
public func migrate(data: MigrationData, path: String, passphrase: String?, progressListener: ProgressListener) throws  {
    try rustCallWithError(FfiConverterTypeMigrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_func_migrate(
        FfiConverterTypeMigrationData.lower(data),
        FfiConverterString.lower(path),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterCallbackInterfaceProgressListener.lower(progressListener),$0)
}
}


/**
 * Migrate room settings, including room algorithm and whether to block
 * untrusted devices from legacy store to Sqlite store.
 *
 * Note that this method should only be used if a client has already migrated
 * account data via [migrate](#method.migrate) method, which did not include
 * room settings. For a brand new migration, the [migrate](#method.migrate)
 * method will take care of room settings automatically, if provided.
 *
 * # Arguments
 *
 * * `room_settings` - Map of room settings
 *
 * * `path` - The path where the Sqlite store should be created.
 *
 * * `passphrase` - The passphrase that should be used to encrypt the data at
 * rest in the Sqlite store. **Warning**, if no passphrase is given, the store
 * and all its data will remain unencrypted.
 */
public func migrateRoomSettings(roomSettings: [String: RoomSettings], path: String, passphrase: String?) throws  {
    try rustCallWithError(FfiConverterTypeMigrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_func_migrate_room_settings(
        FfiConverterDictionaryStringTypeRoomSettings.lower(roomSettings),
        FfiConverterString.lower(path),
        FfiConverterOptionString.lower(passphrase),$0)
}
}


/**
 * Migrate sessions and group sessions of a libolm based setup to a vodozemac
 * based setup stored in a SQLite store.
 *
 * This method allows you to migrate a subset of the data, it should only be
 * used after the [`migrate()`] method has been already used.
 *
 * # Arguments
 *
 * * `data` - The data that should be migrated over to the SQLite store.
 *
 * * `path` - The path where the SQLite store should be created.
 *
 * * `passphrase` - The passphrase that should be used to encrypt the data at
 * rest in the SQLite store. **Warning**, if no passphrase is given, the store
 * and all its data will remain unencrypted.
 *
 * * `progress_listener` - A callback that can be used to introspect the
 * progress of the migration.
 */
public func migrateSessions(data: SessionMigrationData, path: String, passphrase: String?, progressListener: ProgressListener) throws  {
    try rustCallWithError(FfiConverterTypeMigrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_func_migrate_sessions(
        FfiConverterTypeSessionMigrationData.lower(data),
        FfiConverterString.lower(path),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterCallbackInterfaceProgressListener.lower(progressListener),$0)
}
}


/**
 * Set the logger that should be used to forward Rust logs over FFI.
 */
public func setLogger(logger: Logger)  {
    try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_func_set_logger(
        FfiConverterCallbackInterfaceLogger.lower(logger),$0)
}
}


public func version()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_func_version($0)
}
    )
}
public func versionInfo()  -> VersionInfo {
    return try!  FfiConverterTypeVersionInfo.lift(
        try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_func_version_info($0)
}
    )
}
public func vodozemacVersion()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_func_vodozemac_version($0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_matrix_sdk_crypto_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_migrate() != 20953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_migrate_room_settings() != 9503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_migrate_sessions() != 32884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_set_logger() != 1852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_version() != 18282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_version_info() != 38713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_vodozemac_version() != 31430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backupkeys_backup_version() != 56634) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backupkeys_recovery_key() != 59286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backuprecoverykey_decrypt_v1() != 6370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backuprecoverykey_megolm_v1_public_key() != 54235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backuprecoverykey_to_base58() != 15954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backuprecoverykey_to_base64() != 3854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_dehydrateddevice_keys_for_upload() != 29578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_dehydrateddevices_create() != 20431) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_dehydrateddevices_rehydrate() != 47226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_backup_enabled() != 55573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_backup_room_keys() != 36224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_bootstrap_cross_signing() != 16272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_create_encrypted_to_device_request() != 45148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_cross_signing_status() != 60700) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_decrypt_room_event() != 35394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_dehydrated_devices() != 29352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_device_id() != 8368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_disable_backup() != 41418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_discard_room_key() != 42116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_enable_backup_v1() != 34432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_encrypt() != 46212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_export_cross_signing_keys() != 5979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_export_room_keys() != 27800) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_backup_keys() != 32402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_device() != 14526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_identity() != 64741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_missing_sessions() != 63107) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_only_allow_trusted_devices() != 41002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_room_settings() != 53513) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_user_devices() != 894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_verification() != 61548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_verification_request() != 32419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_verification_requests() != 38091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_identity_keys() != 27954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_import_cross_signing_keys() != 40433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_import_decrypted_room_keys() != 20936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_import_room_keys() != 25983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_is_identity_verified() != 32828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_is_user_tracked() != 57926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_mark_request_as_sent() != 47188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_outgoing_requests() != 60867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_query_missing_secrets_from_other_sessions() != 33649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_receive_sync_changes() != 45979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_receive_unencrypted_verification_event() != 60815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_receive_verification_event() != 6630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_request_room_key() != 46819) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_request_self_verification() != 20955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_request_verification() != 43664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_request_verification_with_device() != 24682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_room_key_counts() != 50492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_save_recovery_key() != 38498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_set_local_trust() != 24597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_set_only_allow_trusted_devices() != 51024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_set_room_algorithm() != 3591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_set_room_only_allow_trusted_devices() != 52214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_share_room_history_keys() != 62549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_share_room_key() != 17) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_sign() != 2594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_start_sas_with_device() != 30388) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_update_tracked_users() != 49136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_user_id() != 28648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_verification_request_content() != 41508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_verify_backup() != 48904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_verify_device() != 26767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_verify_identity() != 13082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_cancel() != 63820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_cancel_info() != 797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_confirm() != 7766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_flow_id() != 38858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_generate_qr_code() != 38303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_has_been_scanned() != 34711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_is_cancelled() != 17076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_is_done() != 64647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_other_device_id() != 18546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_other_user_id() != 32903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_reciprocated() != 29284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_room_id() != 42325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_set_changes_listener() != 57396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_state() != 26065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_we_started() != 39359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_rehydrateddevice_receive_events() != 60225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_accept() != 23750) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_cancel() != 21684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_confirm() != 2955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_flow_id() != 8039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_get_decimals() != 6633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_get_emoji_indices() != 21471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_is_done() != 23641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_other_device_id() != 55711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_other_user_id() != 5587) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_room_id() != 56710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_set_changes_listener() != 50290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_state() != 5148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_we_started() != 20077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verification_as_qr() != 38638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verification_as_sas() != 62612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_accept() != 28851) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_cancel() != 45120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_cancel_info() != 58718) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_flow_id() != 48899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_is_cancelled() != 5406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_is_done() != 6301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_is_passive() != 29071) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_is_ready() != 46804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_other_device_id() != 57800) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_other_user_id() != 32763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_our_supported_methods() != 59504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_room_id() != 15921) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_scan_qr_code() != 7778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_set_changes_listener() != 573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_start_qr_verification() != 1161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_start_sas_verification() != 31406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_state() != 50283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_their_supported_methods() != 50334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_we_started() != 30926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_from_base58() != 39905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_from_base64() != 3983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_from_passphrase() != 40050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_new() != 24749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_new_from_passphrase() != 353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_olmmachine_new() != 31217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_logger_log() != 39295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_progresslistener_on_progress() != 31558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcodelistener_on_change() != 40599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_saslistener_on_change() != 16736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequestlistener_on_change() != 52712) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitLogger()
    uniffiCallbackInitProgressListener()
    uniffiCallbackInitQrCodeListener()
    uniffiCallbackInitSasListener()
    uniffiCallbackInitVerificationRequestListener()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all