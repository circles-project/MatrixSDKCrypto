// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MatrixSDKCryptoFFI)
import MatrixSDKCryptoFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_c3eb_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_c3eb_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
fileprivate class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        self.offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset..<offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value, { data.copyBytes(to: $0, from: range)})
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> Array<UInt8> {
        let range = offset..<(offset+count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer({ buffer in
            data.copyBytes(to: buffer, from: range)
        })
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
fileprivate class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        self.bytes = []
        self.offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: Writer)
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    static func lift(_ buf: RustBuffer) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    static func lower(_ value: SwiftType) -> RustBuffer {
          let writer = Writer()
          write(value, into: writer)
          return RustBuffer(bytes: writer.bytes)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    static func read(from buf: Reader) throws -> UInt8 {
        return try lift(buf.readInt())
    }

    static func write(_ value: UInt8, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    static func read(from buf: Reader) throws -> UInt32 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    static func read(from buf: Reader) throws -> Int32 {
        return try lift(buf.readInt())
    }

    static func write(_ value: Int32, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    static func read(from buf: Reader) throws -> UInt64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    static func read(from buf: Reader) throws -> Int64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: Int64, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    static func read(from buf: Reader) throws -> Bool {
        return try lift(buf.readInt())
    }

    static func write(_ value: Bool, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    static func read(from buf: Reader) throws -> String {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    static func write(_ value: String, into buf: Writer) {
        let len = Int32(value.utf8.count)
        buf.writeInt(len)
        buf.writeBytes(value.utf8)
    }
}


public protocol BackupKeysProtocol {
    func `recoveryKey`()  -> BackupRecoveryKey
    func `backupVersion`()  -> String
    
}

public class BackupKeys: BackupKeysProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_c3eb_BackupKeys_object_free(pointer, $0) }
    }

    

    
    public func `recoveryKey`()  -> BackupRecoveryKey {
        return try! FfiConverterTypeBackupRecoveryKey.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_BackupKeys_recovery_key(self.pointer, $0
    )
}
        )
    }
    public func `backupVersion`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_BackupKeys_backup_version(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeBackupKeys: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupKeys

    static func read(from buf: Reader) throws -> BackupKeys {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: BackupKeys, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupKeys {
        return BackupKeys(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: BackupKeys) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol BackupRecoveryKeyProtocol {
    func `megolmV1PublicKey`()  -> MegolmV1BackupKey
    func `decryptV1`(`ephemeralKey`: String, `mac`: String, `ciphertext`: String) throws -> String
    func `toBase58`()  -> String
    func `toBase64`()  -> String
    
}

public class BackupRecoveryKey: BackupRecoveryKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_BackupRecoveryKey_new($0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_c3eb_BackupRecoveryKey_object_free(pointer, $0) }
    }

    
    public static func `fromPassphrase`(`passphrase`: String, `salt`: String, `rounds`: Int32)  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try!
    
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_BackupRecoveryKey_from_passphrase(
        FfiConverterString.lower(`passphrase`), 
        FfiConverterString.lower(`salt`), 
        FfiConverterInt32.lower(`rounds`), $0)
})
    }
    
    public static func `newFromPassphrase`(`passphrase`: String)  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try!
    
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_BackupRecoveryKey_new_from_passphrase(
        FfiConverterString.lower(`passphrase`), $0)
})
    }
    
    public static func `fromBase64`(`key`: String) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeDecodeError.self) {
    
    matrix_sdk_crypto_ffi_c3eb_BackupRecoveryKey_from_base64(
        FfiConverterString.lower(`key`), $0)
})
    }
    
    public static func `fromBase58`(`key`: String) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeDecodeError.self) {
    
    matrix_sdk_crypto_ffi_c3eb_BackupRecoveryKey_from_base58(
        FfiConverterString.lower(`key`), $0)
})
    }
    

    
    public func `megolmV1PublicKey`()  -> MegolmV1BackupKey {
        return try! FfiConverterTypeMegolmV1BackupKey.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_BackupRecoveryKey_megolm_v1_public_key(self.pointer, $0
    )
}
        )
    }
    public func `decryptV1`(`ephemeralKey`: String, `mac`: String, `ciphertext`: String) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypePkDecryptionError.self) {
    matrix_sdk_crypto_ffi_c3eb_BackupRecoveryKey_decrypt_v1(self.pointer, 
        FfiConverterString.lower(`ephemeralKey`), 
        FfiConverterString.lower(`mac`), 
        FfiConverterString.lower(`ciphertext`), $0
    )
}
        )
    }
    public func `toBase58`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_BackupRecoveryKey_to_base58_c5e(self.pointer, $0
    )
}
        )
    }
    public func `toBase64`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_BackupRecoveryKey_to_base64_c9a3(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeBackupRecoveryKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupRecoveryKey

    static func read(from buf: Reader) throws -> BackupRecoveryKey {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: BackupRecoveryKey, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: BackupRecoveryKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol OlmMachineProtocol {
    func `receiveSyncChanges`(`events`: String, `deviceChanges`: DeviceLists, `keyCounts`: [String: Int32], `unusedFallbackKeys`: [String]?) throws -> String
    func `outgoingRequests`() throws -> [Request]
    func `markRequestAsSent`(`requestId`: String, `requestType`: RequestType, `response`: String) throws
    func `decryptRoomEvent`(`event`: String, `roomId`: String) throws -> DecryptedEvent
    func `encrypt`(`roomId`: String, `eventType`: String, `content`: String) throws -> String
    func `getIdentity`(`userId`: String, `timeout`: UInt32) throws -> UserIdentity?
    func `verifyIdentity`(`userId`: String) throws -> SignatureUploadRequest
    func `getDevice`(`userId`: String, `deviceId`: String, `timeout`: UInt32) throws -> Device?
    func `setLocalTrust`(`userId`: String, `deviceId`: String, `trustState`: LocalTrust) throws
    func `verifyDevice`(`userId`: String, `deviceId`: String) throws -> SignatureUploadRequest
    func `getUserDevices`(`userId`: String, `timeout`: UInt32) throws -> [Device]
    func `isUserTracked`(`userId`: String) throws -> Bool
    func `updateTrackedUsers`(`users`: [String]) 
    func `getMissingSessions`(`users`: [String]) throws -> Request?
    func `shareRoomKey`(`roomId`: String, `users`: [String], `settings`: EncryptionSettings) throws -> [Request]
    func `receiveUnencryptedVerificationEvent`(`event`: String, `roomId`: String) throws
    func `getVerificationRequests`(`userId`: String)  -> [VerificationRequest]
    func `getVerificationRequest`(`userId`: String, `flowId`: String)  -> VerificationRequest?
    func `getVerification`(`userId`: String, `flowId`: String)  -> Verification?
    func `requestVerification`(`userId`: String, `roomId`: String, `eventId`: String, `methods`: [String]) throws -> VerificationRequest?
    func `verificationRequestContent`(`userId`: String, `methods`: [String]) throws -> String?
    func `requestSelfVerification`(`methods`: [String]) throws -> RequestVerificationResult?
    func `requestVerificationWithDevice`(`userId`: String, `deviceId`: String, `methods`: [String]) throws -> RequestVerificationResult?
    func `acceptVerificationRequest`(`userId`: String, `flowId`: String, `methods`: [String])  -> OutgoingVerificationRequest?
    func `confirmVerification`(`userId`: String, `flowId`: String) throws -> ConfirmVerificationResult?
    func `cancelVerification`(`userId`: String, `flowId`: String, `cancelCode`: String)  -> OutgoingVerificationRequest?
    func `startSasWithDevice`(`userId`: String, `deviceId`: String) throws -> StartSasResult?
    func `startSasVerification`(`userId`: String, `flowId`: String) throws -> StartSasResult?
    func `acceptSasVerification`(`userId`: String, `flowId`: String)  -> OutgoingVerificationRequest?
    func `getEmojiIndex`(`userId`: String, `flowId`: String)  -> [Int32]?
    func `getDecimals`(`userId`: String, `flowId`: String)  -> [Int32]?
    func `startQrVerification`(`userId`: String, `flowId`: String) throws -> QrCode?
    func `scanQrCode`(`userId`: String, `flowId`: String, `data`: String)  -> ScanResult?
    func `generateQrCode`(`userId`: String, `flowId`: String)  -> String?
    func `requestRoomKey`(`event`: String, `roomId`: String) throws -> KeyRequestPair
    func `exportRoomKeys`(`passphrase`: String, `rounds`: Int32) throws -> String
    func `importRoomKeys`(`keys`: String, `passphrase`: String, `progressListener`: ProgressListener) throws -> KeysImportResult
    func `importDecryptedRoomKeys`(`keys`: String, `progressListener`: ProgressListener) throws -> KeysImportResult
    func `discardRoomKey`(`roomId`: String) throws
    func `crossSigningStatus`()  -> CrossSigningStatus
    func `bootstrapCrossSigning`() throws -> BootstrapCrossSigningResult
    func `exportCrossSigningKeys`()  -> CrossSigningKeyExport?
    func `importCrossSigningKeys`(`export`: CrossSigningKeyExport) throws
    func `isIdentityVerified`(`userId`: String) throws -> Bool
    func `sign`(`message`: String)  -> [String: [String: String]]
    func `enableBackupV1`(`key`: MegolmV1BackupKey, `version`: String) throws
    func `disableBackup`() throws
    func `backupRoomKeys`() throws -> Request?
    func `saveRecoveryKey`(`key`: BackupRecoveryKey?, `version`: String?) throws
    func `roomKeyCounts`() throws -> RoomKeyCounts
    func `getBackupKeys`() throws -> BackupKeys?
    func `backupEnabled`()  -> Bool
    func `verifyBackup`(`authData`: String) throws -> Bool
    func `deviceId`()  -> String
    func `identityKeys`()  -> [String: String]
    func `userId`()  -> String
    
}

public class OlmMachine: OlmMachineProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`userId`: String, `deviceId`: String, `path`: String, `passphrase`: String?) throws {
        self.init(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_new(
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), 
        FfiConverterString.lower(`path`), 
        FfiConverterOptionString.lower(`passphrase`), $0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_c3eb_OlmMachine_object_free(pointer, $0) }
    }

    

    
    public func `receiveSyncChanges`(`events`: String, `deviceChanges`: DeviceLists, `keyCounts`: [String: Int32], `unusedFallbackKeys`: [String]?) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_receive_sync_changes(self.pointer, 
        FfiConverterString.lower(`events`), 
        FfiConverterTypeDeviceLists.lower(`deviceChanges`), 
        FfiConverterDictionaryStringInt32.lower(`keyCounts`), 
        FfiConverterOptionSequenceString.lower(`unusedFallbackKeys`), $0
    )
}
        )
    }
    public func `outgoingRequests`() throws -> [Request] {
        return try FfiConverterSequenceTypeRequest.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_outgoing_requests(self.pointer, $0
    )
}
        )
    }
    public func `markRequestAsSent`(`requestId`: String, `requestType`: RequestType, `response`: String) throws {
        try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_mark_request_as_sent(self.pointer, 
        FfiConverterString.lower(`requestId`), 
        FfiConverterTypeRequestType.lower(`requestType`), 
        FfiConverterString.lower(`response`), $0
    )
}
    }
    public func `decryptRoomEvent`(`event`: String, `roomId`: String) throws -> DecryptedEvent {
        return try FfiConverterTypeDecryptedEvent.lift(
            try
    rustCallWithError(FfiConverterTypeDecryptionError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_decrypt_room_event(self.pointer, 
        FfiConverterString.lower(`event`), 
        FfiConverterString.lower(`roomId`), $0
    )
}
        )
    }
    public func `encrypt`(`roomId`: String, `eventType`: String, `content`: String) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_encrypt(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterString.lower(`eventType`), 
        FfiConverterString.lower(`content`), $0
    )
}
        )
    }
    public func `getIdentity`(`userId`: String, `timeout`: UInt32) throws -> UserIdentity? {
        return try FfiConverterOptionTypeUserIdentity.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_identity(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterUInt32.lower(`timeout`), $0
    )
}
        )
    }
    public func `verifyIdentity`(`userId`: String) throws -> SignatureUploadRequest {
        return try FfiConverterTypeSignatureUploadRequest.lift(
            try
    rustCallWithError(FfiConverterTypeSignatureError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_verify_identity(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }
    public func `getDevice`(`userId`: String, `deviceId`: String, `timeout`: UInt32) throws -> Device? {
        return try FfiConverterOptionTypeDevice.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_device(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), 
        FfiConverterUInt32.lower(`timeout`), $0
    )
}
        )
    }
    public func `setLocalTrust`(`userId`: String, `deviceId`: String, `trustState`: LocalTrust) throws {
        try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_set_local_trust(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), 
        FfiConverterTypeLocalTrust.lower(`trustState`), $0
    )
}
    }
    public func `verifyDevice`(`userId`: String, `deviceId`: String) throws -> SignatureUploadRequest {
        return try FfiConverterTypeSignatureUploadRequest.lift(
            try
    rustCallWithError(FfiConverterTypeSignatureError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_verify_device(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), $0
    )
}
        )
    }
    public func `getUserDevices`(`userId`: String, `timeout`: UInt32) throws -> [Device] {
        return try FfiConverterSequenceTypeDevice.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_user_devices(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterUInt32.lower(`timeout`), $0
    )
}
        )
    }
    public func `isUserTracked`(`userId`: String) throws -> Bool {
        return try FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_is_user_tracked(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }
    public func `updateTrackedUsers`(`users`: [String])  {
        try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_update_tracked_users(self.pointer, 
        FfiConverterSequenceString.lower(`users`), $0
    )
}
    }
    public func `getMissingSessions`(`users`: [String]) throws -> Request? {
        return try FfiConverterOptionTypeRequest.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_missing_sessions(self.pointer, 
        FfiConverterSequenceString.lower(`users`), $0
    )
}
        )
    }
    public func `shareRoomKey`(`roomId`: String, `users`: [String], `settings`: EncryptionSettings) throws -> [Request] {
        return try FfiConverterSequenceTypeRequest.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_share_room_key(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterSequenceString.lower(`users`), 
        FfiConverterTypeEncryptionSettings.lower(`settings`), $0
    )
}
        )
    }
    public func `receiveUnencryptedVerificationEvent`(`event`: String, `roomId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_receive_unencrypted_verification_event(self.pointer, 
        FfiConverterString.lower(`event`), 
        FfiConverterString.lower(`roomId`), $0
    )
}
    }
    public func `getVerificationRequests`(`userId`: String)  -> [VerificationRequest] {
        return try! FfiConverterSequenceTypeVerificationRequest.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_verification_requests(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }
    public func `getVerificationRequest`(`userId`: String, `flowId`: String)  -> VerificationRequest? {
        return try! FfiConverterOptionTypeVerificationRequest.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_verification_request(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `getVerification`(`userId`: String, `flowId`: String)  -> Verification? {
        return try! FfiConverterOptionTypeVerification.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_verification(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `requestVerification`(`userId`: String, `roomId`: String, `eventId`: String, `methods`: [String]) throws -> VerificationRequest? {
        return try FfiConverterOptionTypeVerificationRequest.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_request_verification(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`roomId`), 
        FfiConverterString.lower(`eventId`), 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }
    public func `verificationRequestContent`(`userId`: String, `methods`: [String]) throws -> String? {
        return try FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_verification_request_content(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }
    public func `requestSelfVerification`(`methods`: [String]) throws -> RequestVerificationResult? {
        return try FfiConverterOptionTypeRequestVerificationResult.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_request_self_verification(self.pointer, 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }
    public func `requestVerificationWithDevice`(`userId`: String, `deviceId`: String, `methods`: [String]) throws -> RequestVerificationResult? {
        return try FfiConverterOptionTypeRequestVerificationResult.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_request_verification_with_device(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }
    public func `acceptVerificationRequest`(`userId`: String, `flowId`: String, `methods`: [String])  -> OutgoingVerificationRequest? {
        return try! FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_accept_verification_request(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }
    public func `confirmVerification`(`userId`: String, `flowId`: String) throws -> ConfirmVerificationResult? {
        return try FfiConverterOptionTypeConfirmVerificationResult.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_confirm_verification(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `cancelVerification`(`userId`: String, `flowId`: String, `cancelCode`: String)  -> OutgoingVerificationRequest? {
        return try! FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_cancel_verification(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), 
        FfiConverterString.lower(`cancelCode`), $0
    )
}
        )
    }
    public func `startSasWithDevice`(`userId`: String, `deviceId`: String) throws -> StartSasResult? {
        return try FfiConverterOptionTypeStartSasResult.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_start_sas_with_device(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), $0
    )
}
        )
    }
    public func `startSasVerification`(`userId`: String, `flowId`: String) throws -> StartSasResult? {
        return try FfiConverterOptionTypeStartSasResult.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_start_sas_verification(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `acceptSasVerification`(`userId`: String, `flowId`: String)  -> OutgoingVerificationRequest? {
        return try! FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_accept_sas_verification(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `getEmojiIndex`(`userId`: String, `flowId`: String)  -> [Int32]? {
        return try! FfiConverterOptionSequenceInt32.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_emoji_index(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `getDecimals`(`userId`: String, `flowId`: String)  -> [Int32]? {
        return try! FfiConverterOptionSequenceInt32.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_decimals(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `startQrVerification`(`userId`: String, `flowId`: String) throws -> QrCode? {
        return try FfiConverterOptionTypeQrCode.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_start_qr_verification(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `scanQrCode`(`userId`: String, `flowId`: String, `data`: String)  -> ScanResult? {
        return try! FfiConverterOptionTypeScanResult.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_scan_qr_code(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), 
        FfiConverterString.lower(`data`), $0
    )
}
        )
    }
    public func `generateQrCode`(`userId`: String, `flowId`: String)  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_generate_qr_code(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }
    public func `requestRoomKey`(`event`: String, `roomId`: String) throws -> KeyRequestPair {
        return try FfiConverterTypeKeyRequestPair.lift(
            try
    rustCallWithError(FfiConverterTypeDecryptionError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_request_room_key(self.pointer, 
        FfiConverterString.lower(`event`), 
        FfiConverterString.lower(`roomId`), $0
    )
}
        )
    }
    public func `exportRoomKeys`(`passphrase`: String, `rounds`: Int32) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_export_room_keys(self.pointer, 
        FfiConverterString.lower(`passphrase`), 
        FfiConverterInt32.lower(`rounds`), $0
    )
}
        )
    }
    public func `importRoomKeys`(`keys`: String, `passphrase`: String, `progressListener`: ProgressListener) throws -> KeysImportResult {
        return try FfiConverterTypeKeysImportResult.lift(
            try
    rustCallWithError(FfiConverterTypeKeyImportError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_import_room_keys(self.pointer, 
        FfiConverterString.lower(`keys`), 
        FfiConverterString.lower(`passphrase`), 
        FfiConverterCallbackInterfaceProgressListener.lower(`progressListener`), $0
    )
}
        )
    }
    public func `importDecryptedRoomKeys`(`keys`: String, `progressListener`: ProgressListener) throws -> KeysImportResult {
        return try FfiConverterTypeKeysImportResult.lift(
            try
    rustCallWithError(FfiConverterTypeKeyImportError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_import_decrypted_room_keys(self.pointer, 
        FfiConverterString.lower(`keys`), 
        FfiConverterCallbackInterfaceProgressListener.lower(`progressListener`), $0
    )
}
        )
    }
    public func `discardRoomKey`(`roomId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_discard_room_key(self.pointer, 
        FfiConverterString.lower(`roomId`), $0
    )
}
    }
    public func `crossSigningStatus`()  -> CrossSigningStatus {
        return try! FfiConverterTypeCrossSigningStatus.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_cross_signing_status(self.pointer, $0
    )
}
        )
    }
    public func `bootstrapCrossSigning`() throws -> BootstrapCrossSigningResult {
        return try FfiConverterTypeBootstrapCrossSigningResult.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_bootstrap_cross_signing(self.pointer, $0
    )
}
        )
    }
    public func `exportCrossSigningKeys`()  -> CrossSigningKeyExport? {
        return try! FfiConverterOptionTypeCrossSigningKeyExport.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_export_cross_signing_keys(self.pointer, $0
    )
}
        )
    }
    public func `importCrossSigningKeys`(`export`: CrossSigningKeyExport) throws {
        try
    rustCallWithError(FfiConverterTypeSecretImportError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_import_cross_signing_keys(self.pointer, 
        FfiConverterTypeCrossSigningKeyExport.lower(`export`), $0
    )
}
    }
    public func `isIdentityVerified`(`userId`: String) throws -> Bool {
        return try FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_is_identity_verified(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }
    public func `sign`(`message`: String)  -> [String: [String: String]] {
        return try! FfiConverterDictionaryStringDictionaryStringString.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_sign(self.pointer, 
        FfiConverterString.lower(`message`), $0
    )
}
        )
    }
    public func `enableBackupV1`(`key`: MegolmV1BackupKey, `version`: String) throws {
        try
    rustCallWithError(FfiConverterTypeDecodeError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_enable_backup_v1(self.pointer, 
        FfiConverterTypeMegolmV1BackupKey.lower(`key`), 
        FfiConverterString.lower(`version`), $0
    )
}
    }
    public func `disableBackup`() throws {
        try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_disable_backup(self.pointer, $0
    )
}
    }
    public func `backupRoomKeys`() throws -> Request? {
        return try FfiConverterOptionTypeRequest.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_backup_room_keys(self.pointer, $0
    )
}
        )
    }
    public func `saveRecoveryKey`(`key`: BackupRecoveryKey?, `version`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_save_recovery_key(self.pointer, 
        FfiConverterOptionTypeBackupRecoveryKey.lower(`key`), 
        FfiConverterOptionString.lower(`version`), $0
    )
}
    }
    public func `roomKeyCounts`() throws -> RoomKeyCounts {
        return try FfiConverterTypeRoomKeyCounts.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_room_key_counts(self.pointer, $0
    )
}
        )
    }
    public func `getBackupKeys`() throws -> BackupKeys? {
        return try FfiConverterOptionTypeBackupKeys.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_get_backup_keys(self.pointer, $0
    )
}
        )
    }
    public func `backupEnabled`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_backup_enabled(self.pointer, $0
    )
}
        )
    }
    public func `verifyBackup`(`authData`: String) throws -> Bool {
        return try FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_c3eb_OlmMachine_verify_backup(self.pointer, 
        FfiConverterString.lower(`authData`), $0
    )
}
        )
    }
    public func `deviceId`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_device_id_99e(self.pointer, $0
    )
}
        )
    }
    public func `identityKeys`()  -> [String: String] {
        return try! FfiConverterDictionaryStringString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_identity_keys_feb5(self.pointer, $0
    )
}
        )
    }
    public func `userId`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_user_id_d909(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeOlmMachine: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OlmMachine

    static func read(from buf: Reader) throws -> OlmMachine {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: OlmMachine, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OlmMachine {
        return OlmMachine(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: OlmMachine) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public struct BootstrapCrossSigningResult {
    public var `uploadSigningKeysRequest`: UploadSigningKeysRequest
    public var `signatureRequest`: SignatureUploadRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`uploadSigningKeysRequest`: UploadSigningKeysRequest, `signatureRequest`: SignatureUploadRequest) {
        self.`uploadSigningKeysRequest` = `uploadSigningKeysRequest`
        self.`signatureRequest` = `signatureRequest`
    }
}


extension BootstrapCrossSigningResult: Equatable, Hashable {
    public static func ==(lhs: BootstrapCrossSigningResult, rhs: BootstrapCrossSigningResult) -> Bool {
        if lhs.`uploadSigningKeysRequest` != rhs.`uploadSigningKeysRequest` {
            return false
        }
        if lhs.`signatureRequest` != rhs.`signatureRequest` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`uploadSigningKeysRequest`)
        hasher.combine(`signatureRequest`)
    }
}


fileprivate struct FfiConverterTypeBootstrapCrossSigningResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> BootstrapCrossSigningResult {
        return try BootstrapCrossSigningResult(
            `uploadSigningKeysRequest`: FfiConverterTypeUploadSigningKeysRequest.read(from: buf), 
            `signatureRequest`: FfiConverterTypeSignatureUploadRequest.read(from: buf)
        )
    }

    fileprivate static func write(_ value: BootstrapCrossSigningResult, into buf: Writer) {
        FfiConverterTypeUploadSigningKeysRequest.write(value.`uploadSigningKeysRequest`, into: buf)
        FfiConverterTypeSignatureUploadRequest.write(value.`signatureRequest`, into: buf)
    }
}


public struct CancelInfo {
    public var `cancelCode`: String
    public var `reason`: String
    public var `cancelledByUs`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`cancelCode`: String, `reason`: String, `cancelledByUs`: Bool) {
        self.`cancelCode` = `cancelCode`
        self.`reason` = `reason`
        self.`cancelledByUs` = `cancelledByUs`
    }
}


extension CancelInfo: Equatable, Hashable {
    public static func ==(lhs: CancelInfo, rhs: CancelInfo) -> Bool {
        if lhs.`cancelCode` != rhs.`cancelCode` {
            return false
        }
        if lhs.`reason` != rhs.`reason` {
            return false
        }
        if lhs.`cancelledByUs` != rhs.`cancelledByUs` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`cancelCode`)
        hasher.combine(`reason`)
        hasher.combine(`cancelledByUs`)
    }
}


fileprivate struct FfiConverterTypeCancelInfo: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> CancelInfo {
        return try CancelInfo(
            `cancelCode`: FfiConverterString.read(from: buf), 
            `reason`: FfiConverterString.read(from: buf), 
            `cancelledByUs`: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: CancelInfo, into buf: Writer) {
        FfiConverterString.write(value.`cancelCode`, into: buf)
        FfiConverterString.write(value.`reason`, into: buf)
        FfiConverterBool.write(value.`cancelledByUs`, into: buf)
    }
}


public struct ConfirmVerificationResult {
    public var `requests`: [OutgoingVerificationRequest]
    public var `signatureRequest`: SignatureUploadRequest?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`requests`: [OutgoingVerificationRequest], `signatureRequest`: SignatureUploadRequest?) {
        self.`requests` = `requests`
        self.`signatureRequest` = `signatureRequest`
    }
}


extension ConfirmVerificationResult: Equatable, Hashable {
    public static func ==(lhs: ConfirmVerificationResult, rhs: ConfirmVerificationResult) -> Bool {
        if lhs.`requests` != rhs.`requests` {
            return false
        }
        if lhs.`signatureRequest` != rhs.`signatureRequest` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`requests`)
        hasher.combine(`signatureRequest`)
    }
}


fileprivate struct FfiConverterTypeConfirmVerificationResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> ConfirmVerificationResult {
        return try ConfirmVerificationResult(
            `requests`: FfiConverterSequenceTypeOutgoingVerificationRequest.read(from: buf), 
            `signatureRequest`: FfiConverterOptionTypeSignatureUploadRequest.read(from: buf)
        )
    }

    fileprivate static func write(_ value: ConfirmVerificationResult, into buf: Writer) {
        FfiConverterSequenceTypeOutgoingVerificationRequest.write(value.`requests`, into: buf)
        FfiConverterOptionTypeSignatureUploadRequest.write(value.`signatureRequest`, into: buf)
    }
}


public struct CrossSigningKeyExport {
    public var `masterKey`: String?
    public var `selfSigningKey`: String?
    public var `userSigningKey`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`masterKey`: String?, `selfSigningKey`: String?, `userSigningKey`: String?) {
        self.`masterKey` = `masterKey`
        self.`selfSigningKey` = `selfSigningKey`
        self.`userSigningKey` = `userSigningKey`
    }
}


extension CrossSigningKeyExport: Equatable, Hashable {
    public static func ==(lhs: CrossSigningKeyExport, rhs: CrossSigningKeyExport) -> Bool {
        if lhs.`masterKey` != rhs.`masterKey` {
            return false
        }
        if lhs.`selfSigningKey` != rhs.`selfSigningKey` {
            return false
        }
        if lhs.`userSigningKey` != rhs.`userSigningKey` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`masterKey`)
        hasher.combine(`selfSigningKey`)
        hasher.combine(`userSigningKey`)
    }
}


fileprivate struct FfiConverterTypeCrossSigningKeyExport: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> CrossSigningKeyExport {
        return try CrossSigningKeyExport(
            `masterKey`: FfiConverterOptionString.read(from: buf), 
            `selfSigningKey`: FfiConverterOptionString.read(from: buf), 
            `userSigningKey`: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: CrossSigningKeyExport, into buf: Writer) {
        FfiConverterOptionString.write(value.`masterKey`, into: buf)
        FfiConverterOptionString.write(value.`selfSigningKey`, into: buf)
        FfiConverterOptionString.write(value.`userSigningKey`, into: buf)
    }
}


public struct CrossSigningStatus {
    public var `hasMaster`: Bool
    public var `hasSelfSigning`: Bool
    public var `hasUserSigning`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`hasMaster`: Bool, `hasSelfSigning`: Bool, `hasUserSigning`: Bool) {
        self.`hasMaster` = `hasMaster`
        self.`hasSelfSigning` = `hasSelfSigning`
        self.`hasUserSigning` = `hasUserSigning`
    }
}


extension CrossSigningStatus: Equatable, Hashable {
    public static func ==(lhs: CrossSigningStatus, rhs: CrossSigningStatus) -> Bool {
        if lhs.`hasMaster` != rhs.`hasMaster` {
            return false
        }
        if lhs.`hasSelfSigning` != rhs.`hasSelfSigning` {
            return false
        }
        if lhs.`hasUserSigning` != rhs.`hasUserSigning` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`hasMaster`)
        hasher.combine(`hasSelfSigning`)
        hasher.combine(`hasUserSigning`)
    }
}


fileprivate struct FfiConverterTypeCrossSigningStatus: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> CrossSigningStatus {
        return try CrossSigningStatus(
            `hasMaster`: FfiConverterBool.read(from: buf), 
            `hasSelfSigning`: FfiConverterBool.read(from: buf), 
            `hasUserSigning`: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: CrossSigningStatus, into buf: Writer) {
        FfiConverterBool.write(value.`hasMaster`, into: buf)
        FfiConverterBool.write(value.`hasSelfSigning`, into: buf)
        FfiConverterBool.write(value.`hasUserSigning`, into: buf)
    }
}


public struct DecryptedEvent {
    public var `clearEvent`: String
    public var `senderCurve25519Key`: String
    public var `claimedEd25519Key`: String?
    public var `forwardingCurve25519Chain`: [String]
    public var `verificationState`: VerificationState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`clearEvent`: String, `senderCurve25519Key`: String, `claimedEd25519Key`: String?, `forwardingCurve25519Chain`: [String], `verificationState`: VerificationState) {
        self.`clearEvent` = `clearEvent`
        self.`senderCurve25519Key` = `senderCurve25519Key`
        self.`claimedEd25519Key` = `claimedEd25519Key`
        self.`forwardingCurve25519Chain` = `forwardingCurve25519Chain`
        self.`verificationState` = `verificationState`
    }
}


extension DecryptedEvent: Equatable, Hashable {
    public static func ==(lhs: DecryptedEvent, rhs: DecryptedEvent) -> Bool {
        if lhs.`clearEvent` != rhs.`clearEvent` {
            return false
        }
        if lhs.`senderCurve25519Key` != rhs.`senderCurve25519Key` {
            return false
        }
        if lhs.`claimedEd25519Key` != rhs.`claimedEd25519Key` {
            return false
        }
        if lhs.`forwardingCurve25519Chain` != rhs.`forwardingCurve25519Chain` {
            return false
        }
        if lhs.`verificationState` != rhs.`verificationState` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`clearEvent`)
        hasher.combine(`senderCurve25519Key`)
        hasher.combine(`claimedEd25519Key`)
        hasher.combine(`forwardingCurve25519Chain`)
        hasher.combine(`verificationState`)
    }
}


fileprivate struct FfiConverterTypeDecryptedEvent: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> DecryptedEvent {
        return try DecryptedEvent(
            `clearEvent`: FfiConverterString.read(from: buf), 
            `senderCurve25519Key`: FfiConverterString.read(from: buf), 
            `claimedEd25519Key`: FfiConverterOptionString.read(from: buf), 
            `forwardingCurve25519Chain`: FfiConverterSequenceString.read(from: buf), 
            `verificationState`: FfiConverterTypeVerificationState.read(from: buf)
        )
    }

    fileprivate static func write(_ value: DecryptedEvent, into buf: Writer) {
        FfiConverterString.write(value.`clearEvent`, into: buf)
        FfiConverterString.write(value.`senderCurve25519Key`, into: buf)
        FfiConverterOptionString.write(value.`claimedEd25519Key`, into: buf)
        FfiConverterSequenceString.write(value.`forwardingCurve25519Chain`, into: buf)
        FfiConverterTypeVerificationState.write(value.`verificationState`, into: buf)
    }
}


public struct Device {
    public var `userId`: String
    public var `deviceId`: String
    public var `keys`: [String: String]
    public var `algorithms`: [String]
    public var `displayName`: String?
    public var `isBlocked`: Bool
    public var `locallyTrusted`: Bool
    public var `crossSigningTrusted`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `deviceId`: String, `keys`: [String: String], `algorithms`: [String], `displayName`: String?, `isBlocked`: Bool, `locallyTrusted`: Bool, `crossSigningTrusted`: Bool) {
        self.`userId` = `userId`
        self.`deviceId` = `deviceId`
        self.`keys` = `keys`
        self.`algorithms` = `algorithms`
        self.`displayName` = `displayName`
        self.`isBlocked` = `isBlocked`
        self.`locallyTrusted` = `locallyTrusted`
        self.`crossSigningTrusted` = `crossSigningTrusted`
    }
}


extension Device: Equatable, Hashable {
    public static func ==(lhs: Device, rhs: Device) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`deviceId` != rhs.`deviceId` {
            return false
        }
        if lhs.`keys` != rhs.`keys` {
            return false
        }
        if lhs.`algorithms` != rhs.`algorithms` {
            return false
        }
        if lhs.`displayName` != rhs.`displayName` {
            return false
        }
        if lhs.`isBlocked` != rhs.`isBlocked` {
            return false
        }
        if lhs.`locallyTrusted` != rhs.`locallyTrusted` {
            return false
        }
        if lhs.`crossSigningTrusted` != rhs.`crossSigningTrusted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`deviceId`)
        hasher.combine(`keys`)
        hasher.combine(`algorithms`)
        hasher.combine(`displayName`)
        hasher.combine(`isBlocked`)
        hasher.combine(`locallyTrusted`)
        hasher.combine(`crossSigningTrusted`)
    }
}


fileprivate struct FfiConverterTypeDevice: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Device {
        return try Device(
            `userId`: FfiConverterString.read(from: buf), 
            `deviceId`: FfiConverterString.read(from: buf), 
            `keys`: FfiConverterDictionaryStringString.read(from: buf), 
            `algorithms`: FfiConverterSequenceString.read(from: buf), 
            `displayName`: FfiConverterOptionString.read(from: buf), 
            `isBlocked`: FfiConverterBool.read(from: buf), 
            `locallyTrusted`: FfiConverterBool.read(from: buf), 
            `crossSigningTrusted`: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Device, into buf: Writer) {
        FfiConverterString.write(value.`userId`, into: buf)
        FfiConverterString.write(value.`deviceId`, into: buf)
        FfiConverterDictionaryStringString.write(value.`keys`, into: buf)
        FfiConverterSequenceString.write(value.`algorithms`, into: buf)
        FfiConverterOptionString.write(value.`displayName`, into: buf)
        FfiConverterBool.write(value.`isBlocked`, into: buf)
        FfiConverterBool.write(value.`locallyTrusted`, into: buf)
        FfiConverterBool.write(value.`crossSigningTrusted`, into: buf)
    }
}


public struct DeviceLists {
    public var `changed`: [String]
    public var `left`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`changed`: [String], `left`: [String]) {
        self.`changed` = `changed`
        self.`left` = `left`
    }
}


extension DeviceLists: Equatable, Hashable {
    public static func ==(lhs: DeviceLists, rhs: DeviceLists) -> Bool {
        if lhs.`changed` != rhs.`changed` {
            return false
        }
        if lhs.`left` != rhs.`left` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`changed`)
        hasher.combine(`left`)
    }
}


fileprivate struct FfiConverterTypeDeviceLists: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> DeviceLists {
        return try DeviceLists(
            `changed`: FfiConverterSequenceString.read(from: buf), 
            `left`: FfiConverterSequenceString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: DeviceLists, into buf: Writer) {
        FfiConverterSequenceString.write(value.`changed`, into: buf)
        FfiConverterSequenceString.write(value.`left`, into: buf)
    }
}


public struct EncryptionSettings {
    public var `algorithm`: EventEncryptionAlgorithm
    public var `rotationPeriod`: UInt64
    public var `rotationPeriodMsgs`: UInt64
    public var `historyVisibility`: HistoryVisibility
    public var `onlyAllowTrustedDevices`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`algorithm`: EventEncryptionAlgorithm, `rotationPeriod`: UInt64, `rotationPeriodMsgs`: UInt64, `historyVisibility`: HistoryVisibility, `onlyAllowTrustedDevices`: Bool) {
        self.`algorithm` = `algorithm`
        self.`rotationPeriod` = `rotationPeriod`
        self.`rotationPeriodMsgs` = `rotationPeriodMsgs`
        self.`historyVisibility` = `historyVisibility`
        self.`onlyAllowTrustedDevices` = `onlyAllowTrustedDevices`
    }
}


extension EncryptionSettings: Equatable, Hashable {
    public static func ==(lhs: EncryptionSettings, rhs: EncryptionSettings) -> Bool {
        if lhs.`algorithm` != rhs.`algorithm` {
            return false
        }
        if lhs.`rotationPeriod` != rhs.`rotationPeriod` {
            return false
        }
        if lhs.`rotationPeriodMsgs` != rhs.`rotationPeriodMsgs` {
            return false
        }
        if lhs.`historyVisibility` != rhs.`historyVisibility` {
            return false
        }
        if lhs.`onlyAllowTrustedDevices` != rhs.`onlyAllowTrustedDevices` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`algorithm`)
        hasher.combine(`rotationPeriod`)
        hasher.combine(`rotationPeriodMsgs`)
        hasher.combine(`historyVisibility`)
        hasher.combine(`onlyAllowTrustedDevices`)
    }
}


fileprivate struct FfiConverterTypeEncryptionSettings: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> EncryptionSettings {
        return try EncryptionSettings(
            `algorithm`: FfiConverterTypeEventEncryptionAlgorithm.read(from: buf), 
            `rotationPeriod`: FfiConverterUInt64.read(from: buf), 
            `rotationPeriodMsgs`: FfiConverterUInt64.read(from: buf), 
            `historyVisibility`: FfiConverterTypeHistoryVisibility.read(from: buf), 
            `onlyAllowTrustedDevices`: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: EncryptionSettings, into buf: Writer) {
        FfiConverterTypeEventEncryptionAlgorithm.write(value.`algorithm`, into: buf)
        FfiConverterUInt64.write(value.`rotationPeriod`, into: buf)
        FfiConverterUInt64.write(value.`rotationPeriodMsgs`, into: buf)
        FfiConverterTypeHistoryVisibility.write(value.`historyVisibility`, into: buf)
        FfiConverterBool.write(value.`onlyAllowTrustedDevices`, into: buf)
    }
}


public struct KeyRequestPair {
    public var `cancellation`: Request?
    public var `keyRequest`: Request

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`cancellation`: Request?, `keyRequest`: Request) {
        self.`cancellation` = `cancellation`
        self.`keyRequest` = `keyRequest`
    }
}


extension KeyRequestPair: Equatable, Hashable {
    public static func ==(lhs: KeyRequestPair, rhs: KeyRequestPair) -> Bool {
        if lhs.`cancellation` != rhs.`cancellation` {
            return false
        }
        if lhs.`keyRequest` != rhs.`keyRequest` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`cancellation`)
        hasher.combine(`keyRequest`)
    }
}


fileprivate struct FfiConverterTypeKeyRequestPair: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> KeyRequestPair {
        return try KeyRequestPair(
            `cancellation`: FfiConverterOptionTypeRequest.read(from: buf), 
            `keyRequest`: FfiConverterTypeRequest.read(from: buf)
        )
    }

    fileprivate static func write(_ value: KeyRequestPair, into buf: Writer) {
        FfiConverterOptionTypeRequest.write(value.`cancellation`, into: buf)
        FfiConverterTypeRequest.write(value.`keyRequest`, into: buf)
    }
}


public struct KeysImportResult {
    public var `imported`: Int64
    public var `total`: Int64
    public var `keys`: [String: [String: [String]]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`imported`: Int64, `total`: Int64, `keys`: [String: [String: [String]]]) {
        self.`imported` = `imported`
        self.`total` = `total`
        self.`keys` = `keys`
    }
}


extension KeysImportResult: Equatable, Hashable {
    public static func ==(lhs: KeysImportResult, rhs: KeysImportResult) -> Bool {
        if lhs.`imported` != rhs.`imported` {
            return false
        }
        if lhs.`total` != rhs.`total` {
            return false
        }
        if lhs.`keys` != rhs.`keys` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`imported`)
        hasher.combine(`total`)
        hasher.combine(`keys`)
    }
}


fileprivate struct FfiConverterTypeKeysImportResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> KeysImportResult {
        return try KeysImportResult(
            `imported`: FfiConverterInt64.read(from: buf), 
            `total`: FfiConverterInt64.read(from: buf), 
            `keys`: FfiConverterDictionaryStringDictionaryStringSequenceString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: KeysImportResult, into buf: Writer) {
        FfiConverterInt64.write(value.`imported`, into: buf)
        FfiConverterInt64.write(value.`total`, into: buf)
        FfiConverterDictionaryStringDictionaryStringSequenceString.write(value.`keys`, into: buf)
    }
}


public struct MegolmV1BackupKey {
    public var `publicKey`: String
    public var `signatures`: [String: [String: String]]
    public var `passphraseInfo`: PassphraseInfo?
    public var `backupAlgorithm`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`publicKey`: String, `signatures`: [String: [String: String]], `passphraseInfo`: PassphraseInfo?, `backupAlgorithm`: String) {
        self.`publicKey` = `publicKey`
        self.`signatures` = `signatures`
        self.`passphraseInfo` = `passphraseInfo`
        self.`backupAlgorithm` = `backupAlgorithm`
    }
}


extension MegolmV1BackupKey: Equatable, Hashable {
    public static func ==(lhs: MegolmV1BackupKey, rhs: MegolmV1BackupKey) -> Bool {
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`signatures` != rhs.`signatures` {
            return false
        }
        if lhs.`passphraseInfo` != rhs.`passphraseInfo` {
            return false
        }
        if lhs.`backupAlgorithm` != rhs.`backupAlgorithm` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`publicKey`)
        hasher.combine(`signatures`)
        hasher.combine(`passphraseInfo`)
        hasher.combine(`backupAlgorithm`)
    }
}


fileprivate struct FfiConverterTypeMegolmV1BackupKey: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> MegolmV1BackupKey {
        return try MegolmV1BackupKey(
            `publicKey`: FfiConverterString.read(from: buf), 
            `signatures`: FfiConverterDictionaryStringDictionaryStringString.read(from: buf), 
            `passphraseInfo`: FfiConverterOptionTypePassphraseInfo.read(from: buf), 
            `backupAlgorithm`: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: MegolmV1BackupKey, into buf: Writer) {
        FfiConverterString.write(value.`publicKey`, into: buf)
        FfiConverterDictionaryStringDictionaryStringString.write(value.`signatures`, into: buf)
        FfiConverterOptionTypePassphraseInfo.write(value.`passphraseInfo`, into: buf)
        FfiConverterString.write(value.`backupAlgorithm`, into: buf)
    }
}


public struct MigrationData {
    public var `account`: PickledAccount
    public var `sessions`: [PickledSession]
    public var `inboundGroupSessions`: [PickledInboundGroupSession]
    public var `backupVersion`: String?
    public var `backupRecoveryKey`: String?
    public var `pickleKey`: [UInt8]
    public var `crossSigning`: CrossSigningKeyExport
    public var `trackedUsers`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`account`: PickledAccount, `sessions`: [PickledSession], `inboundGroupSessions`: [PickledInboundGroupSession], `backupVersion`: String?, `backupRecoveryKey`: String?, `pickleKey`: [UInt8], `crossSigning`: CrossSigningKeyExport, `trackedUsers`: [String]) {
        self.`account` = `account`
        self.`sessions` = `sessions`
        self.`inboundGroupSessions` = `inboundGroupSessions`
        self.`backupVersion` = `backupVersion`
        self.`backupRecoveryKey` = `backupRecoveryKey`
        self.`pickleKey` = `pickleKey`
        self.`crossSigning` = `crossSigning`
        self.`trackedUsers` = `trackedUsers`
    }
}


extension MigrationData: Equatable, Hashable {
    public static func ==(lhs: MigrationData, rhs: MigrationData) -> Bool {
        if lhs.`account` != rhs.`account` {
            return false
        }
        if lhs.`sessions` != rhs.`sessions` {
            return false
        }
        if lhs.`inboundGroupSessions` != rhs.`inboundGroupSessions` {
            return false
        }
        if lhs.`backupVersion` != rhs.`backupVersion` {
            return false
        }
        if lhs.`backupRecoveryKey` != rhs.`backupRecoveryKey` {
            return false
        }
        if lhs.`pickleKey` != rhs.`pickleKey` {
            return false
        }
        if lhs.`crossSigning` != rhs.`crossSigning` {
            return false
        }
        if lhs.`trackedUsers` != rhs.`trackedUsers` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`account`)
        hasher.combine(`sessions`)
        hasher.combine(`inboundGroupSessions`)
        hasher.combine(`backupVersion`)
        hasher.combine(`backupRecoveryKey`)
        hasher.combine(`pickleKey`)
        hasher.combine(`crossSigning`)
        hasher.combine(`trackedUsers`)
    }
}


fileprivate struct FfiConverterTypeMigrationData: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> MigrationData {
        return try MigrationData(
            `account`: FfiConverterTypePickledAccount.read(from: buf), 
            `sessions`: FfiConverterSequenceTypePickledSession.read(from: buf), 
            `inboundGroupSessions`: FfiConverterSequenceTypePickledInboundGroupSession.read(from: buf), 
            `backupVersion`: FfiConverterOptionString.read(from: buf), 
            `backupRecoveryKey`: FfiConverterOptionString.read(from: buf), 
            `pickleKey`: FfiConverterSequenceUInt8.read(from: buf), 
            `crossSigning`: FfiConverterTypeCrossSigningKeyExport.read(from: buf), 
            `trackedUsers`: FfiConverterSequenceString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: MigrationData, into buf: Writer) {
        FfiConverterTypePickledAccount.write(value.`account`, into: buf)
        FfiConverterSequenceTypePickledSession.write(value.`sessions`, into: buf)
        FfiConverterSequenceTypePickledInboundGroupSession.write(value.`inboundGroupSessions`, into: buf)
        FfiConverterOptionString.write(value.`backupVersion`, into: buf)
        FfiConverterOptionString.write(value.`backupRecoveryKey`, into: buf)
        FfiConverterSequenceUInt8.write(value.`pickleKey`, into: buf)
        FfiConverterTypeCrossSigningKeyExport.write(value.`crossSigning`, into: buf)
        FfiConverterSequenceString.write(value.`trackedUsers`, into: buf)
    }
}


public struct PassphraseInfo {
    public var `privateKeySalt`: String
    public var `privateKeyIterations`: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`privateKeySalt`: String, `privateKeyIterations`: Int32) {
        self.`privateKeySalt` = `privateKeySalt`
        self.`privateKeyIterations` = `privateKeyIterations`
    }
}


extension PassphraseInfo: Equatable, Hashable {
    public static func ==(lhs: PassphraseInfo, rhs: PassphraseInfo) -> Bool {
        if lhs.`privateKeySalt` != rhs.`privateKeySalt` {
            return false
        }
        if lhs.`privateKeyIterations` != rhs.`privateKeyIterations` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`privateKeySalt`)
        hasher.combine(`privateKeyIterations`)
    }
}


fileprivate struct FfiConverterTypePassphraseInfo: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> PassphraseInfo {
        return try PassphraseInfo(
            `privateKeySalt`: FfiConverterString.read(from: buf), 
            `privateKeyIterations`: FfiConverterInt32.read(from: buf)
        )
    }

    fileprivate static func write(_ value: PassphraseInfo, into buf: Writer) {
        FfiConverterString.write(value.`privateKeySalt`, into: buf)
        FfiConverterInt32.write(value.`privateKeyIterations`, into: buf)
    }
}


public struct PickledAccount {
    public var `userId`: String
    public var `deviceId`: String
    public var `pickle`: String
    public var `shared`: Bool
    public var `uploadedSignedKeyCount`: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `deviceId`: String, `pickle`: String, `shared`: Bool, `uploadedSignedKeyCount`: Int64) {
        self.`userId` = `userId`
        self.`deviceId` = `deviceId`
        self.`pickle` = `pickle`
        self.`shared` = `shared`
        self.`uploadedSignedKeyCount` = `uploadedSignedKeyCount`
    }
}


extension PickledAccount: Equatable, Hashable {
    public static func ==(lhs: PickledAccount, rhs: PickledAccount) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`deviceId` != rhs.`deviceId` {
            return false
        }
        if lhs.`pickle` != rhs.`pickle` {
            return false
        }
        if lhs.`shared` != rhs.`shared` {
            return false
        }
        if lhs.`uploadedSignedKeyCount` != rhs.`uploadedSignedKeyCount` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`deviceId`)
        hasher.combine(`pickle`)
        hasher.combine(`shared`)
        hasher.combine(`uploadedSignedKeyCount`)
    }
}


fileprivate struct FfiConverterTypePickledAccount: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> PickledAccount {
        return try PickledAccount(
            `userId`: FfiConverterString.read(from: buf), 
            `deviceId`: FfiConverterString.read(from: buf), 
            `pickle`: FfiConverterString.read(from: buf), 
            `shared`: FfiConverterBool.read(from: buf), 
            `uploadedSignedKeyCount`: FfiConverterInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: PickledAccount, into buf: Writer) {
        FfiConverterString.write(value.`userId`, into: buf)
        FfiConverterString.write(value.`deviceId`, into: buf)
        FfiConverterString.write(value.`pickle`, into: buf)
        FfiConverterBool.write(value.`shared`, into: buf)
        FfiConverterInt64.write(value.`uploadedSignedKeyCount`, into: buf)
    }
}


public struct PickledInboundGroupSession {
    public var `pickle`: String
    public var `senderKey`: String
    public var `signingKey`: [String: String]
    public var `roomId`: String
    public var `forwardingChains`: [String]
    public var `imported`: Bool
    public var `backedUp`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`pickle`: String, `senderKey`: String, `signingKey`: [String: String], `roomId`: String, `forwardingChains`: [String], `imported`: Bool, `backedUp`: Bool) {
        self.`pickle` = `pickle`
        self.`senderKey` = `senderKey`
        self.`signingKey` = `signingKey`
        self.`roomId` = `roomId`
        self.`forwardingChains` = `forwardingChains`
        self.`imported` = `imported`
        self.`backedUp` = `backedUp`
    }
}


extension PickledInboundGroupSession: Equatable, Hashable {
    public static func ==(lhs: PickledInboundGroupSession, rhs: PickledInboundGroupSession) -> Bool {
        if lhs.`pickle` != rhs.`pickle` {
            return false
        }
        if lhs.`senderKey` != rhs.`senderKey` {
            return false
        }
        if lhs.`signingKey` != rhs.`signingKey` {
            return false
        }
        if lhs.`roomId` != rhs.`roomId` {
            return false
        }
        if lhs.`forwardingChains` != rhs.`forwardingChains` {
            return false
        }
        if lhs.`imported` != rhs.`imported` {
            return false
        }
        if lhs.`backedUp` != rhs.`backedUp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`pickle`)
        hasher.combine(`senderKey`)
        hasher.combine(`signingKey`)
        hasher.combine(`roomId`)
        hasher.combine(`forwardingChains`)
        hasher.combine(`imported`)
        hasher.combine(`backedUp`)
    }
}


fileprivate struct FfiConverterTypePickledInboundGroupSession: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> PickledInboundGroupSession {
        return try PickledInboundGroupSession(
            `pickle`: FfiConverterString.read(from: buf), 
            `senderKey`: FfiConverterString.read(from: buf), 
            `signingKey`: FfiConverterDictionaryStringString.read(from: buf), 
            `roomId`: FfiConverterString.read(from: buf), 
            `forwardingChains`: FfiConverterSequenceString.read(from: buf), 
            `imported`: FfiConverterBool.read(from: buf), 
            `backedUp`: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: PickledInboundGroupSession, into buf: Writer) {
        FfiConverterString.write(value.`pickle`, into: buf)
        FfiConverterString.write(value.`senderKey`, into: buf)
        FfiConverterDictionaryStringString.write(value.`signingKey`, into: buf)
        FfiConverterString.write(value.`roomId`, into: buf)
        FfiConverterSequenceString.write(value.`forwardingChains`, into: buf)
        FfiConverterBool.write(value.`imported`, into: buf)
        FfiConverterBool.write(value.`backedUp`, into: buf)
    }
}


public struct PickledSession {
    public var `pickle`: String
    public var `senderKey`: String
    public var `createdUsingFallbackKey`: Bool
    public var `creationTime`: String
    public var `lastUseTime`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`pickle`: String, `senderKey`: String, `createdUsingFallbackKey`: Bool, `creationTime`: String, `lastUseTime`: String) {
        self.`pickle` = `pickle`
        self.`senderKey` = `senderKey`
        self.`createdUsingFallbackKey` = `createdUsingFallbackKey`
        self.`creationTime` = `creationTime`
        self.`lastUseTime` = `lastUseTime`
    }
}


extension PickledSession: Equatable, Hashable {
    public static func ==(lhs: PickledSession, rhs: PickledSession) -> Bool {
        if lhs.`pickle` != rhs.`pickle` {
            return false
        }
        if lhs.`senderKey` != rhs.`senderKey` {
            return false
        }
        if lhs.`createdUsingFallbackKey` != rhs.`createdUsingFallbackKey` {
            return false
        }
        if lhs.`creationTime` != rhs.`creationTime` {
            return false
        }
        if lhs.`lastUseTime` != rhs.`lastUseTime` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`pickle`)
        hasher.combine(`senderKey`)
        hasher.combine(`createdUsingFallbackKey`)
        hasher.combine(`creationTime`)
        hasher.combine(`lastUseTime`)
    }
}


fileprivate struct FfiConverterTypePickledSession: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> PickledSession {
        return try PickledSession(
            `pickle`: FfiConverterString.read(from: buf), 
            `senderKey`: FfiConverterString.read(from: buf), 
            `createdUsingFallbackKey`: FfiConverterBool.read(from: buf), 
            `creationTime`: FfiConverterString.read(from: buf), 
            `lastUseTime`: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: PickledSession, into buf: Writer) {
        FfiConverterString.write(value.`pickle`, into: buf)
        FfiConverterString.write(value.`senderKey`, into: buf)
        FfiConverterBool.write(value.`createdUsingFallbackKey`, into: buf)
        FfiConverterString.write(value.`creationTime`, into: buf)
        FfiConverterString.write(value.`lastUseTime`, into: buf)
    }
}


public struct QrCode {
    public var `otherUserId`: String
    public var `otherDeviceId`: String
    public var `flowId`: String
    public var `roomId`: String?
    public var `weStarted`: Bool
    public var `otherSideScanned`: Bool
    public var `hasBeenConfirmed`: Bool
    public var `reciprocated`: Bool
    public var `isDone`: Bool
    public var `isCancelled`: Bool
    public var `cancelInfo`: CancelInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`otherUserId`: String, `otherDeviceId`: String, `flowId`: String, `roomId`: String?, `weStarted`: Bool, `otherSideScanned`: Bool, `hasBeenConfirmed`: Bool, `reciprocated`: Bool, `isDone`: Bool, `isCancelled`: Bool, `cancelInfo`: CancelInfo?) {
        self.`otherUserId` = `otherUserId`
        self.`otherDeviceId` = `otherDeviceId`
        self.`flowId` = `flowId`
        self.`roomId` = `roomId`
        self.`weStarted` = `weStarted`
        self.`otherSideScanned` = `otherSideScanned`
        self.`hasBeenConfirmed` = `hasBeenConfirmed`
        self.`reciprocated` = `reciprocated`
        self.`isDone` = `isDone`
        self.`isCancelled` = `isCancelled`
        self.`cancelInfo` = `cancelInfo`
    }
}


extension QrCode: Equatable, Hashable {
    public static func ==(lhs: QrCode, rhs: QrCode) -> Bool {
        if lhs.`otherUserId` != rhs.`otherUserId` {
            return false
        }
        if lhs.`otherDeviceId` != rhs.`otherDeviceId` {
            return false
        }
        if lhs.`flowId` != rhs.`flowId` {
            return false
        }
        if lhs.`roomId` != rhs.`roomId` {
            return false
        }
        if lhs.`weStarted` != rhs.`weStarted` {
            return false
        }
        if lhs.`otherSideScanned` != rhs.`otherSideScanned` {
            return false
        }
        if lhs.`hasBeenConfirmed` != rhs.`hasBeenConfirmed` {
            return false
        }
        if lhs.`reciprocated` != rhs.`reciprocated` {
            return false
        }
        if lhs.`isDone` != rhs.`isDone` {
            return false
        }
        if lhs.`isCancelled` != rhs.`isCancelled` {
            return false
        }
        if lhs.`cancelInfo` != rhs.`cancelInfo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`otherUserId`)
        hasher.combine(`otherDeviceId`)
        hasher.combine(`flowId`)
        hasher.combine(`roomId`)
        hasher.combine(`weStarted`)
        hasher.combine(`otherSideScanned`)
        hasher.combine(`hasBeenConfirmed`)
        hasher.combine(`reciprocated`)
        hasher.combine(`isDone`)
        hasher.combine(`isCancelled`)
        hasher.combine(`cancelInfo`)
    }
}


fileprivate struct FfiConverterTypeQrCode: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> QrCode {
        return try QrCode(
            `otherUserId`: FfiConverterString.read(from: buf), 
            `otherDeviceId`: FfiConverterString.read(from: buf), 
            `flowId`: FfiConverterString.read(from: buf), 
            `roomId`: FfiConverterOptionString.read(from: buf), 
            `weStarted`: FfiConverterBool.read(from: buf), 
            `otherSideScanned`: FfiConverterBool.read(from: buf), 
            `hasBeenConfirmed`: FfiConverterBool.read(from: buf), 
            `reciprocated`: FfiConverterBool.read(from: buf), 
            `isDone`: FfiConverterBool.read(from: buf), 
            `isCancelled`: FfiConverterBool.read(from: buf), 
            `cancelInfo`: FfiConverterOptionTypeCancelInfo.read(from: buf)
        )
    }

    fileprivate static func write(_ value: QrCode, into buf: Writer) {
        FfiConverterString.write(value.`otherUserId`, into: buf)
        FfiConverterString.write(value.`otherDeviceId`, into: buf)
        FfiConverterString.write(value.`flowId`, into: buf)
        FfiConverterOptionString.write(value.`roomId`, into: buf)
        FfiConverterBool.write(value.`weStarted`, into: buf)
        FfiConverterBool.write(value.`otherSideScanned`, into: buf)
        FfiConverterBool.write(value.`hasBeenConfirmed`, into: buf)
        FfiConverterBool.write(value.`reciprocated`, into: buf)
        FfiConverterBool.write(value.`isDone`, into: buf)
        FfiConverterBool.write(value.`isCancelled`, into: buf)
        FfiConverterOptionTypeCancelInfo.write(value.`cancelInfo`, into: buf)
    }
}


public struct RequestVerificationResult {
    public var `verification`: VerificationRequest
    public var `request`: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`verification`: VerificationRequest, `request`: OutgoingVerificationRequest) {
        self.`verification` = `verification`
        self.`request` = `request`
    }
}


extension RequestVerificationResult: Equatable, Hashable {
    public static func ==(lhs: RequestVerificationResult, rhs: RequestVerificationResult) -> Bool {
        if lhs.`verification` != rhs.`verification` {
            return false
        }
        if lhs.`request` != rhs.`request` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`verification`)
        hasher.combine(`request`)
    }
}


fileprivate struct FfiConverterTypeRequestVerificationResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> RequestVerificationResult {
        return try RequestVerificationResult(
            `verification`: FfiConverterTypeVerificationRequest.read(from: buf), 
            `request`: FfiConverterTypeOutgoingVerificationRequest.read(from: buf)
        )
    }

    fileprivate static func write(_ value: RequestVerificationResult, into buf: Writer) {
        FfiConverterTypeVerificationRequest.write(value.`verification`, into: buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.`request`, into: buf)
    }
}


public struct RoomKeyCounts {
    public var `total`: Int64
    public var `backedUp`: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`total`: Int64, `backedUp`: Int64) {
        self.`total` = `total`
        self.`backedUp` = `backedUp`
    }
}


extension RoomKeyCounts: Equatable, Hashable {
    public static func ==(lhs: RoomKeyCounts, rhs: RoomKeyCounts) -> Bool {
        if lhs.`total` != rhs.`total` {
            return false
        }
        if lhs.`backedUp` != rhs.`backedUp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`total`)
        hasher.combine(`backedUp`)
    }
}


fileprivate struct FfiConverterTypeRoomKeyCounts: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> RoomKeyCounts {
        return try RoomKeyCounts(
            `total`: FfiConverterInt64.read(from: buf), 
            `backedUp`: FfiConverterInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: RoomKeyCounts, into buf: Writer) {
        FfiConverterInt64.write(value.`total`, into: buf)
        FfiConverterInt64.write(value.`backedUp`, into: buf)
    }
}


public struct Sas {
    public var `otherUserId`: String
    public var `otherDeviceId`: String
    public var `flowId`: String
    public var `roomId`: String?
    public var `weStarted`: Bool
    public var `hasBeenAccepted`: Bool
    public var `canBePresented`: Bool
    public var `supportsEmoji`: Bool
    public var `haveWeConfirmed`: Bool
    public var `isDone`: Bool
    public var `isCancelled`: Bool
    public var `cancelInfo`: CancelInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`otherUserId`: String, `otherDeviceId`: String, `flowId`: String, `roomId`: String?, `weStarted`: Bool, `hasBeenAccepted`: Bool, `canBePresented`: Bool, `supportsEmoji`: Bool, `haveWeConfirmed`: Bool, `isDone`: Bool, `isCancelled`: Bool, `cancelInfo`: CancelInfo?) {
        self.`otherUserId` = `otherUserId`
        self.`otherDeviceId` = `otherDeviceId`
        self.`flowId` = `flowId`
        self.`roomId` = `roomId`
        self.`weStarted` = `weStarted`
        self.`hasBeenAccepted` = `hasBeenAccepted`
        self.`canBePresented` = `canBePresented`
        self.`supportsEmoji` = `supportsEmoji`
        self.`haveWeConfirmed` = `haveWeConfirmed`
        self.`isDone` = `isDone`
        self.`isCancelled` = `isCancelled`
        self.`cancelInfo` = `cancelInfo`
    }
}


extension Sas: Equatable, Hashable {
    public static func ==(lhs: Sas, rhs: Sas) -> Bool {
        if lhs.`otherUserId` != rhs.`otherUserId` {
            return false
        }
        if lhs.`otherDeviceId` != rhs.`otherDeviceId` {
            return false
        }
        if lhs.`flowId` != rhs.`flowId` {
            return false
        }
        if lhs.`roomId` != rhs.`roomId` {
            return false
        }
        if lhs.`weStarted` != rhs.`weStarted` {
            return false
        }
        if lhs.`hasBeenAccepted` != rhs.`hasBeenAccepted` {
            return false
        }
        if lhs.`canBePresented` != rhs.`canBePresented` {
            return false
        }
        if lhs.`supportsEmoji` != rhs.`supportsEmoji` {
            return false
        }
        if lhs.`haveWeConfirmed` != rhs.`haveWeConfirmed` {
            return false
        }
        if lhs.`isDone` != rhs.`isDone` {
            return false
        }
        if lhs.`isCancelled` != rhs.`isCancelled` {
            return false
        }
        if lhs.`cancelInfo` != rhs.`cancelInfo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`otherUserId`)
        hasher.combine(`otherDeviceId`)
        hasher.combine(`flowId`)
        hasher.combine(`roomId`)
        hasher.combine(`weStarted`)
        hasher.combine(`hasBeenAccepted`)
        hasher.combine(`canBePresented`)
        hasher.combine(`supportsEmoji`)
        hasher.combine(`haveWeConfirmed`)
        hasher.combine(`isDone`)
        hasher.combine(`isCancelled`)
        hasher.combine(`cancelInfo`)
    }
}


fileprivate struct FfiConverterTypeSas: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Sas {
        return try Sas(
            `otherUserId`: FfiConverterString.read(from: buf), 
            `otherDeviceId`: FfiConverterString.read(from: buf), 
            `flowId`: FfiConverterString.read(from: buf), 
            `roomId`: FfiConverterOptionString.read(from: buf), 
            `weStarted`: FfiConverterBool.read(from: buf), 
            `hasBeenAccepted`: FfiConverterBool.read(from: buf), 
            `canBePresented`: FfiConverterBool.read(from: buf), 
            `supportsEmoji`: FfiConverterBool.read(from: buf), 
            `haveWeConfirmed`: FfiConverterBool.read(from: buf), 
            `isDone`: FfiConverterBool.read(from: buf), 
            `isCancelled`: FfiConverterBool.read(from: buf), 
            `cancelInfo`: FfiConverterOptionTypeCancelInfo.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Sas, into buf: Writer) {
        FfiConverterString.write(value.`otherUserId`, into: buf)
        FfiConverterString.write(value.`otherDeviceId`, into: buf)
        FfiConverterString.write(value.`flowId`, into: buf)
        FfiConverterOptionString.write(value.`roomId`, into: buf)
        FfiConverterBool.write(value.`weStarted`, into: buf)
        FfiConverterBool.write(value.`hasBeenAccepted`, into: buf)
        FfiConverterBool.write(value.`canBePresented`, into: buf)
        FfiConverterBool.write(value.`supportsEmoji`, into: buf)
        FfiConverterBool.write(value.`haveWeConfirmed`, into: buf)
        FfiConverterBool.write(value.`isDone`, into: buf)
        FfiConverterBool.write(value.`isCancelled`, into: buf)
        FfiConverterOptionTypeCancelInfo.write(value.`cancelInfo`, into: buf)
    }
}


public struct ScanResult {
    public var `qr`: QrCode
    public var `request`: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`qr`: QrCode, `request`: OutgoingVerificationRequest) {
        self.`qr` = `qr`
        self.`request` = `request`
    }
}


extension ScanResult: Equatable, Hashable {
    public static func ==(lhs: ScanResult, rhs: ScanResult) -> Bool {
        if lhs.`qr` != rhs.`qr` {
            return false
        }
        if lhs.`request` != rhs.`request` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`qr`)
        hasher.combine(`request`)
    }
}


fileprivate struct FfiConverterTypeScanResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> ScanResult {
        return try ScanResult(
            `qr`: FfiConverterTypeQrCode.read(from: buf), 
            `request`: FfiConverterTypeOutgoingVerificationRequest.read(from: buf)
        )
    }

    fileprivate static func write(_ value: ScanResult, into buf: Writer) {
        FfiConverterTypeQrCode.write(value.`qr`, into: buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.`request`, into: buf)
    }
}


public struct SignatureUploadRequest {
    public var `body`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String) {
        self.`body` = `body`
    }
}


extension SignatureUploadRequest: Equatable, Hashable {
    public static func ==(lhs: SignatureUploadRequest, rhs: SignatureUploadRequest) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
    }
}


fileprivate struct FfiConverterTypeSignatureUploadRequest: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> SignatureUploadRequest {
        return try SignatureUploadRequest(
            `body`: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: SignatureUploadRequest, into buf: Writer) {
        FfiConverterString.write(value.`body`, into: buf)
    }
}


public struct StartSasResult {
    public var `sas`: Sas
    public var `request`: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`sas`: Sas, `request`: OutgoingVerificationRequest) {
        self.`sas` = `sas`
        self.`request` = `request`
    }
}


extension StartSasResult: Equatable, Hashable {
    public static func ==(lhs: StartSasResult, rhs: StartSasResult) -> Bool {
        if lhs.`sas` != rhs.`sas` {
            return false
        }
        if lhs.`request` != rhs.`request` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`sas`)
        hasher.combine(`request`)
    }
}


fileprivate struct FfiConverterTypeStartSasResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> StartSasResult {
        return try StartSasResult(
            `sas`: FfiConverterTypeSas.read(from: buf), 
            `request`: FfiConverterTypeOutgoingVerificationRequest.read(from: buf)
        )
    }

    fileprivate static func write(_ value: StartSasResult, into buf: Writer) {
        FfiConverterTypeSas.write(value.`sas`, into: buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.`request`, into: buf)
    }
}


public struct UploadSigningKeysRequest {
    public var `masterKey`: String
    public var `selfSigningKey`: String
    public var `userSigningKey`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`masterKey`: String, `selfSigningKey`: String, `userSigningKey`: String) {
        self.`masterKey` = `masterKey`
        self.`selfSigningKey` = `selfSigningKey`
        self.`userSigningKey` = `userSigningKey`
    }
}


extension UploadSigningKeysRequest: Equatable, Hashable {
    public static func ==(lhs: UploadSigningKeysRequest, rhs: UploadSigningKeysRequest) -> Bool {
        if lhs.`masterKey` != rhs.`masterKey` {
            return false
        }
        if lhs.`selfSigningKey` != rhs.`selfSigningKey` {
            return false
        }
        if lhs.`userSigningKey` != rhs.`userSigningKey` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`masterKey`)
        hasher.combine(`selfSigningKey`)
        hasher.combine(`userSigningKey`)
    }
}


fileprivate struct FfiConverterTypeUploadSigningKeysRequest: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> UploadSigningKeysRequest {
        return try UploadSigningKeysRequest(
            `masterKey`: FfiConverterString.read(from: buf), 
            `selfSigningKey`: FfiConverterString.read(from: buf), 
            `userSigningKey`: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: UploadSigningKeysRequest, into buf: Writer) {
        FfiConverterString.write(value.`masterKey`, into: buf)
        FfiConverterString.write(value.`selfSigningKey`, into: buf)
        FfiConverterString.write(value.`userSigningKey`, into: buf)
    }
}


public struct VerificationRequest {
    public var `otherUserId`: String
    public var `otherDeviceId`: String?
    public var `flowId`: String
    public var `roomId`: String?
    public var `weStarted`: Bool
    public var `isReady`: Bool
    public var `isPassive`: Bool
    public var `isDone`: Bool
    public var `isCancelled`: Bool
    public var `cancelInfo`: CancelInfo?
    public var `theirMethods`: [String]?
    public var `ourMethods`: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`otherUserId`: String, `otherDeviceId`: String?, `flowId`: String, `roomId`: String?, `weStarted`: Bool, `isReady`: Bool, `isPassive`: Bool, `isDone`: Bool, `isCancelled`: Bool, `cancelInfo`: CancelInfo?, `theirMethods`: [String]?, `ourMethods`: [String]?) {
        self.`otherUserId` = `otherUserId`
        self.`otherDeviceId` = `otherDeviceId`
        self.`flowId` = `flowId`
        self.`roomId` = `roomId`
        self.`weStarted` = `weStarted`
        self.`isReady` = `isReady`
        self.`isPassive` = `isPassive`
        self.`isDone` = `isDone`
        self.`isCancelled` = `isCancelled`
        self.`cancelInfo` = `cancelInfo`
        self.`theirMethods` = `theirMethods`
        self.`ourMethods` = `ourMethods`
    }
}


extension VerificationRequest: Equatable, Hashable {
    public static func ==(lhs: VerificationRequest, rhs: VerificationRequest) -> Bool {
        if lhs.`otherUserId` != rhs.`otherUserId` {
            return false
        }
        if lhs.`otherDeviceId` != rhs.`otherDeviceId` {
            return false
        }
        if lhs.`flowId` != rhs.`flowId` {
            return false
        }
        if lhs.`roomId` != rhs.`roomId` {
            return false
        }
        if lhs.`weStarted` != rhs.`weStarted` {
            return false
        }
        if lhs.`isReady` != rhs.`isReady` {
            return false
        }
        if lhs.`isPassive` != rhs.`isPassive` {
            return false
        }
        if lhs.`isDone` != rhs.`isDone` {
            return false
        }
        if lhs.`isCancelled` != rhs.`isCancelled` {
            return false
        }
        if lhs.`cancelInfo` != rhs.`cancelInfo` {
            return false
        }
        if lhs.`theirMethods` != rhs.`theirMethods` {
            return false
        }
        if lhs.`ourMethods` != rhs.`ourMethods` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`otherUserId`)
        hasher.combine(`otherDeviceId`)
        hasher.combine(`flowId`)
        hasher.combine(`roomId`)
        hasher.combine(`weStarted`)
        hasher.combine(`isReady`)
        hasher.combine(`isPassive`)
        hasher.combine(`isDone`)
        hasher.combine(`isCancelled`)
        hasher.combine(`cancelInfo`)
        hasher.combine(`theirMethods`)
        hasher.combine(`ourMethods`)
    }
}


fileprivate struct FfiConverterTypeVerificationRequest: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> VerificationRequest {
        return try VerificationRequest(
            `otherUserId`: FfiConverterString.read(from: buf), 
            `otherDeviceId`: FfiConverterOptionString.read(from: buf), 
            `flowId`: FfiConverterString.read(from: buf), 
            `roomId`: FfiConverterOptionString.read(from: buf), 
            `weStarted`: FfiConverterBool.read(from: buf), 
            `isReady`: FfiConverterBool.read(from: buf), 
            `isPassive`: FfiConverterBool.read(from: buf), 
            `isDone`: FfiConverterBool.read(from: buf), 
            `isCancelled`: FfiConverterBool.read(from: buf), 
            `cancelInfo`: FfiConverterOptionTypeCancelInfo.read(from: buf), 
            `theirMethods`: FfiConverterOptionSequenceString.read(from: buf), 
            `ourMethods`: FfiConverterOptionSequenceString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: VerificationRequest, into buf: Writer) {
        FfiConverterString.write(value.`otherUserId`, into: buf)
        FfiConverterOptionString.write(value.`otherDeviceId`, into: buf)
        FfiConverterString.write(value.`flowId`, into: buf)
        FfiConverterOptionString.write(value.`roomId`, into: buf)
        FfiConverterBool.write(value.`weStarted`, into: buf)
        FfiConverterBool.write(value.`isReady`, into: buf)
        FfiConverterBool.write(value.`isPassive`, into: buf)
        FfiConverterBool.write(value.`isDone`, into: buf)
        FfiConverterBool.write(value.`isCancelled`, into: buf)
        FfiConverterOptionTypeCancelInfo.write(value.`cancelInfo`, into: buf)
        FfiConverterOptionSequenceString.write(value.`theirMethods`, into: buf)
        FfiConverterOptionSequenceString.write(value.`ourMethods`, into: buf)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventEncryptionAlgorithm {
    
    case `olmV1Curve25519AesSha2`
    case `megolmV1AesSha2`
}

fileprivate struct FfiConverterTypeEventEncryptionAlgorithm: FfiConverterRustBuffer {
    typealias SwiftType = EventEncryptionAlgorithm

    static func read(from buf: Reader) throws -> EventEncryptionAlgorithm {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`olmV1Curve25519AesSha2`
        
        case 2: return .`megolmV1AesSha2`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: EventEncryptionAlgorithm, into buf: Writer) {
        switch value {
        
        
        case .`olmV1Curve25519AesSha2`:
            buf.writeInt(Int32(1))
        
        
        case .`megolmV1AesSha2`:
            buf.writeInt(Int32(2))
        
        }
    }
}


extension EventEncryptionAlgorithm: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum HistoryVisibility {
    
    case `invited`
    case `joined`
    case `shared`
    case `worldReadable`
}

fileprivate struct FfiConverterTypeHistoryVisibility: FfiConverterRustBuffer {
    typealias SwiftType = HistoryVisibility

    static func read(from buf: Reader) throws -> HistoryVisibility {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`invited`
        
        case 2: return .`joined`
        
        case 3: return .`shared`
        
        case 4: return .`worldReadable`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: HistoryVisibility, into buf: Writer) {
        switch value {
        
        
        case .`invited`:
            buf.writeInt(Int32(1))
        
        
        case .`joined`:
            buf.writeInt(Int32(2))
        
        
        case .`shared`:
            buf.writeInt(Int32(3))
        
        
        case .`worldReadable`:
            buf.writeInt(Int32(4))
        
        }
    }
}


extension HistoryVisibility: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LocalTrust {
    
    case `verified`
    case `blackListed`
    case `ignored`
    case `unset`
}

fileprivate struct FfiConverterTypeLocalTrust: FfiConverterRustBuffer {
    typealias SwiftType = LocalTrust

    static func read(from buf: Reader) throws -> LocalTrust {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`verified`
        
        case 2: return .`blackListed`
        
        case 3: return .`ignored`
        
        case 4: return .`unset`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: LocalTrust, into buf: Writer) {
        switch value {
        
        
        case .`verified`:
            buf.writeInt(Int32(1))
        
        
        case .`blackListed`:
            buf.writeInt(Int32(2))
        
        
        case .`ignored`:
            buf.writeInt(Int32(3))
        
        
        case .`unset`:
            buf.writeInt(Int32(4))
        
        }
    }
}


extension LocalTrust: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OutgoingVerificationRequest {
    
    case `toDevice`(`requestId`: String, `eventType`: String, `body`: String)
    case `inRoom`(`requestId`: String, `roomId`: String, `eventType`: String, `content`: String)
}

fileprivate struct FfiConverterTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingVerificationRequest

    static func read(from buf: Reader) throws -> OutgoingVerificationRequest {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`toDevice`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `eventType`: try FfiConverterString.read(from: buf), 
            `body`: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .`inRoom`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `roomId`: try FfiConverterString.read(from: buf), 
            `eventType`: try FfiConverterString.read(from: buf), 
            `content`: try FfiConverterString.read(from: buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: OutgoingVerificationRequest, into buf: Writer) {
        switch value {
        
        
        case let .`toDevice`(`requestId`,`eventType`,`body`):
            buf.writeInt(Int32(1))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterString.write(`eventType`, into: buf)
            FfiConverterString.write(`body`, into: buf)
            
        
        case let .`inRoom`(`requestId`,`roomId`,`eventType`,`content`):
            buf.writeInt(Int32(2))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterString.write(`roomId`, into: buf)
            FfiConverterString.write(`eventType`, into: buf)
            FfiConverterString.write(`content`, into: buf)
            
        }
    }
}


extension OutgoingVerificationRequest: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Request {
    
    case `toDevice`(`requestId`: String, `eventType`: String, `body`: String)
    case `keysUpload`(`requestId`: String, `body`: String)
    case `keysQuery`(`requestId`: String, `users`: [String])
    case `keysClaim`(`requestId`: String, `oneTimeKeys`: [String: [String: String]])
    case `keysBackup`(`requestId`: String, `version`: String, `rooms`: String)
    case `roomMessage`(`requestId`: String, `roomId`: String, `eventType`: String, `content`: String)
    case `signatureUpload`(`requestId`: String, `body`: String)
}

fileprivate struct FfiConverterTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = Request

    static func read(from buf: Reader) throws -> Request {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`toDevice`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `eventType`: try FfiConverterString.read(from: buf), 
            `body`: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .`keysUpload`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `body`: try FfiConverterString.read(from: buf)
        )
        
        case 3: return .`keysQuery`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `users`: try FfiConverterSequenceString.read(from: buf)
        )
        
        case 4: return .`keysClaim`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `oneTimeKeys`: try FfiConverterDictionaryStringDictionaryStringString.read(from: buf)
        )
        
        case 5: return .`keysBackup`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `version`: try FfiConverterString.read(from: buf), 
            `rooms`: try FfiConverterString.read(from: buf)
        )
        
        case 6: return .`roomMessage`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `roomId`: try FfiConverterString.read(from: buf), 
            `eventType`: try FfiConverterString.read(from: buf), 
            `content`: try FfiConverterString.read(from: buf)
        )
        
        case 7: return .`signatureUpload`(
            `requestId`: try FfiConverterString.read(from: buf), 
            `body`: try FfiConverterString.read(from: buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: Request, into buf: Writer) {
        switch value {
        
        
        case let .`toDevice`(`requestId`,`eventType`,`body`):
            buf.writeInt(Int32(1))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterString.write(`eventType`, into: buf)
            FfiConverterString.write(`body`, into: buf)
            
        
        case let .`keysUpload`(`requestId`,`body`):
            buf.writeInt(Int32(2))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterString.write(`body`, into: buf)
            
        
        case let .`keysQuery`(`requestId`,`users`):
            buf.writeInt(Int32(3))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterSequenceString.write(`users`, into: buf)
            
        
        case let .`keysClaim`(`requestId`,`oneTimeKeys`):
            buf.writeInt(Int32(4))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterDictionaryStringDictionaryStringString.write(`oneTimeKeys`, into: buf)
            
        
        case let .`keysBackup`(`requestId`,`version`,`rooms`):
            buf.writeInt(Int32(5))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterString.write(`version`, into: buf)
            FfiConverterString.write(`rooms`, into: buf)
            
        
        case let .`roomMessage`(`requestId`,`roomId`,`eventType`,`content`):
            buf.writeInt(Int32(6))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterString.write(`roomId`, into: buf)
            FfiConverterString.write(`eventType`, into: buf)
            FfiConverterString.write(`content`, into: buf)
            
        
        case let .`signatureUpload`(`requestId`,`body`):
            buf.writeInt(Int32(7))
            FfiConverterString.write(`requestId`, into: buf)
            FfiConverterString.write(`body`, into: buf)
            
        }
    }
}


extension Request: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RequestType {
    
    case `keysQuery`
    case `keysClaim`
    case `keysUpload`
    case `toDevice`
    case `signatureUpload`
    case `keysBackup`
    case `roomMessage`
}

fileprivate struct FfiConverterTypeRequestType: FfiConverterRustBuffer {
    typealias SwiftType = RequestType

    static func read(from buf: Reader) throws -> RequestType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`keysQuery`
        
        case 2: return .`keysClaim`
        
        case 3: return .`keysUpload`
        
        case 4: return .`toDevice`
        
        case 5: return .`signatureUpload`
        
        case 6: return .`keysBackup`
        
        case 7: return .`roomMessage`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: RequestType, into buf: Writer) {
        switch value {
        
        
        case .`keysQuery`:
            buf.writeInt(Int32(1))
        
        
        case .`keysClaim`:
            buf.writeInt(Int32(2))
        
        
        case .`keysUpload`:
            buf.writeInt(Int32(3))
        
        
        case .`toDevice`:
            buf.writeInt(Int32(4))
        
        
        case .`signatureUpload`:
            buf.writeInt(Int32(5))
        
        
        case .`keysBackup`:
            buf.writeInt(Int32(6))
        
        
        case .`roomMessage`:
            buf.writeInt(Int32(7))
        
        }
    }
}


extension RequestType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UserIdentity {
    
    case `own`(`userId`: String, `trustsOurOwnDevice`: Bool, `masterKey`: String, `selfSigningKey`: String, `userSigningKey`: String)
    case `other`(`userId`: String, `masterKey`: String, `selfSigningKey`: String)
}

fileprivate struct FfiConverterTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity

    static func read(from buf: Reader) throws -> UserIdentity {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`own`(
            `userId`: try FfiConverterString.read(from: buf), 
            `trustsOurOwnDevice`: try FfiConverterBool.read(from: buf), 
            `masterKey`: try FfiConverterString.read(from: buf), 
            `selfSigningKey`: try FfiConverterString.read(from: buf), 
            `userSigningKey`: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .`other`(
            `userId`: try FfiConverterString.read(from: buf), 
            `masterKey`: try FfiConverterString.read(from: buf), 
            `selfSigningKey`: try FfiConverterString.read(from: buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: UserIdentity, into buf: Writer) {
        switch value {
        
        
        case let .`own`(`userId`,`trustsOurOwnDevice`,`masterKey`,`selfSigningKey`,`userSigningKey`):
            buf.writeInt(Int32(1))
            FfiConverterString.write(`userId`, into: buf)
            FfiConverterBool.write(`trustsOurOwnDevice`, into: buf)
            FfiConverterString.write(`masterKey`, into: buf)
            FfiConverterString.write(`selfSigningKey`, into: buf)
            FfiConverterString.write(`userSigningKey`, into: buf)
            
        
        case let .`other`(`userId`,`masterKey`,`selfSigningKey`):
            buf.writeInt(Int32(2))
            FfiConverterString.write(`userId`, into: buf)
            FfiConverterString.write(`masterKey`, into: buf)
            FfiConverterString.write(`selfSigningKey`, into: buf)
            
        }
    }
}


extension UserIdentity: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Verification {
    
    case `sasV1`(`sas`: Sas)
    case `qrCodeV1`(`qrcode`: QrCode)
}

fileprivate struct FfiConverterTypeVerification: FfiConverterRustBuffer {
    typealias SwiftType = Verification

    static func read(from buf: Reader) throws -> Verification {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`sasV1`(
            `sas`: try FfiConverterTypeSas.read(from: buf)
        )
        
        case 2: return .`qrCodeV1`(
            `qrcode`: try FfiConverterTypeQrCode.read(from: buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: Verification, into buf: Writer) {
        switch value {
        
        
        case let .`sasV1`(`sas`):
            buf.writeInt(Int32(1))
            FfiConverterTypeSas.write(`sas`, into: buf)
            
        
        case let .`qrCodeV1`(`qrcode`):
            buf.writeInt(Int32(2))
            FfiConverterTypeQrCode.write(`qrcode`, into: buf)
            
        }
    }
}


extension Verification: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VerificationState {
    
    case `trusted`
    case `untrusted`
    case `unknownDevice`
}

fileprivate struct FfiConverterTypeVerificationState: FfiConverterRustBuffer {
    typealias SwiftType = VerificationState

    static func read(from buf: Reader) throws -> VerificationState {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`trusted`
        
        case 2: return .`untrusted`
        
        case 3: return .`unknownDevice`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: VerificationState, into buf: Writer) {
        switch value {
        
        
        case .`trusted`:
            buf.writeInt(Int32(1))
        
        
        case .`untrusted`:
            buf.writeInt(Int32(2))
        
        
        case .`unknownDevice`:
            buf.writeInt(Int32(3))
        
        }
    }
}


extension VerificationState: Equatable, Hashable {}



public enum CryptoStoreError {

    
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case OlmError(message: String)
    
    // Simple error enums only carry a message
    case Serialization(message: String)
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case InvalidUserId(message: String)
    
}

fileprivate struct FfiConverterTypeCryptoStoreError: FfiConverterRustBuffer {
    typealias SwiftType = CryptoStoreError

    static func read(from buf: Reader) throws -> CryptoStoreError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .CryptoStore(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .OlmError(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 3: return .Serialization(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 4: return .Identifier(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 5: return .InvalidUserId(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: CryptoStoreError, into buf: Writer) {
        switch value {

        

        
        case let .CryptoStore(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .OlmError(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)
        case let .Serialization(message):
            buf.writeInt(Int32(3))
            FfiConverterString.write(message, into: buf)
        case let .Identifier(message):
            buf.writeInt(Int32(4))
            FfiConverterString.write(message, into: buf)
        case let .InvalidUserId(message):
            buf.writeInt(Int32(5))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension CryptoStoreError: Equatable, Hashable {}

extension CryptoStoreError: Error { }


public enum DecodeError {

    
    
    // Simple error enums only carry a message
    case Decode(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
}

fileprivate struct FfiConverterTypeDecodeError: FfiConverterRustBuffer {
    typealias SwiftType = DecodeError

    static func read(from buf: Reader) throws -> DecodeError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Decode(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: DecodeError, into buf: Writer) {
        switch value {

        

        
        case let .Decode(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .CryptoStore(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension DecodeError: Equatable, Hashable {}

extension DecodeError: Error { }


public enum DecryptionError {

    
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case Serialization(message: String)
    
    // Simple error enums only carry a message
    case Megolm(message: String)
    
}

fileprivate struct FfiConverterTypeDecryptionError: FfiConverterRustBuffer {
    typealias SwiftType = DecryptionError

    static func read(from buf: Reader) throws -> DecryptionError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Identifier(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .Serialization(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 3: return .Megolm(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: DecryptionError, into buf: Writer) {
        switch value {

        

        
        case let .Identifier(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .Serialization(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)
        case let .Megolm(message):
            buf.writeInt(Int32(3))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension DecryptionError: Equatable, Hashable {}

extension DecryptionError: Error { }


public enum KeyImportError {

    
    
    // Simple error enums only carry a message
    case Export(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case Json(message: String)
    
}

fileprivate struct FfiConverterTypeKeyImportError: FfiConverterRustBuffer {
    typealias SwiftType = KeyImportError

    static func read(from buf: Reader) throws -> KeyImportError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Export(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 3: return .Json(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: KeyImportError, into buf: Writer) {
        switch value {

        

        
        case let .Export(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .CryptoStore(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)
        case let .Json(message):
            buf.writeInt(Int32(3))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension KeyImportError: Equatable, Hashable {}

extension KeyImportError: Error { }


public enum MigrationError {

    
    
    case Generic(`errorMessage`: String)
}

fileprivate struct FfiConverterTypeMigrationError: FfiConverterRustBuffer {
    typealias SwiftType = MigrationError

    static func read(from buf: Reader) throws -> MigrationError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Generic(
            `errorMessage`: try FfiConverterString.read(from: buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: MigrationError, into buf: Writer) {
        switch value {

        

        
        
        case let .Generic(`errorMessage`):
            buf.writeInt(Int32(1))
            FfiConverterString.write(`errorMessage`, into: buf)
            
        }
    }
}


extension MigrationError: Equatable, Hashable {}

extension MigrationError: Error { }


public enum PkDecryptionError {

    
    
    // Simple error enums only carry a message
    case Olm(message: String)
    
}

fileprivate struct FfiConverterTypePkDecryptionError: FfiConverterRustBuffer {
    typealias SwiftType = PkDecryptionError

    static func read(from buf: Reader) throws -> PkDecryptionError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Olm(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: PkDecryptionError, into buf: Writer) {
        switch value {

        

        
        case let .Olm(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension PkDecryptionError: Equatable, Hashable {}

extension PkDecryptionError: Error { }


public enum SecretImportError {

    
    
    // Simple error enums only carry a message
    case Import(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
}

fileprivate struct FfiConverterTypeSecretImportError: FfiConverterRustBuffer {
    typealias SwiftType = SecretImportError

    static func read(from buf: Reader) throws -> SecretImportError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Import(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: SecretImportError, into buf: Writer) {
        switch value {

        

        
        case let .Import(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .CryptoStore(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension SecretImportError: Equatable, Hashable {}

extension SecretImportError: Error { }


public enum SignatureError {

    
    
    // Simple error enums only carry a message
    case Signature(message: String)
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case UnknownDevice(message: String)
    
    // Simple error enums only carry a message
    case UnknownUserIdentity(message: String)
    
}

fileprivate struct FfiConverterTypeSignatureError: FfiConverterRustBuffer {
    typealias SwiftType = SignatureError

    static func read(from buf: Reader) throws -> SignatureError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Signature(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .Identifier(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 3: return .CryptoStore(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 4: return .UnknownDevice(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 5: return .UnknownUserIdentity(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: SignatureError, into buf: Writer) {
        switch value {

        

        
        case let .Signature(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .Identifier(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)
        case let .CryptoStore(message):
            buf.writeInt(Int32(3))
            FfiConverterString.write(message, into: buf)
        case let .UnknownDevice(message):
            buf.writeInt(Int32(4))
            FfiConverterString.write(message, into: buf)
        case let .UnknownUserIdentity(message):
            buf.writeInt(Int32(5))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension SignatureError: Equatable, Hashable {}

extension SignatureError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias Handle = UInt64
fileprivate class ConcurrentHandleMap<T> {
    private var leftMap: [Handle: T] = [:]
    private var counter: [Handle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: Handle] = [:]

    private let lock = NSLock()
    private var currentHandle: Handle = 0
    private let stride: Handle = 1

    func insert(obj: T) -> Handle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: Handle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: Handle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: Handle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for Logger Callback Interface

public protocol Logger : AnyObject {
    func `log`(`logLine`: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceLogger : ForeignCallback =
    { (handle: Handle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeLog`(_ swiftCallbackInterface: Logger, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            let reader = Reader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`log`(
                    `logLine`:  try FfiConverterString.read(from: reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: Logger
        do {
            cb = try FfiConverterCallbackInterfaceLogger.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("Logger: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceLogger.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeLog`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FFIConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceLogger {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_crypto_ffi_c3eb_Logger_init_callback(foreignCallbackCallbackInterfaceLogger, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: Handle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = ConcurrentHandleMap<Logger>()
}

extension FfiConverterCallbackInterfaceLogger : FfiConverter {
    typealias SwiftType = Logger
    // We can use Handle as the FFIType because it's a typealias to UInt64
    typealias FfiType = Handle

    static func lift(_ handle: Handle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    static func read(from buf: Reader) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: Handle = try buf.readInt()
        return try lift(handle)
    }

    static func lower(_ v: SwiftType) -> Handle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    static func write(_ v: SwiftType, into buf: Writer) {
        ensureCallbackinitialized();
        buf.writeInt(lower(v))
    }
}



// Declaration and FfiConverters for ProgressListener Callback Interface

public protocol ProgressListener : AnyObject {
    func `onProgress`(`progress`: Int32, `total`: Int32) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceProgressListener : ForeignCallback =
    { (handle: Handle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeOnProgress`(_ swiftCallbackInterface: ProgressListener, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            let reader = Reader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`onProgress`(
                    `progress`:  try FfiConverterInt32.read(from: reader), 
                    `total`:  try FfiConverterInt32.read(from: reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: ProgressListener
        do {
            cb = try FfiConverterCallbackInterfaceProgressListener.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("ProgressListener: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceProgressListener.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeOnProgress`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FFIConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceProgressListener {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_crypto_ffi_c3eb_ProgressListener_init_callback(foreignCallbackCallbackInterfaceProgressListener, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: Handle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = ConcurrentHandleMap<ProgressListener>()
}

extension FfiConverterCallbackInterfaceProgressListener : FfiConverter {
    typealias SwiftType = ProgressListener
    // We can use Handle as the FFIType because it's a typealias to UInt64
    typealias FfiType = Handle

    static func lift(_ handle: Handle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    static func read(from buf: Reader) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: Handle = try buf.readInt()
        return try lift(handle)
    }

    static func lower(_ v: SwiftType) -> Handle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    static func write(_ v: SwiftType, into buf: Writer) {
        ensureCallbackinitialized();
        buf.writeInt(lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterString.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackupKeys: FfiConverterRustBuffer {
    typealias SwiftType = BackupKeys?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeBackupKeys.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupKeys.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackupRecoveryKey: FfiConverterRustBuffer {
    typealias SwiftType = BackupRecoveryKey?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeBackupRecoveryKey.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupRecoveryKey.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCancelInfo: FfiConverterRustBuffer {
    typealias SwiftType = CancelInfo?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeCancelInfo.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCancelInfo.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeConfirmVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmVerificationResult?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeConfirmVerificationResult.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConfirmVerificationResult.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCrossSigningKeyExport: FfiConverterRustBuffer {
    typealias SwiftType = CrossSigningKeyExport?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeCrossSigningKeyExport.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCrossSigningKeyExport.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDevice: FfiConverterRustBuffer {
    typealias SwiftType = Device?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeDevice.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDevice.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePassphraseInfo: FfiConverterRustBuffer {
    typealias SwiftType = PassphraseInfo?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypePassphraseInfo.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePassphraseInfo.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeQrCode: FfiConverterRustBuffer {
    typealias SwiftType = QrCode?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeQrCode.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeQrCode.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRequestVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = RequestVerificationResult?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeRequestVerificationResult.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequestVerificationResult.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeScanResult: FfiConverterRustBuffer {
    typealias SwiftType = ScanResult?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeScanResult.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeScanResult.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSignatureUploadRequest: FfiConverterRustBuffer {
    typealias SwiftType = SignatureUploadRequest?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeSignatureUploadRequest.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignatureUploadRequest.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeStartSasResult: FfiConverterRustBuffer {
    typealias SwiftType = StartSasResult?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeStartSasResult.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStartSasResult.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = VerificationRequest?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeVerificationRequest.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerificationRequest.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingVerificationRequest?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeOutgoingVerificationRequest.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutgoingVerificationRequest.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = Request?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeRequest.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequest.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeUserIdentity.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserIdentity.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerification: FfiConverterRustBuffer {
    typealias SwiftType = Verification?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeVerification.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerification.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterSequenceInt32.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceInt32.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterSequenceString.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    static func write(_ value: [UInt8], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterUInt8.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [UInt8] {
        let len: Int32 = try buf.readInt()
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]

    static func write(_ value: [Int32], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterInt32.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Int32] {
        let len: Int32 = try buf.readInt()
        var seq = [Int32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt32.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    static func write(_ value: [String], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterString.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [String] {
        let len: Int32 = try buf.readInt()
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDevice: FfiConverterRustBuffer {
    typealias SwiftType = [Device]

    static func write(_ value: [Device], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeDevice.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Device] {
        let len: Int32 = try buf.readInt()
        var seq = [Device]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDevice.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePickledInboundGroupSession: FfiConverterRustBuffer {
    typealias SwiftType = [PickledInboundGroupSession]

    static func write(_ value: [PickledInboundGroupSession], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypePickledInboundGroupSession.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [PickledInboundGroupSession] {
        let len: Int32 = try buf.readInt()
        var seq = [PickledInboundGroupSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePickledInboundGroupSession.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePickledSession: FfiConverterRustBuffer {
    typealias SwiftType = [PickledSession]

    static func write(_ value: [PickledSession], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypePickledSession.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [PickledSession] {
        let len: Int32 = try buf.readInt()
        var seq = [PickledSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePickledSession.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = [VerificationRequest]

    static func write(_ value: [VerificationRequest], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeVerificationRequest.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [VerificationRequest] {
        let len: Int32 = try buf.readInt()
        var seq = [VerificationRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerificationRequest.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = [OutgoingVerificationRequest]

    static func write(_ value: [OutgoingVerificationRequest], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeOutgoingVerificationRequest.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [OutgoingVerificationRequest] {
        let len: Int32 = try buf.readInt()
        var seq = [OutgoingVerificationRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutgoingVerificationRequest.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = [Request]

    static func write(_ value: [Request], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeRequest.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Request] {
        let len: Int32 = try buf.readInt()
        var seq = [Request]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequest.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringInt32: FfiConverterRustBuffer {
    fileprivate static func write(_ value: [String: Int32], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            FfiConverterString.write(key, into: buf)
            FfiConverterInt32.write(value, into: buf)
        }
    }

    fileprivate static func read(from buf: Reader) throws -> [String: Int32] {
        let len: Int32 = try buf.readInt()
        var dict = [String: Int32]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: buf)
            let value = try FfiConverterInt32.read(from: buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    fileprivate static func write(_ value: [String: String], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            FfiConverterString.write(key, into: buf)
            FfiConverterString.write(value, into: buf)
        }
    }

    fileprivate static func read(from buf: Reader) throws -> [String: String] {
        let len: Int32 = try buf.readInt()
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: buf)
            let value = try FfiConverterString.read(from: buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    fileprivate static func write(_ value: [String: [String]], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            FfiConverterString.write(key, into: buf)
            FfiConverterSequenceString.write(value, into: buf)
        }
    }

    fileprivate static func read(from buf: Reader) throws -> [String: [String]] {
        let len: Int32 = try buf.readInt()
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: buf)
            let value = try FfiConverterSequenceString.read(from: buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringString: FfiConverterRustBuffer {
    fileprivate static func write(_ value: [String: [String: String]], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            FfiConverterString.write(key, into: buf)
            FfiConverterDictionaryStringString.write(value, into: buf)
        }
    }

    fileprivate static func read(from buf: Reader) throws -> [String: [String: String]] {
        let len: Int32 = try buf.readInt()
        var dict = [String: [String: String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: buf)
            let value = try FfiConverterDictionaryStringString.read(from: buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringSequenceString: FfiConverterRustBuffer {
    fileprivate static func write(_ value: [String: [String: [String]]], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            FfiConverterString.write(key, into: buf)
            FfiConverterDictionaryStringSequenceString.write(value, into: buf)
        }
    }

    fileprivate static func read(from buf: Reader) throws -> [String: [String: [String]]] {
        let len: Int32 = try buf.readInt()
        var dict = [String: [String: [String]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: buf)
            let value = try FfiConverterDictionaryStringSequenceString.read(from: buf)
            dict[key] = value
        }
        return dict
    }
}

public func `setLogger`(`logger`: Logger)  {
    try!
    
    rustCall() {
    
    matrix_sdk_crypto_ffi_c3eb_set_logger(
        FfiConverterCallbackInterfaceLogger.lower(`logger`), $0)
}
}


public func `migrate`(`data`: MigrationData, `path`: String, `passphrase`: String?, `progressListener`: ProgressListener) throws {
    try
    
    rustCallWithError(FfiConverterTypeMigrationError.self) {
    
    matrix_sdk_crypto_ffi_c3eb_migrate(
        FfiConverterTypeMigrationData.lower(`data`), 
        FfiConverterString.lower(`path`), 
        FfiConverterOptionString.lower(`passphrase`), 
        FfiConverterCallbackInterfaceProgressListener.lower(`progressListener`), $0)
}
}


/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum MatrixSdkCryptoLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}