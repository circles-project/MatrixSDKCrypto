// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MatrixSDKCryptoFFI)
import MatrixSDKCryptoFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
                throw CancellationError()

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


public protocol BackupKeysProtocol {
    func backupVersion()   -> String
    func recoveryKey()   -> BackupRecoveryKey
    
}

public class BackupKeys: BackupKeysProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_backupkeys(pointer, $0) }
    }

    

    
    

    public func backupVersion()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backupkeys_backup_version(self.pointer, $0
    )
}
        )
    }

    public func recoveryKey()  -> BackupRecoveryKey {
        return try!  FfiConverterTypeBackupRecoveryKey.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backupkeys_recovery_key(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeBackupKeys: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupKeys

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupKeys {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BackupKeys, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupKeys {
        return BackupKeys(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BackupKeys) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeBackupKeys_lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupKeys {
    return try FfiConverterTypeBackupKeys.lift(pointer)
}

public func FfiConverterTypeBackupKeys_lower(_ value: BackupKeys) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBackupKeys.lower(value)
}


public protocol BackupRecoveryKeyProtocol {
    func decryptV1(ephemeralKey: String, mac: String, ciphertext: String)  throws -> String
    func megolmV1PublicKey()   -> MegolmV1BackupKey
    func toBase58()   -> String
    func toBase64()   -> String
    
}

public class BackupRecoveryKey: BackupRecoveryKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_backuprecoverykey(pointer, $0) }
    }

    

    public static func fromBase58(key: String) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeDecodeError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_from_base58(
        FfiConverterString.lower(key),$0)
})
    }

    

    public static func fromBase64(key: String) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeDecodeError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_from_base64(
        FfiConverterString.lower(key),$0)
})
    }

    

    public static func fromPassphrase(passphrase: String, salt: String, rounds: Int32)  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_from_passphrase(
        FfiConverterString.lower(passphrase),
        FfiConverterString.lower(salt),
        FfiConverterInt32.lower(rounds),$0)
})
    }

    

    public static func newFromPassphrase(passphrase: String)  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_backuprecoverykey_new_from_passphrase(
        FfiConverterString.lower(passphrase),$0)
})
    }

    

    
    

    public func decryptV1(ephemeralKey: String, mac: String, ciphertext: String) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePkDecryptionError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_backuprecoverykey_decrypt_v1(self.pointer, 
        FfiConverterString.lower(ephemeralKey),
        FfiConverterString.lower(mac),
        FfiConverterString.lower(ciphertext),$0
    )
}
        )
    }

    public func megolmV1PublicKey()  -> MegolmV1BackupKey {
        return try!  FfiConverterTypeMegolmV1BackupKey.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backuprecoverykey_megolm_v1_public_key(self.pointer, $0
    )
}
        )
    }

    public func toBase58()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backuprecoverykey_to_base58(self.pointer, $0
    )
}
        )
    }

    public func toBase64()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_backuprecoverykey_to_base64(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeBackupRecoveryKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupRecoveryKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupRecoveryKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BackupRecoveryKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BackupRecoveryKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeBackupRecoveryKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupRecoveryKey {
    return try FfiConverterTypeBackupRecoveryKey.lift(pointer)
}

public func FfiConverterTypeBackupRecoveryKey_lower(_ value: BackupRecoveryKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBackupRecoveryKey.lower(value)
}


public protocol DehydratedDeviceProtocol {
    func keysForUpload(deviceDisplayName: String, pickleKey: Data)  throws -> UploadDehydratedDeviceRequest
    
}

public class DehydratedDevice: DehydratedDeviceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_dehydrateddevice(pointer, $0) }
    }

    

    
    

    public func keysForUpload(deviceDisplayName: String, pickleKey: Data) throws -> UploadDehydratedDeviceRequest {
        return try  FfiConverterTypeUploadDehydratedDeviceRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeDehydrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_dehydrateddevice_keys_for_upload(self.pointer, 
        FfiConverterString.lower(deviceDisplayName),
        FfiConverterData.lower(pickleKey),$0
    )
}
        )
    }
}

public struct FfiConverterTypeDehydratedDevice: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DehydratedDevice

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DehydratedDevice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DehydratedDevice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DehydratedDevice {
        return DehydratedDevice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DehydratedDevice) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeDehydratedDevice_lift(_ pointer: UnsafeMutableRawPointer) throws -> DehydratedDevice {
    return try FfiConverterTypeDehydratedDevice.lift(pointer)
}

public func FfiConverterTypeDehydratedDevice_lower(_ value: DehydratedDevice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDehydratedDevice.lower(value)
}


public protocol DehydratedDevicesProtocol {
    func create()   -> DehydratedDevice
    func rehydrate(pickleKey: Data, deviceId: String, deviceData: String)  throws -> RehydratedDevice
    
}

public class DehydratedDevices: DehydratedDevicesProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_dehydrateddevices(pointer, $0) }
    }

    

    
    

    public func create()  -> DehydratedDevice {
        return try!  FfiConverterTypeDehydratedDevice.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_dehydrateddevices_create(self.pointer, $0
    )
}
        )
    }

    public func rehydrate(pickleKey: Data, deviceId: String, deviceData: String) throws -> RehydratedDevice {
        return try  FfiConverterTypeRehydratedDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeDehydrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_dehydrateddevices_rehydrate(self.pointer, 
        FfiConverterData.lower(pickleKey),
        FfiConverterString.lower(deviceId),
        FfiConverterString.lower(deviceData),$0
    )
}
        )
    }
}

public struct FfiConverterTypeDehydratedDevices: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DehydratedDevices

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DehydratedDevices {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DehydratedDevices, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DehydratedDevices {
        return DehydratedDevices(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DehydratedDevices) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeDehydratedDevices_lift(_ pointer: UnsafeMutableRawPointer) throws -> DehydratedDevices {
    return try FfiConverterTypeDehydratedDevices.lift(pointer)
}

public func FfiConverterTypeDehydratedDevices_lower(_ value: DehydratedDevices) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDehydratedDevices.lower(value)
}


public protocol OlmMachineProtocol {
    func backupEnabled()   -> Bool
    func backupRoomKeys()  throws -> Request?
    func bootstrapCrossSigning()  throws -> BootstrapCrossSigningResult
    func crossSigningStatus()   -> CrossSigningStatus
    func decryptRoomEvent(event: String, roomId: String, handleVerificationEvents: Bool, strictShields: Bool)  throws -> DecryptedEvent
    func dehydratedDevices()   -> DehydratedDevices
    func deviceId()   -> String
    func disableBackup()  throws
    func discardRoomKey(roomId: String)  throws
    func enableBackupV1(key: MegolmV1BackupKey, version: String)  throws
    func encrypt(roomId: String, eventType: String, content: String)  throws -> String
    func exportCrossSigningKeys()  throws -> CrossSigningKeyExport?
    func exportRoomKeys(passphrase: String, rounds: Int32)  throws -> String
    func getBackupKeys()  throws -> BackupKeys?
    func getDevice(userId: String, deviceId: String, timeout: UInt32)  throws -> Device?
    func getIdentity(userId: String, timeout: UInt32)  throws -> UserIdentity?
    func getMissingSessions(users: [String])  throws -> Request?
    func getOnlyAllowTrustedDevices()  throws -> Bool
    func getRoomSettings(roomId: String)  throws -> RoomSettings?
    func getUserDevices(userId: String, timeout: UInt32)  throws -> [Device]
    func getVerification(userId: String, flowId: String)   -> Verification?
    func getVerificationRequest(userId: String, flowId: String)   -> VerificationRequest?
    func getVerificationRequests(userId: String)   -> [VerificationRequest]
    func identityKeys()   -> [String: String]
    func importCrossSigningKeys(export: CrossSigningKeyExport)  throws
    func importDecryptedRoomKeys(keys: String, progressListener: ProgressListener)  throws -> KeysImportResult
    func importRoomKeys(keys: String, passphrase: String, progressListener: ProgressListener)  throws -> KeysImportResult
    func isIdentityVerified(userId: String)  throws -> Bool
    func isUserTracked(userId: String)  throws -> Bool
    func markRequestAsSent(requestId: String, requestType: RequestType, responseBody: String)  throws
    func outgoingRequests()  throws -> [Request]
    func queryMissingSecretsFromOtherSessions()  throws -> Bool
    func receiveSyncChanges(events: String, deviceChanges: DeviceLists, keyCounts: [String: Int32], unusedFallbackKeys: [String]?, nextBatchToken: String)  throws -> SyncChangesResult
    func receiveUnencryptedVerificationEvent(event: String, roomId: String)  throws
    func receiveVerificationEvent(event: String, roomId: String)  throws
    func requestRoomKey(event: String, roomId: String)  throws -> KeyRequestPair
    func requestSelfVerification(methods: [String])  throws -> RequestVerificationResult?
    func requestVerification(userId: String, roomId: String, eventId: String, methods: [String])  throws -> VerificationRequest?
    func requestVerificationWithDevice(userId: String, deviceId: String, methods: [String])  throws -> RequestVerificationResult?
    func roomKeyCounts()  throws -> RoomKeyCounts
    func saveRecoveryKey(key: BackupRecoveryKey?, version: String?)  throws
    func setLocalTrust(userId: String, deviceId: String, trustState: LocalTrust)  throws
    func setOnlyAllowTrustedDevices(onlyAllowTrustedDevices: Bool)  throws
    func setRoomAlgorithm(roomId: String, algorithm: EventEncryptionAlgorithm)  throws
    func setRoomOnlyAllowTrustedDevices(roomId: String, onlyAllowTrustedDevices: Bool)  throws
    func shareRoomHistoryKeys(roomId: String, users: [String])  throws -> [Request]
    func shareRoomKey(roomId: String, users: [String], settings: EncryptionSettings)  throws -> [Request]
    func sign(message: String)  throws -> [String: [String: String]]
    func startSasWithDevice(userId: String, deviceId: String)  throws -> StartSasResult?
    func updateTrackedUsers(users: [String])  throws
    func userId()   -> String
    func verificationRequestContent(userId: String, methods: [String])  throws -> String?
    func verifyBackup(backupInfo: String)  throws -> SignatureVerification
    func verifyDevice(userId: String, deviceId: String)  throws -> SignatureUploadRequest
    func verifyIdentity(userId: String)  throws -> SignatureUploadRequest
    
}

public class OlmMachine: OlmMachineProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(userId: String, deviceId: String, path: String, passphrase: String?) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_constructor_olmmachine_new(
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterString.lower(path),
        FfiConverterOptionString.lower(passphrase),$0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_olmmachine(pointer, $0) }
    }

    

    
    

    public func backupEnabled()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_backup_enabled(self.pointer, $0
    )
}
        )
    }

    public func backupRoomKeys() throws -> Request? {
        return try  FfiConverterOptionTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_backup_room_keys(self.pointer, $0
    )
}
        )
    }

    public func bootstrapCrossSigning() throws -> BootstrapCrossSigningResult {
        return try  FfiConverterTypeBootstrapCrossSigningResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_bootstrap_cross_signing(self.pointer, $0
    )
}
        )
    }

    public func crossSigningStatus()  -> CrossSigningStatus {
        return try!  FfiConverterTypeCrossSigningStatus.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_cross_signing_status(self.pointer, $0
    )
}
        )
    }

    public func decryptRoomEvent(event: String, roomId: String, handleVerificationEvents: Bool, strictShields: Bool) throws -> DecryptedEvent {
        return try  FfiConverterTypeDecryptedEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeDecryptionError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_decrypt_room_event(self.pointer, 
        FfiConverterString.lower(event),
        FfiConverterString.lower(roomId),
        FfiConverterBool.lower(handleVerificationEvents),
        FfiConverterBool.lower(strictShields),$0
    )
}
        )
    }

    public func dehydratedDevices()  -> DehydratedDevices {
        return try!  FfiConverterTypeDehydratedDevices.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_dehydrated_devices(self.pointer, $0
    )
}
        )
    }

    public func deviceId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_device_id(self.pointer, $0
    )
}
        )
    }

    public func disableBackup() throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_disable_backup(self.pointer, $0
    )
}
    }

    public func discardRoomKey(roomId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_discard_room_key(self.pointer, 
        FfiConverterString.lower(roomId),$0
    )
}
    }

    public func enableBackupV1(key: MegolmV1BackupKey, version: String) throws {
        try 
    rustCallWithError(FfiConverterTypeDecodeError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_enable_backup_v1(self.pointer, 
        FfiConverterTypeMegolmV1BackupKey.lower(key),
        FfiConverterString.lower(version),$0
    )
}
    }

    public func encrypt(roomId: String, eventType: String, content: String) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_encrypt(self.pointer, 
        FfiConverterString.lower(roomId),
        FfiConverterString.lower(eventType),
        FfiConverterString.lower(content),$0
    )
}
        )
    }

    public func exportCrossSigningKeys() throws -> CrossSigningKeyExport? {
        return try  FfiConverterOptionTypeCrossSigningKeyExport.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_export_cross_signing_keys(self.pointer, $0
    )
}
        )
    }

    public func exportRoomKeys(passphrase: String, rounds: Int32) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_export_room_keys(self.pointer, 
        FfiConverterString.lower(passphrase),
        FfiConverterInt32.lower(rounds),$0
    )
}
        )
    }

    public func getBackupKeys() throws -> BackupKeys? {
        return try  FfiConverterOptionTypeBackupKeys.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_backup_keys(self.pointer, $0
    )
}
        )
    }

    public func getDevice(userId: String, deviceId: String, timeout: UInt32) throws -> Device? {
        return try  FfiConverterOptionTypeDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_device(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterUInt32.lower(timeout),$0
    )
}
        )
    }

    public func getIdentity(userId: String, timeout: UInt32) throws -> UserIdentity? {
        return try  FfiConverterOptionTypeUserIdentity.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_identity(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterUInt32.lower(timeout),$0
    )
}
        )
    }

    public func getMissingSessions(users: [String]) throws -> Request? {
        return try  FfiConverterOptionTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_missing_sessions(self.pointer, 
        FfiConverterSequenceString.lower(users),$0
    )
}
        )
    }

    public func getOnlyAllowTrustedDevices() throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_only_allow_trusted_devices(self.pointer, $0
    )
}
        )
    }

    public func getRoomSettings(roomId: String) throws -> RoomSettings? {
        return try  FfiConverterOptionTypeRoomSettings.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_room_settings(self.pointer, 
        FfiConverterString.lower(roomId),$0
    )
}
        )
    }

    public func getUserDevices(userId: String, timeout: UInt32) throws -> [Device] {
        return try  FfiConverterSequenceTypeDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_user_devices(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterUInt32.lower(timeout),$0
    )
}
        )
    }

    public func getVerification(userId: String, flowId: String)  -> Verification? {
        return try!  FfiConverterOptionTypeVerification.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_verification(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(flowId),$0
    )
}
        )
    }

    public func getVerificationRequest(userId: String, flowId: String)  -> VerificationRequest? {
        return try!  FfiConverterOptionTypeVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_verification_request(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(flowId),$0
    )
}
        )
    }

    public func getVerificationRequests(userId: String)  -> [VerificationRequest] {
        return try!  FfiConverterSequenceTypeVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_get_verification_requests(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

    public func identityKeys()  -> [String: String] {
        return try!  FfiConverterDictionaryStringString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_identity_keys(self.pointer, $0
    )
}
        )
    }

    public func importCrossSigningKeys(export: CrossSigningKeyExport) throws {
        try 
    rustCallWithError(FfiConverterTypeSecretImportError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_import_cross_signing_keys(self.pointer, 
        FfiConverterTypeCrossSigningKeyExport.lower(export),$0
    )
}
    }

    public func importDecryptedRoomKeys(keys: String, progressListener: ProgressListener) throws -> KeysImportResult {
        return try  FfiConverterTypeKeysImportResult.lift(
            try 
    rustCallWithError(FfiConverterTypeKeyImportError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_import_decrypted_room_keys(self.pointer, 
        FfiConverterString.lower(keys),
        FfiConverterCallbackInterfaceProgressListener.lower(progressListener),$0
    )
}
        )
    }

    public func importRoomKeys(keys: String, passphrase: String, progressListener: ProgressListener) throws -> KeysImportResult {
        return try  FfiConverterTypeKeysImportResult.lift(
            try 
    rustCallWithError(FfiConverterTypeKeyImportError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_import_room_keys(self.pointer, 
        FfiConverterString.lower(keys),
        FfiConverterString.lower(passphrase),
        FfiConverterCallbackInterfaceProgressListener.lower(progressListener),$0
    )
}
        )
    }

    public func isIdentityVerified(userId: String) throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_is_identity_verified(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

    public func isUserTracked(userId: String) throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_is_user_tracked(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

    public func markRequestAsSent(requestId: String, requestType: RequestType, responseBody: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_mark_request_as_sent(self.pointer, 
        FfiConverterString.lower(requestId),
        FfiConverterTypeRequestType.lower(requestType),
        FfiConverterString.lower(responseBody),$0
    )
}
    }

    public func outgoingRequests() throws -> [Request] {
        return try  FfiConverterSequenceTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_outgoing_requests(self.pointer, $0
    )
}
        )
    }

    public func queryMissingSecretsFromOtherSessions() throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_query_missing_secrets_from_other_sessions(self.pointer, $0
    )
}
        )
    }

    public func receiveSyncChanges(events: String, deviceChanges: DeviceLists, keyCounts: [String: Int32], unusedFallbackKeys: [String]?, nextBatchToken: String) throws -> SyncChangesResult {
        return try  FfiConverterTypeSyncChangesResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_receive_sync_changes(self.pointer, 
        FfiConverterString.lower(events),
        FfiConverterTypeDeviceLists.lower(deviceChanges),
        FfiConverterDictionaryStringInt32.lower(keyCounts),
        FfiConverterOptionSequenceString.lower(unusedFallbackKeys),
        FfiConverterString.lower(nextBatchToken),$0
    )
}
        )
    }

    public func receiveUnencryptedVerificationEvent(event: String, roomId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_receive_unencrypted_verification_event(self.pointer, 
        FfiConverterString.lower(event),
        FfiConverterString.lower(roomId),$0
    )
}
    }

    public func receiveVerificationEvent(event: String, roomId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_receive_verification_event(self.pointer, 
        FfiConverterString.lower(event),
        FfiConverterString.lower(roomId),$0
    )
}
    }

    public func requestRoomKey(event: String, roomId: String) throws -> KeyRequestPair {
        return try  FfiConverterTypeKeyRequestPair.lift(
            try 
    rustCallWithError(FfiConverterTypeDecryptionError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_request_room_key(self.pointer, 
        FfiConverterString.lower(event),
        FfiConverterString.lower(roomId),$0
    )
}
        )
    }

    public func requestSelfVerification(methods: [String]) throws -> RequestVerificationResult? {
        return try  FfiConverterOptionTypeRequestVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_request_self_verification(self.pointer, 
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }

    public func requestVerification(userId: String, roomId: String, eventId: String, methods: [String]) throws -> VerificationRequest? {
        return try  FfiConverterOptionTypeVerificationRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_request_verification(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(roomId),
        FfiConverterString.lower(eventId),
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }

    public func requestVerificationWithDevice(userId: String, deviceId: String, methods: [String]) throws -> RequestVerificationResult? {
        return try  FfiConverterOptionTypeRequestVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_request_verification_with_device(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }

    public func roomKeyCounts() throws -> RoomKeyCounts {
        return try  FfiConverterTypeRoomKeyCounts.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_room_key_counts(self.pointer, $0
    )
}
        )
    }

    public func saveRecoveryKey(key: BackupRecoveryKey?, version: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_save_recovery_key(self.pointer, 
        FfiConverterOptionTypeBackupRecoveryKey.lower(key),
        FfiConverterOptionString.lower(version),$0
    )
}
    }

    public func setLocalTrust(userId: String, deviceId: String, trustState: LocalTrust) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_set_local_trust(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),
        FfiConverterTypeLocalTrust.lower(trustState),$0
    )
}
    }

    public func setOnlyAllowTrustedDevices(onlyAllowTrustedDevices: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_set_only_allow_trusted_devices(self.pointer, 
        FfiConverterBool.lower(onlyAllowTrustedDevices),$0
    )
}
    }

    public func setRoomAlgorithm(roomId: String, algorithm: EventEncryptionAlgorithm) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_set_room_algorithm(self.pointer, 
        FfiConverterString.lower(roomId),
        FfiConverterTypeEventEncryptionAlgorithm.lower(algorithm),$0
    )
}
    }

    public func setRoomOnlyAllowTrustedDevices(roomId: String, onlyAllowTrustedDevices: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_set_room_only_allow_trusted_devices(self.pointer, 
        FfiConverterString.lower(roomId),
        FfiConverterBool.lower(onlyAllowTrustedDevices),$0
    )
}
    }

    public func shareRoomHistoryKeys(roomId: String, users: [String]) throws -> [Request] {
        return try  FfiConverterSequenceTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_share_room_history_keys(self.pointer, 
        FfiConverterString.lower(roomId),
        FfiConverterSequenceString.lower(users),$0
    )
}
        )
    }

    public func shareRoomKey(roomId: String, users: [String], settings: EncryptionSettings) throws -> [Request] {
        return try  FfiConverterSequenceTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_share_room_key(self.pointer, 
        FfiConverterString.lower(roomId),
        FfiConverterSequenceString.lower(users),
        FfiConverterTypeEncryptionSettings.lower(settings),$0
    )
}
        )
    }

    public func sign(message: String) throws -> [String: [String: String]] {
        return try  FfiConverterDictionaryStringDictionaryStringString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_sign(self.pointer, 
        FfiConverterString.lower(message),$0
    )
}
        )
    }

    public func startSasWithDevice(userId: String, deviceId: String) throws -> StartSasResult? {
        return try  FfiConverterOptionTypeStartSasResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_start_sas_with_device(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),$0
    )
}
        )
    }

    public func updateTrackedUsers(users: [String]) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_update_tracked_users(self.pointer, 
        FfiConverterSequenceString.lower(users),$0
    )
}
    }

    public func userId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_user_id(self.pointer, $0
    )
}
        )
    }

    public func verificationRequestContent(userId: String, methods: [String]) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_verification_request_content(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }

    public func verifyBackup(backupInfo: String) throws -> SignatureVerification {
        return try  FfiConverterTypeSignatureVerification.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_verify_backup(self.pointer, 
        FfiConverterString.lower(backupInfo),$0
    )
}
        )
    }

    public func verifyDevice(userId: String, deviceId: String) throws -> SignatureUploadRequest {
        return try  FfiConverterTypeSignatureUploadRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeSignatureError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_verify_device(self.pointer, 
        FfiConverterString.lower(userId),
        FfiConverterString.lower(deviceId),$0
    )
}
        )
    }

    public func verifyIdentity(userId: String) throws -> SignatureUploadRequest {
        return try  FfiConverterTypeSignatureUploadRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeSignatureError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_olmmachine_verify_identity(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }
}

public struct FfiConverterTypeOlmMachine: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OlmMachine

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlmMachine {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OlmMachine, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OlmMachine {
        return OlmMachine(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OlmMachine) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOlmMachine_lift(_ pointer: UnsafeMutableRawPointer) throws -> OlmMachine {
    return try FfiConverterTypeOlmMachine.lift(pointer)
}

public func FfiConverterTypeOlmMachine_lower(_ value: OlmMachine) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOlmMachine.lower(value)
}


public protocol QrCodeProtocol {
    func cancel(cancelCode: String)   -> OutgoingVerificationRequest?
    func cancelInfo()   -> CancelInfo?
    func confirm()   -> ConfirmVerificationResult?
    func flowId()   -> String
    func generateQrCode()   -> String?
    func hasBeenScanned()   -> Bool
    func isCancelled()   -> Bool
    func isDone()   -> Bool
    func otherDeviceId()   -> String
    func otherUserId()   -> String
    func reciprocated()   -> Bool
    func roomId()   -> String?
    func setChangesListener(listener: QrCodeListener)  
    func state()   -> QrCodeState
    func weStarted()   -> Bool
    
}

public class QrCode: QrCodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_qrcode(pointer, $0) }
    }

    

    
    

    public func cancel(cancelCode: String)  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_cancel(self.pointer, 
        FfiConverterString.lower(cancelCode),$0
    )
}
        )
    }

    public func cancelInfo()  -> CancelInfo? {
        return try!  FfiConverterOptionTypeCancelInfo.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_cancel_info(self.pointer, $0
    )
}
        )
    }

    public func confirm()  -> ConfirmVerificationResult? {
        return try!  FfiConverterOptionTypeConfirmVerificationResult.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_confirm(self.pointer, $0
    )
}
        )
    }

    public func flowId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_flow_id(self.pointer, $0
    )
}
        )
    }

    public func generateQrCode()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_generate_qr_code(self.pointer, $0
    )
}
        )
    }

    public func hasBeenScanned()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_has_been_scanned(self.pointer, $0
    )
}
        )
    }

    public func isCancelled()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_is_cancelled(self.pointer, $0
    )
}
        )
    }

    public func isDone()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_is_done(self.pointer, $0
    )
}
        )
    }

    public func otherDeviceId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_other_device_id(self.pointer, $0
    )
}
        )
    }

    public func otherUserId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_other_user_id(self.pointer, $0
    )
}
        )
    }

    public func reciprocated()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_reciprocated(self.pointer, $0
    )
}
        )
    }

    public func roomId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_room_id(self.pointer, $0
    )
}
        )
    }

    public func setChangesListener(listener: QrCodeListener)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_set_changes_listener(self.pointer, 
        FfiConverterCallbackInterfaceQrCodeListener.lower(listener),$0
    )
}
    }

    public func state()  -> QrCodeState {
        return try!  FfiConverterTypeQrCodeState.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_state(self.pointer, $0
    )
}
        )
    }

    public func weStarted()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_qrcode_we_started(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeQrCode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = QrCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: QrCode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> QrCode {
        return QrCode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: QrCode) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeQrCode_lift(_ pointer: UnsafeMutableRawPointer) throws -> QrCode {
    return try FfiConverterTypeQrCode.lift(pointer)
}

public func FfiConverterTypeQrCode_lower(_ value: QrCode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeQrCode.lower(value)
}


public protocol RehydratedDeviceProtocol {
    func receiveEvents(events: String)  throws
    
}

public class RehydratedDevice: RehydratedDeviceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_rehydrateddevice(pointer, $0) }
    }

    

    
    

    public func receiveEvents(events: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_rehydrateddevice_receive_events(self.pointer, 
        FfiConverterString.lower(events),$0
    )
}
    }
}

public struct FfiConverterTypeRehydratedDevice: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RehydratedDevice

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RehydratedDevice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RehydratedDevice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RehydratedDevice {
        return RehydratedDevice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RehydratedDevice) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRehydratedDevice_lift(_ pointer: UnsafeMutableRawPointer) throws -> RehydratedDevice {
    return try FfiConverterTypeRehydratedDevice.lift(pointer)
}

public func FfiConverterTypeRehydratedDevice_lower(_ value: RehydratedDevice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRehydratedDevice.lower(value)
}


public protocol SasProtocol {
    func accept()   -> OutgoingVerificationRequest?
    func cancel(cancelCode: String)   -> OutgoingVerificationRequest?
    func confirm()  throws -> ConfirmVerificationResult?
    func flowId()   -> String
    func getDecimals()   -> [Int32]?
    func getEmojiIndices()   -> [Int32]?
    func isDone()   -> Bool
    func otherDeviceId()   -> String
    func otherUserId()   -> String
    func roomId()   -> String?
    func setChangesListener(listener: SasListener)  
    func state()   -> SasState
    func weStarted()   -> Bool
    
}

public class Sas: SasProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_sas(pointer, $0) }
    }

    

    
    

    public func accept()  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_accept(self.pointer, $0
    )
}
        )
    }

    public func cancel(cancelCode: String)  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_cancel(self.pointer, 
        FfiConverterString.lower(cancelCode),$0
    )
}
        )
    }

    public func confirm() throws -> ConfirmVerificationResult? {
        return try  FfiConverterOptionTypeConfirmVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_confirm(self.pointer, $0
    )
}
        )
    }

    public func flowId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_flow_id(self.pointer, $0
    )
}
        )
    }

    public func getDecimals()  -> [Int32]? {
        return try!  FfiConverterOptionSequenceInt32.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_get_decimals(self.pointer, $0
    )
}
        )
    }

    public func getEmojiIndices()  -> [Int32]? {
        return try!  FfiConverterOptionSequenceInt32.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_get_emoji_indices(self.pointer, $0
    )
}
        )
    }

    public func isDone()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_is_done(self.pointer, $0
    )
}
        )
    }

    public func otherDeviceId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_other_device_id(self.pointer, $0
    )
}
        )
    }

    public func otherUserId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_other_user_id(self.pointer, $0
    )
}
        )
    }

    public func roomId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_room_id(self.pointer, $0
    )
}
        )
    }

    public func setChangesListener(listener: SasListener)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_set_changes_listener(self.pointer, 
        FfiConverterCallbackInterfaceSasListener.lower(listener),$0
    )
}
    }

    public func state()  -> SasState {
        return try!  FfiConverterTypeSasState.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_state(self.pointer, $0
    )
}
        )
    }

    public func weStarted()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_sas_we_started(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSas: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Sas

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sas {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Sas, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Sas {
        return Sas(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Sas) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSas_lift(_ pointer: UnsafeMutableRawPointer) throws -> Sas {
    return try FfiConverterTypeSas.lift(pointer)
}

public func FfiConverterTypeSas_lower(_ value: Sas) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSas.lower(value)
}


public protocol VerificationProtocol {
    func asQr()   -> QrCode?
    func asSas()   -> Sas?
    
}

public class Verification: VerificationProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_verification(pointer, $0) }
    }

    

    
    

    public func asQr()  -> QrCode? {
        return try!  FfiConverterOptionTypeQrCode.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verification_as_qr(self.pointer, $0
    )
}
        )
    }

    public func asSas()  -> Sas? {
        return try!  FfiConverterOptionTypeSas.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verification_as_sas(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeVerification: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Verification

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Verification {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Verification, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Verification {
        return Verification(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Verification) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeVerification_lift(_ pointer: UnsafeMutableRawPointer) throws -> Verification {
    return try FfiConverterTypeVerification.lift(pointer)
}

public func FfiConverterTypeVerification_lower(_ value: Verification) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVerification.lower(value)
}


public protocol VerificationRequestProtocol {
    func accept(methods: [String])   -> OutgoingVerificationRequest?
    func cancel()   -> OutgoingVerificationRequest?
    func cancelInfo()   -> CancelInfo?
    func flowId()   -> String
    func isCancelled()   -> Bool
    func isDone()   -> Bool
    func isPassive()   -> Bool
    func isReady()   -> Bool
    func otherDeviceId()   -> String?
    func otherUserId()   -> String
    func ourSupportedMethods()   -> [String]?
    func roomId()   -> String?
    func scanQrCode(data: String)   -> ScanResult?
    func setChangesListener(listener: VerificationRequestListener)  
    func startQrVerification()  throws -> QrCode?
    func startSasVerification()  throws -> StartSasResult?
    func state()   -> VerificationRequestState
    func theirSupportedMethods()   -> [String]?
    func weStarted()   -> Bool
    
}

public class VerificationRequest: VerificationRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_crypto_ffi_fn_free_verificationrequest(pointer, $0) }
    }

    

    
    

    public func accept(methods: [String])  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_accept(self.pointer, 
        FfiConverterSequenceString.lower(methods),$0
    )
}
        )
    }

    public func cancel()  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_cancel(self.pointer, $0
    )
}
        )
    }

    public func cancelInfo()  -> CancelInfo? {
        return try!  FfiConverterOptionTypeCancelInfo.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_cancel_info(self.pointer, $0
    )
}
        )
    }

    public func flowId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_flow_id(self.pointer, $0
    )
}
        )
    }

    public func isCancelled()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_is_cancelled(self.pointer, $0
    )
}
        )
    }

    public func isDone()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_is_done(self.pointer, $0
    )
}
        )
    }

    public func isPassive()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_is_passive(self.pointer, $0
    )
}
        )
    }

    public func isReady()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_is_ready(self.pointer, $0
    )
}
        )
    }

    public func otherDeviceId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_other_device_id(self.pointer, $0
    )
}
        )
    }

    public func otherUserId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_other_user_id(self.pointer, $0
    )
}
        )
    }

    public func ourSupportedMethods()  -> [String]? {
        return try!  FfiConverterOptionSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_our_supported_methods(self.pointer, $0
    )
}
        )
    }

    public func roomId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_room_id(self.pointer, $0
    )
}
        )
    }

    public func scanQrCode(data: String)  -> ScanResult? {
        return try!  FfiConverterOptionTypeScanResult.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_scan_qr_code(self.pointer, 
        FfiConverterString.lower(data),$0
    )
}
        )
    }

    public func setChangesListener(listener: VerificationRequestListener)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_set_changes_listener(self.pointer, 
        FfiConverterCallbackInterfaceVerificationRequestListener.lower(listener),$0
    )
}
    }

    public func startQrVerification() throws -> QrCode? {
        return try  FfiConverterOptionTypeQrCode.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_start_qr_verification(self.pointer, $0
    )
}
        )
    }

    public func startSasVerification() throws -> StartSasResult? {
        return try  FfiConverterOptionTypeStartSasResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_start_sas_verification(self.pointer, $0
    )
}
        )
    }

    public func state()  -> VerificationRequestState {
        return try!  FfiConverterTypeVerificationRequestState.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_state(self.pointer, $0
    )
}
        )
    }

    public func theirSupportedMethods()  -> [String]? {
        return try!  FfiConverterOptionSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_their_supported_methods(self.pointer, $0
    )
}
        )
    }

    public func weStarted()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_crypto_ffi_fn_method_verificationrequest_we_started(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeVerificationRequest: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VerificationRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VerificationRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VerificationRequest {
        return VerificationRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VerificationRequest) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeVerificationRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> VerificationRequest {
    return try FfiConverterTypeVerificationRequest.lift(pointer)
}

public func FfiConverterTypeVerificationRequest_lower(_ value: VerificationRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVerificationRequest.lower(value)
}


public struct BootstrapCrossSigningResult {
    public var uploadSigningKeysRequest: UploadSigningKeysRequest
    public var signatureRequest: SignatureUploadRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uploadSigningKeysRequest: UploadSigningKeysRequest, signatureRequest: SignatureUploadRequest) {
        self.uploadSigningKeysRequest = uploadSigningKeysRequest
        self.signatureRequest = signatureRequest
    }
}


extension BootstrapCrossSigningResult: Equatable, Hashable {
    public static func ==(lhs: BootstrapCrossSigningResult, rhs: BootstrapCrossSigningResult) -> Bool {
        if lhs.uploadSigningKeysRequest != rhs.uploadSigningKeysRequest {
            return false
        }
        if lhs.signatureRequest != rhs.signatureRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uploadSigningKeysRequest)
        hasher.combine(signatureRequest)
    }
}


public struct FfiConverterTypeBootstrapCrossSigningResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BootstrapCrossSigningResult {
        return try BootstrapCrossSigningResult(
            uploadSigningKeysRequest: FfiConverterTypeUploadSigningKeysRequest.read(from: &buf), 
            signatureRequest: FfiConverterTypeSignatureUploadRequest.read(from: &buf)
        )
    }

    public static func write(_ value: BootstrapCrossSigningResult, into buf: inout [UInt8]) {
        FfiConverterTypeUploadSigningKeysRequest.write(value.uploadSigningKeysRequest, into: &buf)
        FfiConverterTypeSignatureUploadRequest.write(value.signatureRequest, into: &buf)
    }
}


public func FfiConverterTypeBootstrapCrossSigningResult_lift(_ buf: RustBuffer) throws -> BootstrapCrossSigningResult {
    return try FfiConverterTypeBootstrapCrossSigningResult.lift(buf)
}

public func FfiConverterTypeBootstrapCrossSigningResult_lower(_ value: BootstrapCrossSigningResult) -> RustBuffer {
    return FfiConverterTypeBootstrapCrossSigningResult.lower(value)
}


public struct CancelInfo {
    public var reason: String
    public var cancelCode: String
    public var cancelledByUs: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(reason: String, cancelCode: String, cancelledByUs: Bool) {
        self.reason = reason
        self.cancelCode = cancelCode
        self.cancelledByUs = cancelledByUs
    }
}


extension CancelInfo: Equatable, Hashable {
    public static func ==(lhs: CancelInfo, rhs: CancelInfo) -> Bool {
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.cancelCode != rhs.cancelCode {
            return false
        }
        if lhs.cancelledByUs != rhs.cancelledByUs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reason)
        hasher.combine(cancelCode)
        hasher.combine(cancelledByUs)
    }
}


public struct FfiConverterTypeCancelInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelInfo {
        return try CancelInfo(
            reason: FfiConverterString.read(from: &buf), 
            cancelCode: FfiConverterString.read(from: &buf), 
            cancelledByUs: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CancelInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reason, into: &buf)
        FfiConverterString.write(value.cancelCode, into: &buf)
        FfiConverterBool.write(value.cancelledByUs, into: &buf)
    }
}


public func FfiConverterTypeCancelInfo_lift(_ buf: RustBuffer) throws -> CancelInfo {
    return try FfiConverterTypeCancelInfo.lift(buf)
}

public func FfiConverterTypeCancelInfo_lower(_ value: CancelInfo) -> RustBuffer {
    return FfiConverterTypeCancelInfo.lower(value)
}


public struct ConfirmVerificationResult {
    public var requests: [OutgoingVerificationRequest]
    public var signatureRequest: SignatureUploadRequest?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requests: [OutgoingVerificationRequest], signatureRequest: SignatureUploadRequest?) {
        self.requests = requests
        self.signatureRequest = signatureRequest
    }
}


extension ConfirmVerificationResult: Equatable, Hashable {
    public static func ==(lhs: ConfirmVerificationResult, rhs: ConfirmVerificationResult) -> Bool {
        if lhs.requests != rhs.requests {
            return false
        }
        if lhs.signatureRequest != rhs.signatureRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requests)
        hasher.combine(signatureRequest)
    }
}


public struct FfiConverterTypeConfirmVerificationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmVerificationResult {
        return try ConfirmVerificationResult(
            requests: FfiConverterSequenceTypeOutgoingVerificationRequest.read(from: &buf), 
            signatureRequest: FfiConverterOptionTypeSignatureUploadRequest.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmVerificationResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeOutgoingVerificationRequest.write(value.requests, into: &buf)
        FfiConverterOptionTypeSignatureUploadRequest.write(value.signatureRequest, into: &buf)
    }
}


public func FfiConverterTypeConfirmVerificationResult_lift(_ buf: RustBuffer) throws -> ConfirmVerificationResult {
    return try FfiConverterTypeConfirmVerificationResult.lift(buf)
}

public func FfiConverterTypeConfirmVerificationResult_lower(_ value: ConfirmVerificationResult) -> RustBuffer {
    return FfiConverterTypeConfirmVerificationResult.lower(value)
}


public struct CrossSigningKeyExport {
    public var masterKey: String?
    public var selfSigningKey: String?
    public var userSigningKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(masterKey: String?, selfSigningKey: String?, userSigningKey: String?) {
        self.masterKey = masterKey
        self.selfSigningKey = selfSigningKey
        self.userSigningKey = userSigningKey
    }
}


extension CrossSigningKeyExport: Equatable, Hashable {
    public static func ==(lhs: CrossSigningKeyExport, rhs: CrossSigningKeyExport) -> Bool {
        if lhs.masterKey != rhs.masterKey {
            return false
        }
        if lhs.selfSigningKey != rhs.selfSigningKey {
            return false
        }
        if lhs.userSigningKey != rhs.userSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterKey)
        hasher.combine(selfSigningKey)
        hasher.combine(userSigningKey)
    }
}


public struct FfiConverterTypeCrossSigningKeyExport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CrossSigningKeyExport {
        return try CrossSigningKeyExport(
            masterKey: FfiConverterOptionString.read(from: &buf), 
            selfSigningKey: FfiConverterOptionString.read(from: &buf), 
            userSigningKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CrossSigningKeyExport, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.masterKey, into: &buf)
        FfiConverterOptionString.write(value.selfSigningKey, into: &buf)
        FfiConverterOptionString.write(value.userSigningKey, into: &buf)
    }
}


public func FfiConverterTypeCrossSigningKeyExport_lift(_ buf: RustBuffer) throws -> CrossSigningKeyExport {
    return try FfiConverterTypeCrossSigningKeyExport.lift(buf)
}

public func FfiConverterTypeCrossSigningKeyExport_lower(_ value: CrossSigningKeyExport) -> RustBuffer {
    return FfiConverterTypeCrossSigningKeyExport.lower(value)
}


public struct CrossSigningStatus {
    public var hasMaster: Bool
    public var hasSelfSigning: Bool
    public var hasUserSigning: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hasMaster: Bool, hasSelfSigning: Bool, hasUserSigning: Bool) {
        self.hasMaster = hasMaster
        self.hasSelfSigning = hasSelfSigning
        self.hasUserSigning = hasUserSigning
    }
}


extension CrossSigningStatus: Equatable, Hashable {
    public static func ==(lhs: CrossSigningStatus, rhs: CrossSigningStatus) -> Bool {
        if lhs.hasMaster != rhs.hasMaster {
            return false
        }
        if lhs.hasSelfSigning != rhs.hasSelfSigning {
            return false
        }
        if lhs.hasUserSigning != rhs.hasUserSigning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hasMaster)
        hasher.combine(hasSelfSigning)
        hasher.combine(hasUserSigning)
    }
}


public struct FfiConverterTypeCrossSigningStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CrossSigningStatus {
        return try CrossSigningStatus(
            hasMaster: FfiConverterBool.read(from: &buf), 
            hasSelfSigning: FfiConverterBool.read(from: &buf), 
            hasUserSigning: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CrossSigningStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.hasMaster, into: &buf)
        FfiConverterBool.write(value.hasSelfSigning, into: &buf)
        FfiConverterBool.write(value.hasUserSigning, into: &buf)
    }
}


public func FfiConverterTypeCrossSigningStatus_lift(_ buf: RustBuffer) throws -> CrossSigningStatus {
    return try FfiConverterTypeCrossSigningStatus.lift(buf)
}

public func FfiConverterTypeCrossSigningStatus_lower(_ value: CrossSigningStatus) -> RustBuffer {
    return FfiConverterTypeCrossSigningStatus.lower(value)
}


public struct DecryptedEvent {
    public var clearEvent: String
    public var senderCurve25519Key: String
    public var claimedEd25519Key: String?
    public var forwardingCurve25519Chain: [String]
    public var shieldState: ShieldState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(clearEvent: String, senderCurve25519Key: String, claimedEd25519Key: String?, forwardingCurve25519Chain: [String], shieldState: ShieldState) {
        self.clearEvent = clearEvent
        self.senderCurve25519Key = senderCurve25519Key
        self.claimedEd25519Key = claimedEd25519Key
        self.forwardingCurve25519Chain = forwardingCurve25519Chain
        self.shieldState = shieldState
    }
}


extension DecryptedEvent: Equatable, Hashable {
    public static func ==(lhs: DecryptedEvent, rhs: DecryptedEvent) -> Bool {
        if lhs.clearEvent != rhs.clearEvent {
            return false
        }
        if lhs.senderCurve25519Key != rhs.senderCurve25519Key {
            return false
        }
        if lhs.claimedEd25519Key != rhs.claimedEd25519Key {
            return false
        }
        if lhs.forwardingCurve25519Chain != rhs.forwardingCurve25519Chain {
            return false
        }
        if lhs.shieldState != rhs.shieldState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clearEvent)
        hasher.combine(senderCurve25519Key)
        hasher.combine(claimedEd25519Key)
        hasher.combine(forwardingCurve25519Chain)
        hasher.combine(shieldState)
    }
}


public struct FfiConverterTypeDecryptedEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptedEvent {
        return try DecryptedEvent(
            clearEvent: FfiConverterString.read(from: &buf), 
            senderCurve25519Key: FfiConverterString.read(from: &buf), 
            claimedEd25519Key: FfiConverterOptionString.read(from: &buf), 
            forwardingCurve25519Chain: FfiConverterSequenceString.read(from: &buf), 
            shieldState: FfiConverterTypeShieldState.read(from: &buf)
        )
    }

    public static func write(_ value: DecryptedEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.clearEvent, into: &buf)
        FfiConverterString.write(value.senderCurve25519Key, into: &buf)
        FfiConverterOptionString.write(value.claimedEd25519Key, into: &buf)
        FfiConverterSequenceString.write(value.forwardingCurve25519Chain, into: &buf)
        FfiConverterTypeShieldState.write(value.shieldState, into: &buf)
    }
}


public func FfiConverterTypeDecryptedEvent_lift(_ buf: RustBuffer) throws -> DecryptedEvent {
    return try FfiConverterTypeDecryptedEvent.lift(buf)
}

public func FfiConverterTypeDecryptedEvent_lower(_ value: DecryptedEvent) -> RustBuffer {
    return FfiConverterTypeDecryptedEvent.lower(value)
}


public struct Device {
    public var userId: String
    public var deviceId: String
    public var keys: [String: String]
    public var algorithms: [String]
    public var displayName: String?
    public var isBlocked: Bool
    public var locallyTrusted: Bool
    public var crossSigningTrusted: Bool
    public var firstTimeSeenTs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, deviceId: String, keys: [String: String], algorithms: [String], displayName: String?, isBlocked: Bool, locallyTrusted: Bool, crossSigningTrusted: Bool, firstTimeSeenTs: UInt64) {
        self.userId = userId
        self.deviceId = deviceId
        self.keys = keys
        self.algorithms = algorithms
        self.displayName = displayName
        self.isBlocked = isBlocked
        self.locallyTrusted = locallyTrusted
        self.crossSigningTrusted = crossSigningTrusted
        self.firstTimeSeenTs = firstTimeSeenTs
    }
}


extension Device: Equatable, Hashable {
    public static func ==(lhs: Device, rhs: Device) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        if lhs.algorithms != rhs.algorithms {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.isBlocked != rhs.isBlocked {
            return false
        }
        if lhs.locallyTrusted != rhs.locallyTrusted {
            return false
        }
        if lhs.crossSigningTrusted != rhs.crossSigningTrusted {
            return false
        }
        if lhs.firstTimeSeenTs != rhs.firstTimeSeenTs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(keys)
        hasher.combine(algorithms)
        hasher.combine(displayName)
        hasher.combine(isBlocked)
        hasher.combine(locallyTrusted)
        hasher.combine(crossSigningTrusted)
        hasher.combine(firstTimeSeenTs)
    }
}


public struct FfiConverterTypeDevice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Device {
        return try Device(
            userId: FfiConverterString.read(from: &buf), 
            deviceId: FfiConverterString.read(from: &buf), 
            keys: FfiConverterDictionaryStringString.read(from: &buf), 
            algorithms: FfiConverterSequenceString.read(from: &buf), 
            displayName: FfiConverterOptionString.read(from: &buf), 
            isBlocked: FfiConverterBool.read(from: &buf), 
            locallyTrusted: FfiConverterBool.read(from: &buf), 
            crossSigningTrusted: FfiConverterBool.read(from: &buf), 
            firstTimeSeenTs: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Device, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterDictionaryStringString.write(value.keys, into: &buf)
        FfiConverterSequenceString.write(value.algorithms, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterBool.write(value.isBlocked, into: &buf)
        FfiConverterBool.write(value.locallyTrusted, into: &buf)
        FfiConverterBool.write(value.crossSigningTrusted, into: &buf)
        FfiConverterUInt64.write(value.firstTimeSeenTs, into: &buf)
    }
}


public func FfiConverterTypeDevice_lift(_ buf: RustBuffer) throws -> Device {
    return try FfiConverterTypeDevice.lift(buf)
}

public func FfiConverterTypeDevice_lower(_ value: Device) -> RustBuffer {
    return FfiConverterTypeDevice.lower(value)
}


public struct DeviceLists {
    public var changed: [String]
    public var left: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(changed: [String], left: [String]) {
        self.changed = changed
        self.left = left
    }
}


extension DeviceLists: Equatable, Hashable {
    public static func ==(lhs: DeviceLists, rhs: DeviceLists) -> Bool {
        if lhs.changed != rhs.changed {
            return false
        }
        if lhs.left != rhs.left {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(changed)
        hasher.combine(left)
    }
}


public struct FfiConverterTypeDeviceLists: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceLists {
        return try DeviceLists(
            changed: FfiConverterSequenceString.read(from: &buf), 
            left: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceLists, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.changed, into: &buf)
        FfiConverterSequenceString.write(value.left, into: &buf)
    }
}


public func FfiConverterTypeDeviceLists_lift(_ buf: RustBuffer) throws -> DeviceLists {
    return try FfiConverterTypeDeviceLists.lift(buf)
}

public func FfiConverterTypeDeviceLists_lower(_ value: DeviceLists) -> RustBuffer {
    return FfiConverterTypeDeviceLists.lower(value)
}


public struct EncryptionSettings {
    public var algorithm: EventEncryptionAlgorithm
    public var rotationPeriod: UInt64
    public var rotationPeriodMsgs: UInt64
    public var historyVisibility: HistoryVisibility
    public var onlyAllowTrustedDevices: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(algorithm: EventEncryptionAlgorithm, rotationPeriod: UInt64, rotationPeriodMsgs: UInt64, historyVisibility: HistoryVisibility, onlyAllowTrustedDevices: Bool) {
        self.algorithm = algorithm
        self.rotationPeriod = rotationPeriod
        self.rotationPeriodMsgs = rotationPeriodMsgs
        self.historyVisibility = historyVisibility
        self.onlyAllowTrustedDevices = onlyAllowTrustedDevices
    }
}


extension EncryptionSettings: Equatable, Hashable {
    public static func ==(lhs: EncryptionSettings, rhs: EncryptionSettings) -> Bool {
        if lhs.algorithm != rhs.algorithm {
            return false
        }
        if lhs.rotationPeriod != rhs.rotationPeriod {
            return false
        }
        if lhs.rotationPeriodMsgs != rhs.rotationPeriodMsgs {
            return false
        }
        if lhs.historyVisibility != rhs.historyVisibility {
            return false
        }
        if lhs.onlyAllowTrustedDevices != rhs.onlyAllowTrustedDevices {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(algorithm)
        hasher.combine(rotationPeriod)
        hasher.combine(rotationPeriodMsgs)
        hasher.combine(historyVisibility)
        hasher.combine(onlyAllowTrustedDevices)
    }
}


public struct FfiConverterTypeEncryptionSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionSettings {
        return try EncryptionSettings(
            algorithm: FfiConverterTypeEventEncryptionAlgorithm.read(from: &buf), 
            rotationPeriod: FfiConverterUInt64.read(from: &buf), 
            rotationPeriodMsgs: FfiConverterUInt64.read(from: &buf), 
            historyVisibility: FfiConverterTypeHistoryVisibility.read(from: &buf), 
            onlyAllowTrustedDevices: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptionSettings, into buf: inout [UInt8]) {
        FfiConverterTypeEventEncryptionAlgorithm.write(value.algorithm, into: &buf)
        FfiConverterUInt64.write(value.rotationPeriod, into: &buf)
        FfiConverterUInt64.write(value.rotationPeriodMsgs, into: &buf)
        FfiConverterTypeHistoryVisibility.write(value.historyVisibility, into: &buf)
        FfiConverterBool.write(value.onlyAllowTrustedDevices, into: &buf)
    }
}


public func FfiConverterTypeEncryptionSettings_lift(_ buf: RustBuffer) throws -> EncryptionSettings {
    return try FfiConverterTypeEncryptionSettings.lift(buf)
}

public func FfiConverterTypeEncryptionSettings_lower(_ value: EncryptionSettings) -> RustBuffer {
    return FfiConverterTypeEncryptionSettings.lower(value)
}


public struct KeyRequestPair {
    public var cancellation: Request?
    public var keyRequest: Request

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cancellation: Request?, keyRequest: Request) {
        self.cancellation = cancellation
        self.keyRequest = keyRequest
    }
}


extension KeyRequestPair: Equatable, Hashable {
    public static func ==(lhs: KeyRequestPair, rhs: KeyRequestPair) -> Bool {
        if lhs.cancellation != rhs.cancellation {
            return false
        }
        if lhs.keyRequest != rhs.keyRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cancellation)
        hasher.combine(keyRequest)
    }
}


public struct FfiConverterTypeKeyRequestPair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyRequestPair {
        return try KeyRequestPair(
            cancellation: FfiConverterOptionTypeRequest.read(from: &buf), 
            keyRequest: FfiConverterTypeRequest.read(from: &buf)
        )
    }

    public static func write(_ value: KeyRequestPair, into buf: inout [UInt8]) {
        FfiConverterOptionTypeRequest.write(value.cancellation, into: &buf)
        FfiConverterTypeRequest.write(value.keyRequest, into: &buf)
    }
}


public func FfiConverterTypeKeyRequestPair_lift(_ buf: RustBuffer) throws -> KeyRequestPair {
    return try FfiConverterTypeKeyRequestPair.lift(buf)
}

public func FfiConverterTypeKeyRequestPair_lower(_ value: KeyRequestPair) -> RustBuffer {
    return FfiConverterTypeKeyRequestPair.lower(value)
}


public struct KeysImportResult {
    public var imported: Int64
    public var total: Int64
    public var keys: [String: [String: [String]]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(imported: Int64, total: Int64, keys: [String: [String: [String]]]) {
        self.imported = imported
        self.total = total
        self.keys = keys
    }
}


extension KeysImportResult: Equatable, Hashable {
    public static func ==(lhs: KeysImportResult, rhs: KeysImportResult) -> Bool {
        if lhs.imported != rhs.imported {
            return false
        }
        if lhs.total != rhs.total {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(imported)
        hasher.combine(total)
        hasher.combine(keys)
    }
}


public struct FfiConverterTypeKeysImportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeysImportResult {
        return try KeysImportResult(
            imported: FfiConverterInt64.read(from: &buf), 
            total: FfiConverterInt64.read(from: &buf), 
            keys: FfiConverterDictionaryStringDictionaryStringSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: KeysImportResult, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.imported, into: &buf)
        FfiConverterInt64.write(value.total, into: &buf)
        FfiConverterDictionaryStringDictionaryStringSequenceString.write(value.keys, into: &buf)
    }
}


public func FfiConverterTypeKeysImportResult_lift(_ buf: RustBuffer) throws -> KeysImportResult {
    return try FfiConverterTypeKeysImportResult.lift(buf)
}

public func FfiConverterTypeKeysImportResult_lower(_ value: KeysImportResult) -> RustBuffer {
    return FfiConverterTypeKeysImportResult.lower(value)
}


public struct MegolmV1BackupKey {
    public var publicKey: String
    public var signatures: [String: [String: String]]
    public var passphraseInfo: PassphraseInfo?
    public var backupAlgorithm: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: String, signatures: [String: [String: String]], passphraseInfo: PassphraseInfo?, backupAlgorithm: String) {
        self.publicKey = publicKey
        self.signatures = signatures
        self.passphraseInfo = passphraseInfo
        self.backupAlgorithm = backupAlgorithm
    }
}


extension MegolmV1BackupKey: Equatable, Hashable {
    public static func ==(lhs: MegolmV1BackupKey, rhs: MegolmV1BackupKey) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.signatures != rhs.signatures {
            return false
        }
        if lhs.passphraseInfo != rhs.passphraseInfo {
            return false
        }
        if lhs.backupAlgorithm != rhs.backupAlgorithm {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(signatures)
        hasher.combine(passphraseInfo)
        hasher.combine(backupAlgorithm)
    }
}


public struct FfiConverterTypeMegolmV1BackupKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MegolmV1BackupKey {
        return try MegolmV1BackupKey(
            publicKey: FfiConverterString.read(from: &buf), 
            signatures: FfiConverterDictionaryStringDictionaryStringString.read(from: &buf), 
            passphraseInfo: FfiConverterOptionTypePassphraseInfo.read(from: &buf), 
            backupAlgorithm: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MegolmV1BackupKey, into buf: inout [UInt8]) {
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterDictionaryStringDictionaryStringString.write(value.signatures, into: &buf)
        FfiConverterOptionTypePassphraseInfo.write(value.passphraseInfo, into: &buf)
        FfiConverterString.write(value.backupAlgorithm, into: &buf)
    }
}


public func FfiConverterTypeMegolmV1BackupKey_lift(_ buf: RustBuffer) throws -> MegolmV1BackupKey {
    return try FfiConverterTypeMegolmV1BackupKey.lift(buf)
}

public func FfiConverterTypeMegolmV1BackupKey_lower(_ value: MegolmV1BackupKey) -> RustBuffer {
    return FfiConverterTypeMegolmV1BackupKey.lower(value)
}


public struct MigrationData {
    public var account: PickledAccount
    public var sessions: [PickledSession]
    public var inboundGroupSessions: [PickledInboundGroupSession]
    public var pickleKey: Data
    public var backupVersion: String?
    public var backupRecoveryKey: String?
    public var crossSigning: CrossSigningKeyExport
    public var trackedUsers: [String]
    public var roomSettings: [String: RoomSettings]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(account: PickledAccount, sessions: [PickledSession], inboundGroupSessions: [PickledInboundGroupSession], pickleKey: Data, backupVersion: String?, backupRecoveryKey: String?, crossSigning: CrossSigningKeyExport, trackedUsers: [String], roomSettings: [String: RoomSettings]) {
        self.account = account
        self.sessions = sessions
        self.inboundGroupSessions = inboundGroupSessions
        self.pickleKey = pickleKey
        self.backupVersion = backupVersion
        self.backupRecoveryKey = backupRecoveryKey
        self.crossSigning = crossSigning
        self.trackedUsers = trackedUsers
        self.roomSettings = roomSettings
    }
}


extension MigrationData: Equatable, Hashable {
    public static func ==(lhs: MigrationData, rhs: MigrationData) -> Bool {
        if lhs.account != rhs.account {
            return false
        }
        if lhs.sessions != rhs.sessions {
            return false
        }
        if lhs.inboundGroupSessions != rhs.inboundGroupSessions {
            return false
        }
        if lhs.pickleKey != rhs.pickleKey {
            return false
        }
        if lhs.backupVersion != rhs.backupVersion {
            return false
        }
        if lhs.backupRecoveryKey != rhs.backupRecoveryKey {
            return false
        }
        if lhs.crossSigning != rhs.crossSigning {
            return false
        }
        if lhs.trackedUsers != rhs.trackedUsers {
            return false
        }
        if lhs.roomSettings != rhs.roomSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(account)
        hasher.combine(sessions)
        hasher.combine(inboundGroupSessions)
        hasher.combine(pickleKey)
        hasher.combine(backupVersion)
        hasher.combine(backupRecoveryKey)
        hasher.combine(crossSigning)
        hasher.combine(trackedUsers)
        hasher.combine(roomSettings)
    }
}


public struct FfiConverterTypeMigrationData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MigrationData {
        return try MigrationData(
            account: FfiConverterTypePickledAccount.read(from: &buf), 
            sessions: FfiConverterSequenceTypePickledSession.read(from: &buf), 
            inboundGroupSessions: FfiConverterSequenceTypePickledInboundGroupSession.read(from: &buf), 
            pickleKey: FfiConverterData.read(from: &buf), 
            backupVersion: FfiConverterOptionString.read(from: &buf), 
            backupRecoveryKey: FfiConverterOptionString.read(from: &buf), 
            crossSigning: FfiConverterTypeCrossSigningKeyExport.read(from: &buf), 
            trackedUsers: FfiConverterSequenceString.read(from: &buf), 
            roomSettings: FfiConverterDictionaryStringTypeRoomSettings.read(from: &buf)
        )
    }

    public static func write(_ value: MigrationData, into buf: inout [UInt8]) {
        FfiConverterTypePickledAccount.write(value.account, into: &buf)
        FfiConverterSequenceTypePickledSession.write(value.sessions, into: &buf)
        FfiConverterSequenceTypePickledInboundGroupSession.write(value.inboundGroupSessions, into: &buf)
        FfiConverterData.write(value.pickleKey, into: &buf)
        FfiConverterOptionString.write(value.backupVersion, into: &buf)
        FfiConverterOptionString.write(value.backupRecoveryKey, into: &buf)
        FfiConverterTypeCrossSigningKeyExport.write(value.crossSigning, into: &buf)
        FfiConverterSequenceString.write(value.trackedUsers, into: &buf)
        FfiConverterDictionaryStringTypeRoomSettings.write(value.roomSettings, into: &buf)
    }
}


public func FfiConverterTypeMigrationData_lift(_ buf: RustBuffer) throws -> MigrationData {
    return try FfiConverterTypeMigrationData.lift(buf)
}

public func FfiConverterTypeMigrationData_lower(_ value: MigrationData) -> RustBuffer {
    return FfiConverterTypeMigrationData.lower(value)
}


public struct PassphraseInfo {
    public var privateKeySalt: String
    public var privateKeyIterations: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(privateKeySalt: String, privateKeyIterations: Int32) {
        self.privateKeySalt = privateKeySalt
        self.privateKeyIterations = privateKeyIterations
    }
}


extension PassphraseInfo: Equatable, Hashable {
    public static func ==(lhs: PassphraseInfo, rhs: PassphraseInfo) -> Bool {
        if lhs.privateKeySalt != rhs.privateKeySalt {
            return false
        }
        if lhs.privateKeyIterations != rhs.privateKeyIterations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(privateKeySalt)
        hasher.combine(privateKeyIterations)
    }
}


public struct FfiConverterTypePassphraseInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PassphraseInfo {
        return try PassphraseInfo(
            privateKeySalt: FfiConverterString.read(from: &buf), 
            privateKeyIterations: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PassphraseInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.privateKeySalt, into: &buf)
        FfiConverterInt32.write(value.privateKeyIterations, into: &buf)
    }
}


public func FfiConverterTypePassphraseInfo_lift(_ buf: RustBuffer) throws -> PassphraseInfo {
    return try FfiConverterTypePassphraseInfo.lift(buf)
}

public func FfiConverterTypePassphraseInfo_lower(_ value: PassphraseInfo) -> RustBuffer {
    return FfiConverterTypePassphraseInfo.lower(value)
}


public struct PickledAccount {
    public var userId: String
    public var deviceId: String
    public var pickle: String
    public var shared: Bool
    public var uploadedSignedKeyCount: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, deviceId: String, pickle: String, shared: Bool, uploadedSignedKeyCount: Int64) {
        self.userId = userId
        self.deviceId = deviceId
        self.pickle = pickle
        self.shared = shared
        self.uploadedSignedKeyCount = uploadedSignedKeyCount
    }
}


extension PickledAccount: Equatable, Hashable {
    public static func ==(lhs: PickledAccount, rhs: PickledAccount) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.shared != rhs.shared {
            return false
        }
        if lhs.uploadedSignedKeyCount != rhs.uploadedSignedKeyCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(pickle)
        hasher.combine(shared)
        hasher.combine(uploadedSignedKeyCount)
    }
}


public struct FfiConverterTypePickledAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledAccount {
        return try PickledAccount(
            userId: FfiConverterString.read(from: &buf), 
            deviceId: FfiConverterString.read(from: &buf), 
            pickle: FfiConverterString.read(from: &buf), 
            shared: FfiConverterBool.read(from: &buf), 
            uploadedSignedKeyCount: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PickledAccount, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterString.write(value.pickle, into: &buf)
        FfiConverterBool.write(value.shared, into: &buf)
        FfiConverterInt64.write(value.uploadedSignedKeyCount, into: &buf)
    }
}


public func FfiConverterTypePickledAccount_lift(_ buf: RustBuffer) throws -> PickledAccount {
    return try FfiConverterTypePickledAccount.lift(buf)
}

public func FfiConverterTypePickledAccount_lower(_ value: PickledAccount) -> RustBuffer {
    return FfiConverterTypePickledAccount.lower(value)
}


public struct PickledInboundGroupSession {
    public var pickle: String
    public var senderKey: String
    public var signingKey: [String: String]
    public var roomId: String
    public var forwardingChains: [String]
    public var imported: Bool
    public var backedUp: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pickle: String, senderKey: String, signingKey: [String: String], roomId: String, forwardingChains: [String], imported: Bool, backedUp: Bool) {
        self.pickle = pickle
        self.senderKey = senderKey
        self.signingKey = signingKey
        self.roomId = roomId
        self.forwardingChains = forwardingChains
        self.imported = imported
        self.backedUp = backedUp
    }
}


extension PickledInboundGroupSession: Equatable, Hashable {
    public static func ==(lhs: PickledInboundGroupSession, rhs: PickledInboundGroupSession) -> Bool {
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.senderKey != rhs.senderKey {
            return false
        }
        if lhs.signingKey != rhs.signingKey {
            return false
        }
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.forwardingChains != rhs.forwardingChains {
            return false
        }
        if lhs.imported != rhs.imported {
            return false
        }
        if lhs.backedUp != rhs.backedUp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pickle)
        hasher.combine(senderKey)
        hasher.combine(signingKey)
        hasher.combine(roomId)
        hasher.combine(forwardingChains)
        hasher.combine(imported)
        hasher.combine(backedUp)
    }
}


public struct FfiConverterTypePickledInboundGroupSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledInboundGroupSession {
        return try PickledInboundGroupSession(
            pickle: FfiConverterString.read(from: &buf), 
            senderKey: FfiConverterString.read(from: &buf), 
            signingKey: FfiConverterDictionaryStringString.read(from: &buf), 
            roomId: FfiConverterString.read(from: &buf), 
            forwardingChains: FfiConverterSequenceString.read(from: &buf), 
            imported: FfiConverterBool.read(from: &buf), 
            backedUp: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PickledInboundGroupSession, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pickle, into: &buf)
        FfiConverterString.write(value.senderKey, into: &buf)
        FfiConverterDictionaryStringString.write(value.signingKey, into: &buf)
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterSequenceString.write(value.forwardingChains, into: &buf)
        FfiConverterBool.write(value.imported, into: &buf)
        FfiConverterBool.write(value.backedUp, into: &buf)
    }
}


public func FfiConverterTypePickledInboundGroupSession_lift(_ buf: RustBuffer) throws -> PickledInboundGroupSession {
    return try FfiConverterTypePickledInboundGroupSession.lift(buf)
}

public func FfiConverterTypePickledInboundGroupSession_lower(_ value: PickledInboundGroupSession) -> RustBuffer {
    return FfiConverterTypePickledInboundGroupSession.lower(value)
}


public struct PickledSession {
    public var pickle: String
    public var senderKey: String
    public var createdUsingFallbackKey: Bool
    public var creationTime: String
    public var lastUseTime: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pickle: String, senderKey: String, createdUsingFallbackKey: Bool, creationTime: String, lastUseTime: String) {
        self.pickle = pickle
        self.senderKey = senderKey
        self.createdUsingFallbackKey = createdUsingFallbackKey
        self.creationTime = creationTime
        self.lastUseTime = lastUseTime
    }
}


extension PickledSession: Equatable, Hashable {
    public static func ==(lhs: PickledSession, rhs: PickledSession) -> Bool {
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.senderKey != rhs.senderKey {
            return false
        }
        if lhs.createdUsingFallbackKey != rhs.createdUsingFallbackKey {
            return false
        }
        if lhs.creationTime != rhs.creationTime {
            return false
        }
        if lhs.lastUseTime != rhs.lastUseTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pickle)
        hasher.combine(senderKey)
        hasher.combine(createdUsingFallbackKey)
        hasher.combine(creationTime)
        hasher.combine(lastUseTime)
    }
}


public struct FfiConverterTypePickledSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledSession {
        return try PickledSession(
            pickle: FfiConverterString.read(from: &buf), 
            senderKey: FfiConverterString.read(from: &buf), 
            createdUsingFallbackKey: FfiConverterBool.read(from: &buf), 
            creationTime: FfiConverterString.read(from: &buf), 
            lastUseTime: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PickledSession, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pickle, into: &buf)
        FfiConverterString.write(value.senderKey, into: &buf)
        FfiConverterBool.write(value.createdUsingFallbackKey, into: &buf)
        FfiConverterString.write(value.creationTime, into: &buf)
        FfiConverterString.write(value.lastUseTime, into: &buf)
    }
}


public func FfiConverterTypePickledSession_lift(_ buf: RustBuffer) throws -> PickledSession {
    return try FfiConverterTypePickledSession.lift(buf)
}

public func FfiConverterTypePickledSession_lower(_ value: PickledSession) -> RustBuffer {
    return FfiConverterTypePickledSession.lower(value)
}


public struct RequestVerificationResult {
    public var verification: VerificationRequest
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(verification: VerificationRequest, request: OutgoingVerificationRequest) {
        self.verification = verification
        self.request = request
    }
}



public struct FfiConverterTypeRequestVerificationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestVerificationResult {
        return try RequestVerificationResult(
            verification: FfiConverterTypeVerificationRequest.read(from: &buf), 
            request: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: RequestVerificationResult, into buf: inout [UInt8]) {
        FfiConverterTypeVerificationRequest.write(value.verification, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.request, into: &buf)
    }
}


public func FfiConverterTypeRequestVerificationResult_lift(_ buf: RustBuffer) throws -> RequestVerificationResult {
    return try FfiConverterTypeRequestVerificationResult.lift(buf)
}

public func FfiConverterTypeRequestVerificationResult_lower(_ value: RequestVerificationResult) -> RustBuffer {
    return FfiConverterTypeRequestVerificationResult.lower(value)
}


public struct RoomKeyCounts {
    public var total: Int64
    public var backedUp: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(total: Int64, backedUp: Int64) {
        self.total = total
        self.backedUp = backedUp
    }
}


extension RoomKeyCounts: Equatable, Hashable {
    public static func ==(lhs: RoomKeyCounts, rhs: RoomKeyCounts) -> Bool {
        if lhs.total != rhs.total {
            return false
        }
        if lhs.backedUp != rhs.backedUp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(total)
        hasher.combine(backedUp)
    }
}


public struct FfiConverterTypeRoomKeyCounts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomKeyCounts {
        return try RoomKeyCounts(
            total: FfiConverterInt64.read(from: &buf), 
            backedUp: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoomKeyCounts, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.total, into: &buf)
        FfiConverterInt64.write(value.backedUp, into: &buf)
    }
}


public func FfiConverterTypeRoomKeyCounts_lift(_ buf: RustBuffer) throws -> RoomKeyCounts {
    return try FfiConverterTypeRoomKeyCounts.lift(buf)
}

public func FfiConverterTypeRoomKeyCounts_lower(_ value: RoomKeyCounts) -> RustBuffer {
    return FfiConverterTypeRoomKeyCounts.lower(value)
}


public struct RoomKeyInfo {
    public var algorithm: String
    public var roomId: String
    public var senderKey: String
    public var sessionId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(algorithm: String, roomId: String, senderKey: String, sessionId: String) {
        self.algorithm = algorithm
        self.roomId = roomId
        self.senderKey = senderKey
        self.sessionId = sessionId
    }
}


extension RoomKeyInfo: Equatable, Hashable {
    public static func ==(lhs: RoomKeyInfo, rhs: RoomKeyInfo) -> Bool {
        if lhs.algorithm != rhs.algorithm {
            return false
        }
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.senderKey != rhs.senderKey {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(algorithm)
        hasher.combine(roomId)
        hasher.combine(senderKey)
        hasher.combine(sessionId)
    }
}


public struct FfiConverterTypeRoomKeyInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomKeyInfo {
        return try RoomKeyInfo(
            algorithm: FfiConverterString.read(from: &buf), 
            roomId: FfiConverterString.read(from: &buf), 
            senderKey: FfiConverterString.read(from: &buf), 
            sessionId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RoomKeyInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.algorithm, into: &buf)
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterString.write(value.senderKey, into: &buf)
        FfiConverterString.write(value.sessionId, into: &buf)
    }
}


public func FfiConverterTypeRoomKeyInfo_lift(_ buf: RustBuffer) throws -> RoomKeyInfo {
    return try FfiConverterTypeRoomKeyInfo.lift(buf)
}

public func FfiConverterTypeRoomKeyInfo_lower(_ value: RoomKeyInfo) -> RustBuffer {
    return FfiConverterTypeRoomKeyInfo.lower(value)
}


public struct RoomSettings {
    public var algorithm: EventEncryptionAlgorithm
    public var onlyAllowTrustedDevices: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(algorithm: EventEncryptionAlgorithm, onlyAllowTrustedDevices: Bool) {
        self.algorithm = algorithm
        self.onlyAllowTrustedDevices = onlyAllowTrustedDevices
    }
}


extension RoomSettings: Equatable, Hashable {
    public static func ==(lhs: RoomSettings, rhs: RoomSettings) -> Bool {
        if lhs.algorithm != rhs.algorithm {
            return false
        }
        if lhs.onlyAllowTrustedDevices != rhs.onlyAllowTrustedDevices {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(algorithm)
        hasher.combine(onlyAllowTrustedDevices)
    }
}


public struct FfiConverterTypeRoomSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomSettings {
        return try RoomSettings(
            algorithm: FfiConverterTypeEventEncryptionAlgorithm.read(from: &buf), 
            onlyAllowTrustedDevices: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RoomSettings, into buf: inout [UInt8]) {
        FfiConverterTypeEventEncryptionAlgorithm.write(value.algorithm, into: &buf)
        FfiConverterBool.write(value.onlyAllowTrustedDevices, into: &buf)
    }
}


public func FfiConverterTypeRoomSettings_lift(_ buf: RustBuffer) throws -> RoomSettings {
    return try FfiConverterTypeRoomSettings.lift(buf)
}

public func FfiConverterTypeRoomSettings_lower(_ value: RoomSettings) -> RustBuffer {
    return FfiConverterTypeRoomSettings.lower(value)
}


public struct ScanResult {
    public var qr: QrCode
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(qr: QrCode, request: OutgoingVerificationRequest) {
        self.qr = qr
        self.request = request
    }
}



public struct FfiConverterTypeScanResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanResult {
        return try ScanResult(
            qr: FfiConverterTypeQrCode.read(from: &buf), 
            request: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: ScanResult, into buf: inout [UInt8]) {
        FfiConverterTypeQrCode.write(value.qr, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.request, into: &buf)
    }
}


public func FfiConverterTypeScanResult_lift(_ buf: RustBuffer) throws -> ScanResult {
    return try FfiConverterTypeScanResult.lift(buf)
}

public func FfiConverterTypeScanResult_lower(_ value: ScanResult) -> RustBuffer {
    return FfiConverterTypeScanResult.lower(value)
}


public struct SessionMigrationData {
    public var userId: String
    public var deviceId: String
    public var curve25519Key: String
    public var ed25519Key: String
    public var sessions: [PickledSession]
    public var inboundGroupSessions: [PickledInboundGroupSession]
    public var pickleKey: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, deviceId: String, curve25519Key: String, ed25519Key: String, sessions: [PickledSession], inboundGroupSessions: [PickledInboundGroupSession], pickleKey: Data) {
        self.userId = userId
        self.deviceId = deviceId
        self.curve25519Key = curve25519Key
        self.ed25519Key = ed25519Key
        self.sessions = sessions
        self.inboundGroupSessions = inboundGroupSessions
        self.pickleKey = pickleKey
    }
}


extension SessionMigrationData: Equatable, Hashable {
    public static func ==(lhs: SessionMigrationData, rhs: SessionMigrationData) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.curve25519Key != rhs.curve25519Key {
            return false
        }
        if lhs.ed25519Key != rhs.ed25519Key {
            return false
        }
        if lhs.sessions != rhs.sessions {
            return false
        }
        if lhs.inboundGroupSessions != rhs.inboundGroupSessions {
            return false
        }
        if lhs.pickleKey != rhs.pickleKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(curve25519Key)
        hasher.combine(ed25519Key)
        hasher.combine(sessions)
        hasher.combine(inboundGroupSessions)
        hasher.combine(pickleKey)
    }
}


public struct FfiConverterTypeSessionMigrationData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionMigrationData {
        return try SessionMigrationData(
            userId: FfiConverterString.read(from: &buf), 
            deviceId: FfiConverterString.read(from: &buf), 
            curve25519Key: FfiConverterString.read(from: &buf), 
            ed25519Key: FfiConverterString.read(from: &buf), 
            sessions: FfiConverterSequenceTypePickledSession.read(from: &buf), 
            inboundGroupSessions: FfiConverterSequenceTypePickledInboundGroupSession.read(from: &buf), 
            pickleKey: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SessionMigrationData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterString.write(value.curve25519Key, into: &buf)
        FfiConverterString.write(value.ed25519Key, into: &buf)
        FfiConverterSequenceTypePickledSession.write(value.sessions, into: &buf)
        FfiConverterSequenceTypePickledInboundGroupSession.write(value.inboundGroupSessions, into: &buf)
        FfiConverterData.write(value.pickleKey, into: &buf)
    }
}


public func FfiConverterTypeSessionMigrationData_lift(_ buf: RustBuffer) throws -> SessionMigrationData {
    return try FfiConverterTypeSessionMigrationData.lift(buf)
}

public func FfiConverterTypeSessionMigrationData_lower(_ value: SessionMigrationData) -> RustBuffer {
    return FfiConverterTypeSessionMigrationData.lower(value)
}


public struct ShieldState {
    public var color: ShieldColor
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(color: ShieldColor, message: String?) {
        self.color = color
        self.message = message
    }
}


extension ShieldState: Equatable, Hashable {
    public static func ==(lhs: ShieldState, rhs: ShieldState) -> Bool {
        if lhs.color != rhs.color {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(color)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeShieldState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldState {
        return try ShieldState(
            color: FfiConverterTypeShieldColor.read(from: &buf), 
            message: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ShieldState, into buf: inout [UInt8]) {
        FfiConverterTypeShieldColor.write(value.color, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeShieldState_lift(_ buf: RustBuffer) throws -> ShieldState {
    return try FfiConverterTypeShieldState.lift(buf)
}

public func FfiConverterTypeShieldState_lower(_ value: ShieldState) -> RustBuffer {
    return FfiConverterTypeShieldState.lower(value)
}


public struct SignatureUploadRequest {
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String) {
        self.body = body
    }
}


extension SignatureUploadRequest: Equatable, Hashable {
    public static func ==(lhs: SignatureUploadRequest, rhs: SignatureUploadRequest) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
    }
}


public struct FfiConverterTypeSignatureUploadRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureUploadRequest {
        return try SignatureUploadRequest(
            body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureUploadRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeSignatureUploadRequest_lift(_ buf: RustBuffer) throws -> SignatureUploadRequest {
    return try FfiConverterTypeSignatureUploadRequest.lift(buf)
}

public func FfiConverterTypeSignatureUploadRequest_lower(_ value: SignatureUploadRequest) -> RustBuffer {
    return FfiConverterTypeSignatureUploadRequest.lower(value)
}


public struct SignatureVerification {
    public var deviceSignature: SignatureState
    public var userIdentitySignature: SignatureState
    public var otherDevicesSignatures: [String: SignatureState]
    public var trusted: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deviceSignature: SignatureState, userIdentitySignature: SignatureState, otherDevicesSignatures: [String: SignatureState], trusted: Bool) {
        self.deviceSignature = deviceSignature
        self.userIdentitySignature = userIdentitySignature
        self.otherDevicesSignatures = otherDevicesSignatures
        self.trusted = trusted
    }
}


extension SignatureVerification: Equatable, Hashable {
    public static func ==(lhs: SignatureVerification, rhs: SignatureVerification) -> Bool {
        if lhs.deviceSignature != rhs.deviceSignature {
            return false
        }
        if lhs.userIdentitySignature != rhs.userIdentitySignature {
            return false
        }
        if lhs.otherDevicesSignatures != rhs.otherDevicesSignatures {
            return false
        }
        if lhs.trusted != rhs.trusted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deviceSignature)
        hasher.combine(userIdentitySignature)
        hasher.combine(otherDevicesSignatures)
        hasher.combine(trusted)
    }
}


public struct FfiConverterTypeSignatureVerification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureVerification {
        return try SignatureVerification(
            deviceSignature: FfiConverterTypeSignatureState.read(from: &buf), 
            userIdentitySignature: FfiConverterTypeSignatureState.read(from: &buf), 
            otherDevicesSignatures: FfiConverterDictionaryStringTypeSignatureState.read(from: &buf), 
            trusted: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureVerification, into buf: inout [UInt8]) {
        FfiConverterTypeSignatureState.write(value.deviceSignature, into: &buf)
        FfiConverterTypeSignatureState.write(value.userIdentitySignature, into: &buf)
        FfiConverterDictionaryStringTypeSignatureState.write(value.otherDevicesSignatures, into: &buf)
        FfiConverterBool.write(value.trusted, into: &buf)
    }
}


public func FfiConverterTypeSignatureVerification_lift(_ buf: RustBuffer) throws -> SignatureVerification {
    return try FfiConverterTypeSignatureVerification.lift(buf)
}

public func FfiConverterTypeSignatureVerification_lower(_ value: SignatureVerification) -> RustBuffer {
    return FfiConverterTypeSignatureVerification.lower(value)
}


public struct StartSasResult {
    public var sas: Sas
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sas: Sas, request: OutgoingVerificationRequest) {
        self.sas = sas
        self.request = request
    }
}



public struct FfiConverterTypeStartSasResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StartSasResult {
        return try StartSasResult(
            sas: FfiConverterTypeSas.read(from: &buf), 
            request: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: StartSasResult, into buf: inout [UInt8]) {
        FfiConverterTypeSas.write(value.sas, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.request, into: &buf)
    }
}


public func FfiConverterTypeStartSasResult_lift(_ buf: RustBuffer) throws -> StartSasResult {
    return try FfiConverterTypeStartSasResult.lift(buf)
}

public func FfiConverterTypeStartSasResult_lower(_ value: StartSasResult) -> RustBuffer {
    return FfiConverterTypeStartSasResult.lower(value)
}


public struct SyncChangesResult {
    public var toDeviceEvents: [String]
    public var roomKeyInfos: [RoomKeyInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(toDeviceEvents: [String], roomKeyInfos: [RoomKeyInfo]) {
        self.toDeviceEvents = toDeviceEvents
        self.roomKeyInfos = roomKeyInfos
    }
}


extension SyncChangesResult: Equatable, Hashable {
    public static func ==(lhs: SyncChangesResult, rhs: SyncChangesResult) -> Bool {
        if lhs.toDeviceEvents != rhs.toDeviceEvents {
            return false
        }
        if lhs.roomKeyInfos != rhs.roomKeyInfos {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(toDeviceEvents)
        hasher.combine(roomKeyInfos)
    }
}


public struct FfiConverterTypeSyncChangesResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncChangesResult {
        return try SyncChangesResult(
            toDeviceEvents: FfiConverterSequenceString.read(from: &buf), 
            roomKeyInfos: FfiConverterSequenceTypeRoomKeyInfo.read(from: &buf)
        )
    }

    public static func write(_ value: SyncChangesResult, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.toDeviceEvents, into: &buf)
        FfiConverterSequenceTypeRoomKeyInfo.write(value.roomKeyInfos, into: &buf)
    }
}


public func FfiConverterTypeSyncChangesResult_lift(_ buf: RustBuffer) throws -> SyncChangesResult {
    return try FfiConverterTypeSyncChangesResult.lift(buf)
}

public func FfiConverterTypeSyncChangesResult_lower(_ value: SyncChangesResult) -> RustBuffer {
    return FfiConverterTypeSyncChangesResult.lower(value)
}


public struct UploadDehydratedDeviceRequest {
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String) {
        self.body = body
    }
}


extension UploadDehydratedDeviceRequest: Equatable, Hashable {
    public static func ==(lhs: UploadDehydratedDeviceRequest, rhs: UploadDehydratedDeviceRequest) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
    }
}


public struct FfiConverterTypeUploadDehydratedDeviceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadDehydratedDeviceRequest {
        return try UploadDehydratedDeviceRequest(
            body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UploadDehydratedDeviceRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeUploadDehydratedDeviceRequest_lift(_ buf: RustBuffer) throws -> UploadDehydratedDeviceRequest {
    return try FfiConverterTypeUploadDehydratedDeviceRequest.lift(buf)
}

public func FfiConverterTypeUploadDehydratedDeviceRequest_lower(_ value: UploadDehydratedDeviceRequest) -> RustBuffer {
    return FfiConverterTypeUploadDehydratedDeviceRequest.lower(value)
}


public struct UploadSigningKeysRequest {
    public var masterKey: String
    public var selfSigningKey: String
    public var userSigningKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(masterKey: String, selfSigningKey: String, userSigningKey: String) {
        self.masterKey = masterKey
        self.selfSigningKey = selfSigningKey
        self.userSigningKey = userSigningKey
    }
}


extension UploadSigningKeysRequest: Equatable, Hashable {
    public static func ==(lhs: UploadSigningKeysRequest, rhs: UploadSigningKeysRequest) -> Bool {
        if lhs.masterKey != rhs.masterKey {
            return false
        }
        if lhs.selfSigningKey != rhs.selfSigningKey {
            return false
        }
        if lhs.userSigningKey != rhs.userSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterKey)
        hasher.combine(selfSigningKey)
        hasher.combine(userSigningKey)
    }
}


public struct FfiConverterTypeUploadSigningKeysRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadSigningKeysRequest {
        return try UploadSigningKeysRequest(
            masterKey: FfiConverterString.read(from: &buf), 
            selfSigningKey: FfiConverterString.read(from: &buf), 
            userSigningKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UploadSigningKeysRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.masterKey, into: &buf)
        FfiConverterString.write(value.selfSigningKey, into: &buf)
        FfiConverterString.write(value.userSigningKey, into: &buf)
    }
}


public func FfiConverterTypeUploadSigningKeysRequest_lift(_ buf: RustBuffer) throws -> UploadSigningKeysRequest {
    return try FfiConverterTypeUploadSigningKeysRequest.lift(buf)
}

public func FfiConverterTypeUploadSigningKeysRequest_lower(_ value: UploadSigningKeysRequest) -> RustBuffer {
    return FfiConverterTypeUploadSigningKeysRequest.lower(value)
}


public struct VersionInfo {
    public var version: String
    public var vodozemacVersion: String
    public var gitSha: String
    public var gitDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: String, vodozemacVersion: String, gitSha: String, gitDescription: String) {
        self.version = version
        self.vodozemacVersion = vodozemacVersion
        self.gitSha = gitSha
        self.gitDescription = gitDescription
    }
}


extension VersionInfo: Equatable, Hashable {
    public static func ==(lhs: VersionInfo, rhs: VersionInfo) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.vodozemacVersion != rhs.vodozemacVersion {
            return false
        }
        if lhs.gitSha != rhs.gitSha {
            return false
        }
        if lhs.gitDescription != rhs.gitDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(vodozemacVersion)
        hasher.combine(gitSha)
        hasher.combine(gitDescription)
    }
}


public struct FfiConverterTypeVersionInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VersionInfo {
        return try VersionInfo(
            version: FfiConverterString.read(from: &buf), 
            vodozemacVersion: FfiConverterString.read(from: &buf), 
            gitSha: FfiConverterString.read(from: &buf), 
            gitDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: VersionInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterString.write(value.vodozemacVersion, into: &buf)
        FfiConverterString.write(value.gitSha, into: &buf)
        FfiConverterString.write(value.gitDescription, into: &buf)
    }
}


public func FfiConverterTypeVersionInfo_lift(_ buf: RustBuffer) throws -> VersionInfo {
    return try FfiConverterTypeVersionInfo.lift(buf)
}

public func FfiConverterTypeVersionInfo_lower(_ value: VersionInfo) -> RustBuffer {
    return FfiConverterTypeVersionInfo.lower(value)
}

public enum CryptoStoreError {

    
    
    // Simple error enums only carry a message
    case OpenStore(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case OlmError(message: String)
    
    // Simple error enums only carry a message
    case Serialization(message: String)
    
    // Simple error enums only carry a message
    case InvalidUserId(message: String)
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeCryptoStoreError.lift(error)
    }
}


public struct FfiConverterTypeCryptoStoreError: FfiConverterRustBuffer {
    typealias SwiftType = CryptoStoreError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CryptoStoreError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .OpenStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .OlmError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Serialization(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidUserId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .Identifier(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CryptoStoreError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .OpenStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .OlmError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Serialization(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidUserId(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .Identifier(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))

        
        }
    }
}


extension CryptoStoreError: Equatable, Hashable {}

extension CryptoStoreError: Error { }

public enum DecodeError {

    
    
    // Simple error enums only carry a message
    case Decode(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeDecodeError.lift(error)
    }
}


public struct FfiConverterTypeDecodeError: FfiConverterRustBuffer {
    typealias SwiftType = DecodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Decode(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodeError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Decode(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


extension DecodeError: Equatable, Hashable {}

extension DecodeError: Error { }

public enum DecryptionError {

    
    
    case Serialization(error: String)
    case Identifier(error: String)
    case Megolm(error: String)
    case MissingRoomKey(error: String, withheldCode: String?)
    case Store(error: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeDecryptionError.lift(error)
    }
}


public struct FfiConverterTypeDecryptionError: FfiConverterRustBuffer {
    typealias SwiftType = DecryptionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Serialization(
            error: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Identifier(
            error: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Megolm(
            error: try FfiConverterString.read(from: &buf)
            )
        case 4: return .MissingRoomKey(
            error: try FfiConverterString.read(from: &buf), 
            withheldCode: try FfiConverterOptionString.read(from: &buf)
            )
        case 5: return .Store(
            error: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecryptionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Serialization(error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .Identifier(error):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .Megolm(error):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .MissingRoomKey(error,withheldCode):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(error, into: &buf)
            FfiConverterOptionString.write(withheldCode, into: &buf)
            
        
        case let .Store(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


extension DecryptionError: Equatable, Hashable {}

extension DecryptionError: Error { }

public enum DehydrationError {

    
    
    // Simple error enums only carry a message
    case Pickle(message: String)
    
    // Simple error enums only carry a message
    case MissingSigningKey(message: String)
    
    // Simple error enums only carry a message
    case Json(message: String)
    
    // Simple error enums only carry a message
    case Store(message: String)
    
    // Simple error enums only carry a message
    case PickleKeyLength(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeDehydrationError.lift(error)
    }
}


public struct FfiConverterTypeDehydrationError: FfiConverterRustBuffer {
    typealias SwiftType = DehydrationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DehydrationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Pickle(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .MissingSigningKey(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Json(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Store(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .PickleKeyLength(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DehydrationError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Pickle(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .MissingSigningKey(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Json(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Store(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .PickleKeyLength(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


extension DehydrationError: Equatable, Hashable {}

extension DehydrationError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventEncryptionAlgorithm {
    
    case olmV1Curve25519AesSha2
    case megolmV1AesSha2
}

public struct FfiConverterTypeEventEncryptionAlgorithm: FfiConverterRustBuffer {
    typealias SwiftType = EventEncryptionAlgorithm

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventEncryptionAlgorithm {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .olmV1Curve25519AesSha2
        
        case 2: return .megolmV1AesSha2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventEncryptionAlgorithm, into buf: inout [UInt8]) {
        switch value {
        
        
        case .olmV1Curve25519AesSha2:
            writeInt(&buf, Int32(1))
        
        
        case .megolmV1AesSha2:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeEventEncryptionAlgorithm_lift(_ buf: RustBuffer) throws -> EventEncryptionAlgorithm {
    return try FfiConverterTypeEventEncryptionAlgorithm.lift(buf)
}

public func FfiConverterTypeEventEncryptionAlgorithm_lower(_ value: EventEncryptionAlgorithm) -> RustBuffer {
    return FfiConverterTypeEventEncryptionAlgorithm.lower(value)
}


extension EventEncryptionAlgorithm: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum HistoryVisibility {
    
    case invited
    case joined
    case shared
    case worldReadable
}

public struct FfiConverterTypeHistoryVisibility: FfiConverterRustBuffer {
    typealias SwiftType = HistoryVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoryVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invited
        
        case 2: return .joined
        
        case 3: return .shared
        
        case 4: return .worldReadable
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HistoryVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invited:
            writeInt(&buf, Int32(1))
        
        
        case .joined:
            writeInt(&buf, Int32(2))
        
        
        case .shared:
            writeInt(&buf, Int32(3))
        
        
        case .worldReadable:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeHistoryVisibility_lift(_ buf: RustBuffer) throws -> HistoryVisibility {
    return try FfiConverterTypeHistoryVisibility.lift(buf)
}

public func FfiConverterTypeHistoryVisibility_lower(_ value: HistoryVisibility) -> RustBuffer {
    return FfiConverterTypeHistoryVisibility.lower(value)
}


extension HistoryVisibility: Equatable, Hashable {}



public enum KeyImportError {

    
    
    // Simple error enums only carry a message
    case Export(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case Json(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeKeyImportError.lift(error)
    }
}


public struct FfiConverterTypeKeyImportError: FfiConverterRustBuffer {
    typealias SwiftType = KeyImportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyImportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Export(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Json(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyImportError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Export(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Json(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


extension KeyImportError: Equatable, Hashable {}

extension KeyImportError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LocalTrust {
    
    case verified
    case blackListed
    case ignored
    case unset
}

public struct FfiConverterTypeLocalTrust: FfiConverterRustBuffer {
    typealias SwiftType = LocalTrust

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalTrust {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .verified
        
        case 2: return .blackListed
        
        case 3: return .ignored
        
        case 4: return .unset
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LocalTrust, into buf: inout [UInt8]) {
        switch value {
        
        
        case .verified:
            writeInt(&buf, Int32(1))
        
        
        case .blackListed:
            writeInt(&buf, Int32(2))
        
        
        case .ignored:
            writeInt(&buf, Int32(3))
        
        
        case .unset:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeLocalTrust_lift(_ buf: RustBuffer) throws -> LocalTrust {
    return try FfiConverterTypeLocalTrust.lift(buf)
}

public func FfiConverterTypeLocalTrust_lower(_ value: LocalTrust) -> RustBuffer {
    return FfiConverterTypeLocalTrust.lower(value)
}


extension LocalTrust: Equatable, Hashable {}



public enum MigrationError {

    
    
    case Generic(errorMessage: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeMigrationError.lift(error)
    }
}


public struct FfiConverterTypeMigrationError: FfiConverterRustBuffer {
    typealias SwiftType = MigrationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MigrationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MigrationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


extension MigrationError: Equatable, Hashable {}

extension MigrationError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OutgoingVerificationRequest {
    
    case toDevice(requestId: String, eventType: String, body: String)
    case inRoom(requestId: String, roomId: String, eventType: String, content: String)
}

public struct FfiConverterTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingVerificationRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutgoingVerificationRequest {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toDevice(
            requestId: try FfiConverterString.read(from: &buf), 
            eventType: try FfiConverterString.read(from: &buf), 
            body: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .inRoom(
            requestId: try FfiConverterString.read(from: &buf), 
            roomId: try FfiConverterString.read(from: &buf), 
            eventType: try FfiConverterString.read(from: &buf), 
            content: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OutgoingVerificationRequest, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .toDevice(requestId,eventType,body):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .inRoom(requestId,roomId,eventType,content):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(roomId, into: &buf)
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(content, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOutgoingVerificationRequest_lift(_ buf: RustBuffer) throws -> OutgoingVerificationRequest {
    return try FfiConverterTypeOutgoingVerificationRequest.lift(buf)
}

public func FfiConverterTypeOutgoingVerificationRequest_lower(_ value: OutgoingVerificationRequest) -> RustBuffer {
    return FfiConverterTypeOutgoingVerificationRequest.lower(value)
}


extension OutgoingVerificationRequest: Equatable, Hashable {}



public enum PkDecryptionError {

    
    
    // Simple error enums only carry a message
    case Olm(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypePkDecryptionError.lift(error)
    }
}


public struct FfiConverterTypePkDecryptionError: FfiConverterRustBuffer {
    typealias SwiftType = PkDecryptionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PkDecryptionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Olm(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PkDecryptionError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Olm(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension PkDecryptionError: Equatable, Hashable {}

extension PkDecryptionError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum QrCodeState {
    
    case started
    case scanned
    case confirmed
    case reciprocated
    case done
    case cancelled(cancelInfo: CancelInfo)
}

public struct FfiConverterTypeQrCodeState: FfiConverterRustBuffer {
    typealias SwiftType = QrCodeState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCodeState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .started
        
        case 2: return .scanned
        
        case 3: return .confirmed
        
        case 4: return .reciprocated
        
        case 5: return .done
        
        case 6: return .cancelled(
            cancelInfo: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrCodeState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .started:
            writeInt(&buf, Int32(1))
        
        
        case .scanned:
            writeInt(&buf, Int32(2))
        
        
        case .confirmed:
            writeInt(&buf, Int32(3))
        
        
        case .reciprocated:
            writeInt(&buf, Int32(4))
        
        
        case .done:
            writeInt(&buf, Int32(5))
        
        
        case let .cancelled(cancelInfo):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCancelInfo.write(cancelInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeQrCodeState_lift(_ buf: RustBuffer) throws -> QrCodeState {
    return try FfiConverterTypeQrCodeState.lift(buf)
}

public func FfiConverterTypeQrCodeState_lower(_ value: QrCodeState) -> RustBuffer {
    return FfiConverterTypeQrCodeState.lower(value)
}


extension QrCodeState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Request {
    
    case toDevice(requestId: String, eventType: String, body: String)
    case keysUpload(requestId: String, body: String)
    case keysQuery(requestId: String, users: [String])
    case keysClaim(requestId: String, oneTimeKeys: [String: [String: String]])
    case keysBackup(requestId: String, version: String, rooms: String)
    case roomMessage(requestId: String, roomId: String, eventType: String, content: String)
    case signatureUpload(requestId: String, body: String)
}

public struct FfiConverterTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = Request

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Request {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toDevice(
            requestId: try FfiConverterString.read(from: &buf), 
            eventType: try FfiConverterString.read(from: &buf), 
            body: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .keysUpload(
            requestId: try FfiConverterString.read(from: &buf), 
            body: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .keysQuery(
            requestId: try FfiConverterString.read(from: &buf), 
            users: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 4: return .keysClaim(
            requestId: try FfiConverterString.read(from: &buf), 
            oneTimeKeys: try FfiConverterDictionaryStringDictionaryStringString.read(from: &buf)
        )
        
        case 5: return .keysBackup(
            requestId: try FfiConverterString.read(from: &buf), 
            version: try FfiConverterString.read(from: &buf), 
            rooms: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .roomMessage(
            requestId: try FfiConverterString.read(from: &buf), 
            roomId: try FfiConverterString.read(from: &buf), 
            eventType: try FfiConverterString.read(from: &buf), 
            content: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .signatureUpload(
            requestId: try FfiConverterString.read(from: &buf), 
            body: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Request, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .toDevice(requestId,eventType,body):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .keysUpload(requestId,body):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .keysQuery(requestId,users):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterSequenceString.write(users, into: &buf)
            
        
        case let .keysClaim(requestId,oneTimeKeys):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterDictionaryStringDictionaryStringString.write(oneTimeKeys, into: &buf)
            
        
        case let .keysBackup(requestId,version,rooms):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(version, into: &buf)
            FfiConverterString.write(rooms, into: &buf)
            
        
        case let .roomMessage(requestId,roomId,eventType,content):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(roomId, into: &buf)
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(content, into: &buf)
            
        
        case let .signatureUpload(requestId,body):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(requestId, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRequest_lift(_ buf: RustBuffer) throws -> Request {
    return try FfiConverterTypeRequest.lift(buf)
}

public func FfiConverterTypeRequest_lower(_ value: Request) -> RustBuffer {
    return FfiConverterTypeRequest.lower(value)
}


extension Request: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RequestType {
    
    case keysQuery
    case keysClaim
    case keysUpload
    case toDevice
    case signatureUpload
    case keysBackup
    case roomMessage
}

public struct FfiConverterTypeRequestType: FfiConverterRustBuffer {
    typealias SwiftType = RequestType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .keysQuery
        
        case 2: return .keysClaim
        
        case 3: return .keysUpload
        
        case 4: return .toDevice
        
        case 5: return .signatureUpload
        
        case 6: return .keysBackup
        
        case 7: return .roomMessage
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .keysQuery:
            writeInt(&buf, Int32(1))
        
        
        case .keysClaim:
            writeInt(&buf, Int32(2))
        
        
        case .keysUpload:
            writeInt(&buf, Int32(3))
        
        
        case .toDevice:
            writeInt(&buf, Int32(4))
        
        
        case .signatureUpload:
            writeInt(&buf, Int32(5))
        
        
        case .keysBackup:
            writeInt(&buf, Int32(6))
        
        
        case .roomMessage:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeRequestType_lift(_ buf: RustBuffer) throws -> RequestType {
    return try FfiConverterTypeRequestType.lift(buf)
}

public func FfiConverterTypeRequestType_lower(_ value: RequestType) -> RustBuffer {
    return FfiConverterTypeRequestType.lower(value)
}


extension RequestType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SasState {
    
    case started
    case accepted
    case keysExchanged(emojis: [Int32]?, decimals: [Int32])
    case confirmed
    case done
    case cancelled(cancelInfo: CancelInfo)
}

public struct FfiConverterTypeSasState: FfiConverterRustBuffer {
    typealias SwiftType = SasState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SasState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .started
        
        case 2: return .accepted
        
        case 3: return .keysExchanged(
            emojis: try FfiConverterOptionSequenceInt32.read(from: &buf), 
            decimals: try FfiConverterSequenceInt32.read(from: &buf)
        )
        
        case 4: return .confirmed
        
        case 5: return .done
        
        case 6: return .cancelled(
            cancelInfo: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SasState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .started:
            writeInt(&buf, Int32(1))
        
        
        case .accepted:
            writeInt(&buf, Int32(2))
        
        
        case let .keysExchanged(emojis,decimals):
            writeInt(&buf, Int32(3))
            FfiConverterOptionSequenceInt32.write(emojis, into: &buf)
            FfiConverterSequenceInt32.write(decimals, into: &buf)
            
        
        case .confirmed:
            writeInt(&buf, Int32(4))
        
        
        case .done:
            writeInt(&buf, Int32(5))
        
        
        case let .cancelled(cancelInfo):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCancelInfo.write(cancelInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSasState_lift(_ buf: RustBuffer) throws -> SasState {
    return try FfiConverterTypeSasState.lift(buf)
}

public func FfiConverterTypeSasState_lower(_ value: SasState) -> RustBuffer {
    return FfiConverterTypeSasState.lower(value)
}


extension SasState: Equatable, Hashable {}



public enum SecretImportError {

    
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case Import(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeSecretImportError.lift(error)
    }
}


public struct FfiConverterTypeSecretImportError: FfiConverterRustBuffer {
    typealias SwiftType = SecretImportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretImportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Import(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecretImportError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Import(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


extension SecretImportError: Equatable, Hashable {}

extension SecretImportError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ShieldColor {
    
    case red
    case grey
    case none
}

public struct FfiConverterTypeShieldColor: FfiConverterRustBuffer {
    typealias SwiftType = ShieldColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red
        
        case 2: return .grey
        
        case 3: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShieldColor, into buf: inout [UInt8]) {
        switch value {
        
        
        case .red:
            writeInt(&buf, Int32(1))
        
        
        case .grey:
            writeInt(&buf, Int32(2))
        
        
        case .none:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeShieldColor_lift(_ buf: RustBuffer) throws -> ShieldColor {
    return try FfiConverterTypeShieldColor.lift(buf)
}

public func FfiConverterTypeShieldColor_lower(_ value: ShieldColor) -> RustBuffer {
    return FfiConverterTypeShieldColor.lower(value)
}


extension ShieldColor: Equatable, Hashable {}



public enum SignatureError {

    
    
    // Simple error enums only carry a message
    case Signature(message: String)
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case UnknownDevice(message: String)
    
    // Simple error enums only carry a message
    case UnknownUserIdentity(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeSignatureError.lift(error)
    }
}


public struct FfiConverterTypeSignatureError: FfiConverterRustBuffer {
    typealias SwiftType = SignatureError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Signature(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Identifier(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .UnknownDevice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .UnknownUserIdentity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Signature(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Identifier(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .CryptoStore(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .UnknownDevice(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .UnknownUserIdentity(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


extension SignatureError: Equatable, Hashable {}

extension SignatureError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SignatureState {
    
    case missing
    case invalid
    case validButNotTrusted
    case validAndTrusted
}

public struct FfiConverterTypeSignatureState: FfiConverterRustBuffer {
    typealias SwiftType = SignatureState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .missing
        
        case 2: return .invalid
        
        case 3: return .validButNotTrusted
        
        case 4: return .validAndTrusted
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .missing:
            writeInt(&buf, Int32(1))
        
        
        case .invalid:
            writeInt(&buf, Int32(2))
        
        
        case .validButNotTrusted:
            writeInt(&buf, Int32(3))
        
        
        case .validAndTrusted:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSignatureState_lift(_ buf: RustBuffer) throws -> SignatureState {
    return try FfiConverterTypeSignatureState.lift(buf)
}

public func FfiConverterTypeSignatureState_lower(_ value: SignatureState) -> RustBuffer {
    return FfiConverterTypeSignatureState.lower(value)
}


extension SignatureState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UserIdentity {
    
    case own(userId: String, trustsOurOwnDevice: Bool, masterKey: String, userSigningKey: String, selfSigningKey: String)
    case other(userId: String, masterKey: String, selfSigningKey: String)
}

public struct FfiConverterTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserIdentity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .own(
            userId: try FfiConverterString.read(from: &buf), 
            trustsOurOwnDevice: try FfiConverterBool.read(from: &buf), 
            masterKey: try FfiConverterString.read(from: &buf), 
            userSigningKey: try FfiConverterString.read(from: &buf), 
            selfSigningKey: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .other(
            userId: try FfiConverterString.read(from: &buf), 
            masterKey: try FfiConverterString.read(from: &buf), 
            selfSigningKey: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UserIdentity, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .own(userId,trustsOurOwnDevice,masterKey,userSigningKey,selfSigningKey):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterBool.write(trustsOurOwnDevice, into: &buf)
            FfiConverterString.write(masterKey, into: &buf)
            FfiConverterString.write(userSigningKey, into: &buf)
            FfiConverterString.write(selfSigningKey, into: &buf)
            
        
        case let .other(userId,masterKey,selfSigningKey):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterString.write(masterKey, into: &buf)
            FfiConverterString.write(selfSigningKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUserIdentity_lift(_ buf: RustBuffer) throws -> UserIdentity {
    return try FfiConverterTypeUserIdentity.lift(buf)
}

public func FfiConverterTypeUserIdentity_lower(_ value: UserIdentity) -> RustBuffer {
    return FfiConverterTypeUserIdentity.lower(value)
}


extension UserIdentity: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VerificationRequestState {
    
    case requested
    case ready(theirMethods: [String], ourMethods: [String])
    case done
    case cancelled(cancelInfo: CancelInfo)
}

public struct FfiConverterTypeVerificationRequestState: FfiConverterRustBuffer {
    typealias SwiftType = VerificationRequestState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationRequestState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .requested
        
        case 2: return .ready(
            theirMethods: try FfiConverterSequenceString.read(from: &buf), 
            ourMethods: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 3: return .done
        
        case 4: return .cancelled(
            cancelInfo: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerificationRequestState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .requested:
            writeInt(&buf, Int32(1))
        
        
        case let .ready(theirMethods,ourMethods):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceString.write(theirMethods, into: &buf)
            FfiConverterSequenceString.write(ourMethods, into: &buf)
            
        
        case .done:
            writeInt(&buf, Int32(3))
        
        
        case let .cancelled(cancelInfo):
            writeInt(&buf, Int32(4))
            FfiConverterTypeCancelInfo.write(cancelInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeVerificationRequestState_lift(_ buf: RustBuffer) throws -> VerificationRequestState {
    return try FfiConverterTypeVerificationRequestState.lift(buf)
}

public func FfiConverterTypeVerificationRequestState_lower(_ value: VerificationRequestState) -> RustBuffer {
    return FfiConverterTypeVerificationRequestState.lower(value)
}


extension VerificationRequestState: Equatable, Hashable {}



fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for Logger Callback Interface

public protocol Logger : AnyObject {
    func log(logLine: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceLogger : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeLog(_ swiftCallbackInterface: Logger, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.log(
                    logLine:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceLogger.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: Logger
            do {
                cb = try FfiConverterCallbackInterfaceLogger.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Logger: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeLog(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceLogger {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_crypto_ffi_fn_init_callback_logger(foreignCallbackCallbackInterfaceLogger, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<Logger>()
}

extension FfiConverterCallbackInterfaceLogger : FfiConverter {
    typealias SwiftType = Logger
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for ProgressListener Callback Interface

public protocol ProgressListener : AnyObject {
    func onProgress(progress: Int32, total: Int32) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceProgressListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnProgress(_ swiftCallbackInterface: ProgressListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onProgress(
                    progress:  try FfiConverterInt32.read(from: &reader), 
                    total:  try FfiConverterInt32.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceProgressListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: ProgressListener
            do {
                cb = try FfiConverterCallbackInterfaceProgressListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("ProgressListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnProgress(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceProgressListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_crypto_ffi_fn_init_callback_progresslistener(foreignCallbackCallbackInterfaceProgressListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<ProgressListener>()
}

extension FfiConverterCallbackInterfaceProgressListener : FfiConverter {
    typealias SwiftType = ProgressListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for QrCodeListener Callback Interface

public protocol QrCodeListener : AnyObject {
    func onChange(state: QrCodeState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceQrCodeListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnChange(_ swiftCallbackInterface: QrCodeListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onChange(
                    state:  try FfiConverterTypeQrCodeState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceQrCodeListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: QrCodeListener
            do {
                cb = try FfiConverterCallbackInterfaceQrCodeListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("QrCodeListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnChange(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceQrCodeListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_crypto_ffi_fn_init_callback_qrcodelistener(foreignCallbackCallbackInterfaceQrCodeListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<QrCodeListener>()
}

extension FfiConverterCallbackInterfaceQrCodeListener : FfiConverter {
    typealias SwiftType = QrCodeListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SasListener Callback Interface

public protocol SasListener : AnyObject {
    func onChange(state: SasState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSasListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnChange(_ swiftCallbackInterface: SasListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onChange(
                    state:  try FfiConverterTypeSasState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSasListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SasListener
            do {
                cb = try FfiConverterCallbackInterfaceSasListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SasListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnChange(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSasListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_crypto_ffi_fn_init_callback_saslistener(foreignCallbackCallbackInterfaceSasListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SasListener>()
}

extension FfiConverterCallbackInterfaceSasListener : FfiConverter {
    typealias SwiftType = SasListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for VerificationRequestListener Callback Interface

public protocol VerificationRequestListener : AnyObject {
    func onChange(state: VerificationRequestState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceVerificationRequestListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnChange(_ swiftCallbackInterface: VerificationRequestListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onChange(
                    state:  try FfiConverterTypeVerificationRequestState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceVerificationRequestListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: VerificationRequestListener
            do {
                cb = try FfiConverterCallbackInterfaceVerificationRequestListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("VerificationRequestListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnChange(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceVerificationRequestListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_crypto_ffi_fn_init_callback_verificationrequestlistener(foreignCallbackCallbackInterfaceVerificationRequestListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<VerificationRequestListener>()
}

extension FfiConverterCallbackInterfaceVerificationRequestListener : FfiConverter {
    typealias SwiftType = VerificationRequestListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackupKeys: FfiConverterRustBuffer {
    typealias SwiftType = BackupKeys?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackupKeys.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupKeys.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackupRecoveryKey: FfiConverterRustBuffer {
    typealias SwiftType = BackupRecoveryKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackupRecoveryKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupRecoveryKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeQrCode: FfiConverterRustBuffer {
    typealias SwiftType = QrCode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeQrCode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeQrCode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSas: FfiConverterRustBuffer {
    typealias SwiftType = Sas?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSas.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSas.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerification: FfiConverterRustBuffer {
    typealias SwiftType = Verification?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVerification.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerification.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = VerificationRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVerificationRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerificationRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCancelInfo: FfiConverterRustBuffer {
    typealias SwiftType = CancelInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCancelInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCancelInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeConfirmVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmVerificationResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConfirmVerificationResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConfirmVerificationResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCrossSigningKeyExport: FfiConverterRustBuffer {
    typealias SwiftType = CrossSigningKeyExport?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCrossSigningKeyExport.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCrossSigningKeyExport.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDevice: FfiConverterRustBuffer {
    typealias SwiftType = Device?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDevice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDevice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePassphraseInfo: FfiConverterRustBuffer {
    typealias SwiftType = PassphraseInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePassphraseInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePassphraseInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRequestVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = RequestVerificationResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequestVerificationResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequestVerificationResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomSettings: FfiConverterRustBuffer {
    typealias SwiftType = RoomSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeScanResult: FfiConverterRustBuffer {
    typealias SwiftType = ScanResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeScanResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeScanResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSignatureUploadRequest: FfiConverterRustBuffer {
    typealias SwiftType = SignatureUploadRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignatureUploadRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignatureUploadRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeStartSasResult: FfiConverterRustBuffer {
    typealias SwiftType = StartSasResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStartSasResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStartSasResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingVerificationRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutgoingVerificationRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = Request?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserIdentity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserIdentity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]

    public static func write(_ value: [Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int32] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = [VerificationRequest]

    public static func write(_ value: [VerificationRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerificationRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerificationRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerificationRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerificationRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDevice: FfiConverterRustBuffer {
    typealias SwiftType = [Device]

    public static func write(_ value: [Device], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDevice.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Device] {
        let len: Int32 = try readInt(&buf)
        var seq = [Device]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDevice.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePickledInboundGroupSession: FfiConverterRustBuffer {
    typealias SwiftType = [PickledInboundGroupSession]

    public static func write(_ value: [PickledInboundGroupSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePickledInboundGroupSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PickledInboundGroupSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [PickledInboundGroupSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePickledInboundGroupSession.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePickledSession: FfiConverterRustBuffer {
    typealias SwiftType = [PickledSession]

    public static func write(_ value: [PickledSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePickledSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PickledSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [PickledSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePickledSession.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomKeyInfo: FfiConverterRustBuffer {
    typealias SwiftType = [RoomKeyInfo]

    public static func write(_ value: [RoomKeyInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomKeyInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomKeyInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomKeyInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomKeyInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = [OutgoingVerificationRequest]

    public static func write(_ value: [OutgoingVerificationRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutgoingVerificationRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutgoingVerificationRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutgoingVerificationRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutgoingVerificationRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = [Request]

    public static func write(_ value: [Request], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Request] {
        let len: Int32 = try readInt(&buf)
        var seq = [Request]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringInt32: FfiConverterRustBuffer {
    public static func write(_ value: [String: Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterInt32.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Int32] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Int32]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterInt32.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeRoomSettings: FfiConverterRustBuffer {
    public static func write(_ value: [String: RoomSettings], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeRoomSettings.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: RoomSettings] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: RoomSettings]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeRoomSettings.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeSignatureState: FfiConverterRustBuffer {
    public static func write(_ value: [String: SignatureState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeSignatureState.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: SignatureState] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: SignatureState]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeSignatureState.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: [String]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: [String]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: [String]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func migrate(data: MigrationData, path: String, passphrase: String?, progressListener: ProgressListener) throws {
    try rustCallWithError(FfiConverterTypeMigrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_func_migrate(
        FfiConverterTypeMigrationData.lower(data),
        FfiConverterString.lower(path),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterCallbackInterfaceProgressListener.lower(progressListener),$0)
}
}



public func migrateRoomSettings(roomSettings: [String: RoomSettings], path: String, passphrase: String?) throws {
    try rustCallWithError(FfiConverterTypeMigrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_func_migrate_room_settings(
        FfiConverterDictionaryStringTypeRoomSettings.lower(roomSettings),
        FfiConverterString.lower(path),
        FfiConverterOptionString.lower(passphrase),$0)
}
}



public func migrateSessions(data: SessionMigrationData, path: String, passphrase: String?, progressListener: ProgressListener) throws {
    try rustCallWithError(FfiConverterTypeMigrationError.lift) {
    uniffi_matrix_sdk_crypto_ffi_fn_func_migrate_sessions(
        FfiConverterTypeSessionMigrationData.lower(data),
        FfiConverterString.lower(path),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterCallbackInterfaceProgressListener.lower(progressListener),$0)
}
}



public func setLogger(logger: Logger)  {
    try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_func_set_logger(
        FfiConverterCallbackInterfaceLogger.lower(logger),$0)
}
}



public func version()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_func_version($0)
}
    )
}

public func versionInfo()  -> VersionInfo {
    return try!  FfiConverterTypeVersionInfo.lift(
        try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_func_version_info($0)
}
    )
}

public func vodozemacVersion()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_matrix_sdk_crypto_ffi_fn_func_vodozemac_version($0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 24
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_matrix_sdk_crypto_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_migrate() != 7719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_migrate_room_settings() != 60199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_migrate_sessions() != 6565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_set_logger() != 5690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_version() != 3558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_version_info() != 6655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_func_vodozemac_version() != 57553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backupkeys_backup_version() != 20065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backupkeys_recovery_key() != 282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backuprecoverykey_decrypt_v1() != 30957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backuprecoverykey_megolm_v1_public_key() != 60161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backuprecoverykey_to_base58() != 12924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_backuprecoverykey_to_base64() != 20586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_dehydrateddevice_keys_for_upload() != 815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_dehydrateddevices_create() != 63063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_dehydrateddevices_rehydrate() != 48844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_backup_enabled() != 56538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_backup_room_keys() != 54771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_bootstrap_cross_signing() != 39610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_cross_signing_status() != 58286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_decrypt_room_event() != 12589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_dehydrated_devices() != 59153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_device_id() != 42401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_disable_backup() != 34924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_discard_room_key() != 27091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_enable_backup_v1() != 53539) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_encrypt() != 60621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_export_cross_signing_keys() != 17889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_export_room_keys() != 35722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_backup_keys() != 53143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_device() != 63551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_identity() != 53827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_missing_sessions() != 52693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_only_allow_trusted_devices() != 44229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_room_settings() != 27344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_user_devices() != 61462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_verification() != 63845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_verification_request() != 18172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_get_verification_requests() != 54863) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_identity_keys() != 51817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_import_cross_signing_keys() != 42815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_import_decrypted_room_keys() != 36003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_import_room_keys() != 4173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_is_identity_verified() != 45888) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_is_user_tracked() != 60268) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_mark_request_as_sent() != 52551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_outgoing_requests() != 59999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_query_missing_secrets_from_other_sessions() != 53304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_receive_sync_changes() != 42547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_receive_unencrypted_verification_event() != 33700) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_receive_verification_event() != 28100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_request_room_key() != 3237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_request_self_verification() != 12393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_request_verification() != 31686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_request_verification_with_device() != 51643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_room_key_counts() != 40676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_save_recovery_key() != 14775) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_set_local_trust() != 455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_set_only_allow_trusted_devices() != 46236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_set_room_algorithm() != 14381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_set_room_only_allow_trusted_devices() != 55781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_share_room_history_keys() != 5556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_share_room_key() != 16055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_sign() != 21907) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_start_sas_with_device() != 51470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_update_tracked_users() != 37800) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_user_id() != 22260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_verification_request_content() != 2536) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_verify_backup() != 35385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_verify_device() != 30128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_olmmachine_verify_identity() != 60719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_cancel() != 33752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_cancel_info() != 38875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_confirm() != 23522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_flow_id() != 6460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_generate_qr_code() != 25050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_has_been_scanned() != 54492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_is_cancelled() != 24341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_is_done() != 28598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_other_device_id() != 49521) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_other_user_id() != 64961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_reciprocated() != 48822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_room_id() != 32340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_set_changes_listener() != 51960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_state() != 19937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcode_we_started() != 62911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_rehydrateddevice_receive_events() != 390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_accept() != 16853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_cancel() != 20964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_confirm() != 23100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_flow_id() != 13532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_get_decimals() != 9029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_get_emoji_indices() != 61898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_is_done() != 26210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_other_device_id() != 12640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_other_user_id() != 19408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_room_id() != 38046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_set_changes_listener() != 46449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_state() != 41548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_sas_we_started() != 27788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verification_as_qr() != 37226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verification_as_sas() != 5105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_accept() != 26607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_cancel() != 28302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_cancel_info() != 10258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_flow_id() != 58598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_is_cancelled() != 29475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_is_done() != 29518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_is_passive() != 2445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_is_ready() != 13517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_other_device_id() != 55914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_other_user_id() != 4081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_our_supported_methods() != 2149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_room_id() != 23019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_scan_qr_code() != 24269) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_set_changes_listener() != 42442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_start_qr_verification() != 4100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_start_sas_verification() != 29922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_state() != 41117) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_their_supported_methods() != 16773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequest_we_started() != 54177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_from_base58() != 16125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_from_base64() != 51840) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_from_passphrase() != 3432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_new() != 39969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_backuprecoverykey_new_from_passphrase() != 19749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_constructor_olmmachine_new() != 55076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_logger_log() != 11403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_progresslistener_on_progress() != 2487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_qrcodelistener_on_change() != 32544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_saslistener_on_change() != 26082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_crypto_ffi_checksum_method_verificationrequestlistener_on_change() != 7850) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}